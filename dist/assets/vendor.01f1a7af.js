var oh=Object.defineProperty;var zo=Object.getOwnPropertySymbols;var lh=Object.prototype.hasOwnProperty,ch=Object.prototype.propertyIsEnumerable;var Bo=(i,e,t)=>e in i?oh(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Oo=(i,e)=>{for(var t in e||(e={}))lh.call(e,t)&&Bo(i,t,e[t]);if(zo)for(var t of zo(e))ch.call(e,t)&&Bo(i,t,e[t]);return i};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Js="135",uh=0,Uo=1,hh=2,Vo=1,fh=2,Yi=3,Ji=0,ot=1,ei=2,Ho=1,vn=0,ji=1,Go=2,ko=3,Wo=4,dh=5,ti=100,ph=101,mh=102,qo=103,Xo=104,gh=200,vh=201,_h=202,yh=203,Zo=204,Yo=205,xh=206,wh=207,Mh=208,bh=209,Sh=210,Eh=0,Th=1,Ah=2,js=3,Ch=4,Lh=5,Rh=6,Ph=7,Pr=0,Nh=1,Ih=2,Gn=0,Dh=1,Fh=2,zh=3,Bh=4,Oh=5,Jo=300,$i=301,Qi=302,$s=303,Qs=304,Nr=306,Ks=307,ea=1e3,Ft=1001,ta=1002,ut=1003,jo=1004,$o=1005,Ut=1006,Uh=1007,Ir=1008,_n=1009,Vh=1010,Hh=1011,Ki=1012,Gh=1013,Dr=1014,yn=1015,ni=1016,kh=1017,Wh=1018,qh=1019,ii=1020,Xh=1021,kn=1022,bt=1023,Zh=1024,Yh=1025,Jh=bt,Wn=1026,ri=1027,jh=1028,$h=1029,Qh=1030,Kh=1031,ef=1032,tf=1033,Qo=33776,Ko=33777,el=33778,tl=33779,nl=35840,il=35841,rl=35842,sl=35843,nf=36196,al=37492,ol=37496,rf=37808,sf=37809,af=37810,of=37811,lf=37812,cf=37813,uf=37814,hf=37815,ff=37816,df=37817,pf=37818,mf=37819,gf=37820,vf=37821,_f=36492,yf=37840,xf=37841,wf=37842,Mf=37843,bf=37844,Sf=37845,Ef=37846,Tf=37847,Af=37848,Cf=37849,Lf=37850,Rf=37851,Pf=37852,Nf=37853,If=2200,Df=2201,Ff=2202,Fr=2300,zr=2301,na=2302,si=2400,ai=2401,Br=2402,ia=2500,ll=2501,zf=0,Tt=3e3,Or=3001,ra=3007,sa=3002,cl=3004,ul=3005,hl=3006,Bf=3200,Of=3201,oi=0,Uf=1,aa=7680,Vf=519,er=35044,Ur=35048,fl="300 es";class qn{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const r=n.slice(0);for(let s=0,a=r.length;s<a;s++)r[s].call(this,e);e.target=null}}}const dt=[];for(let i=0;i<256;i++)dt[i]=(i<16?"0":"")+i.toString(16);const oa=Math.PI/180,la=180/Math.PI;function Qt(){const i=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(dt[i&255]+dt[i>>8&255]+dt[i>>16&255]+dt[i>>24&255]+"-"+dt[e&255]+dt[e>>8&255]+"-"+dt[e>>16&15|64]+dt[e>>24&255]+"-"+dt[t&63|128]+dt[t>>8&255]+"-"+dt[t>>16&255]+dt[t>>24&255]+dt[n&255]+dt[n>>8&255]+dt[n>>16&255]+dt[n>>24&255]).toUpperCase()}function zt(i,e,t){return Math.max(e,Math.min(t,i))}function Hf(i,e){return(i%e+e)%e}function ca(i,e,t){return(1-t)*i+t*e}function dl(i){return(i&i-1)==0&&i!==0}function Gf(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}class le{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),s=this.x-e.x,a=this.y-e.y;return this.x=s*n-a*r+e.x,this.y=s*r+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}le.prototype.isVector2=!0;class pt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,s,a,o,u,h){const c=this.elements;return c[0]=e,c[1]=r,c[2]=o,c[3]=t,c[4]=s,c[5]=u,c[6]=n,c[7]=a,c[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,s=this.elements,a=n[0],o=n[3],u=n[6],h=n[1],c=n[4],l=n[7],f=n[2],d=n[5],v=n[8],m=r[0],_=r[3],p=r[6],g=r[1],y=r[4],x=r[7],M=r[2],S=r[5],w=r[8];return s[0]=a*m+o*g+u*M,s[3]=a*_+o*y+u*S,s[6]=a*p+o*x+u*w,s[1]=h*m+c*g+l*M,s[4]=h*_+c*y+l*S,s[7]=h*p+c*x+l*w,s[2]=f*m+d*g+v*M,s[5]=f*_+d*y+v*S,s[8]=f*p+d*x+v*w,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],c=e[8];return t*a*c-t*o*h-n*s*c+n*o*u+r*s*h-r*a*u}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],c=e[8],l=c*a-o*h,f=o*u-c*s,d=h*s-a*u,v=t*l+n*f+r*d;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/v;return e[0]=l*m,e[1]=(r*h-c*n)*m,e[2]=(o*n-r*a)*m,e[3]=f*m,e[4]=(c*t-r*u)*m,e[5]=(r*s-o*t)*m,e[6]=d*m,e[7]=(n*u-h*t)*m,e[8]=(a*t-n*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,s,a,o){const u=Math.cos(s),h=Math.sin(s);return this.set(n*u,n*h,-n*(u*a+h*o)+a+e,-r*h,r*u,-r*(-h*a+u*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,s=r[0],a=r[3],o=r[6],u=r[1],h=r[4],c=r[7];return r[0]=t*s+n*u,r[3]=t*a+n*h,r[6]=t*o+n*c,r[1]=-n*s+t*u,r[4]=-n*a+t*h,r[7]=-n*o+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<9;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}pt.prototype.isMatrix3=!0;function pl(i){if(i.length===0)return-1/0;let e=i[0];for(let t=1,n=i.length;t<n;++t)i[t]>e&&(e=i[t]);return e}function Vr(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function ml(i,e=0){let t=3735928559^e,n=1103547991^e;for(let r=0,s;r<i.length;r++)s=i.charCodeAt(r),t=Math.imul(t^s,2654435761),n=Math.imul(n^s,1597334677);return t=Math.imul(t^t>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(t^t>>>13,3266489909),4294967296*(2097151&n)+(t>>>0)}let li;class ci{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{li===void 0&&(li=Vr("canvas")),li.width=e.width,li.height=e.height;const n=li.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=li}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let kf=0;class mt extends qn{constructor(e=mt.DEFAULT_IMAGE,t=mt.DEFAULT_MAPPING,n=Ft,r=Ft,s=Ut,a=Ir,o=bt,u=_n,h=1,c=Tt){super();Object.defineProperty(this,"id",{value:kf++}),this.uuid=Qt(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=a,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=u,this.offset=new le(0,0),this.repeat=new le(1,1),this.center=new le(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new pt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=Qt()),!t&&e.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let a=0,o=r.length;a<o;a++)r[a].isDataTexture?s.push(ua(r[a].image)):s.push(ua(r[a]))}else s=ua(r);e.images[r.uuid]={uuid:r.uuid,url:s}}n.image=r.uuid}return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Jo)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ea:e.x=e.x-Math.floor(e.x);break;case Ft:e.x=e.x<0?0:1;break;case ta:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case ea:e.y=e.y-Math.floor(e.y);break;case Ft:e.y=e.y<0?0:1;break;case ta:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}mt.DEFAULT_IMAGE=void 0;mt.DEFAULT_MAPPING=Jo;mt.prototype.isTexture=!0;function ua(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?ci.getDataURL(i):i.data?{data:Array.prototype.slice.call(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class We{constructor(e=0,t=0,n=0,r=1){this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,s=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*t+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*t+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*t+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,s;const a=.01,o=.1,u=e.elements,h=u[0],c=u[4],l=u[8],f=u[1],d=u[5],v=u[9],m=u[2],_=u[6],p=u[10];if(Math.abs(c-f)<a&&Math.abs(l-m)<a&&Math.abs(v-_)<a){if(Math.abs(c+f)<o&&Math.abs(l+m)<o&&Math.abs(v+_)<o&&Math.abs(h+d+p-3)<o)return this.set(1,0,0,0),this;t=Math.PI;const y=(h+1)/2,x=(d+1)/2,M=(p+1)/2,S=(c+f)/4,w=(l+m)/4,C=(v+_)/4;return y>x&&y>M?y<a?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(y),r=S/n,s=w/n):x>M?x<a?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(x),n=S/r,s=C/r):M<a?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(M),n=w/s,r=C/s),this.set(n,r,s,t),this}let g=Math.sqrt((_-v)*(_-v)+(l-m)*(l-m)+(f-c)*(f-c));return Math.abs(g)<.001&&(g=1),this.x=(_-v)/g,this.y=(l-m)/g,this.z=(f-c)/g,this.w=Math.acos((h+d+p-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}We.prototype.isVector4=!0;class Vt extends qn{constructor(e,t,n={}){super();this.width=e,this.height=t,this.depth=1,this.scissor=new We(0,0,e,t),this.scissorTest=!1,this.viewport=new We(0,0,e,t),this.texture=new mt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Ut,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image=Oo({},this.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Vt.prototype.isWebGLRenderTarget=!0;class Wf extends Vt{constructor(e,t,n){super(e,t);const r=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=r.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}Wf.prototype.isWebGLMultipleRenderTargets=!0;class ha extends Vt{constructor(e,t,n={}){super(e,t,n);this.samples=4,this.ignoreDepthForMultisampleCopy=n.ignoreDepth!==void 0?n.ignoreDepth:!0,this.useRenderToTexture=n.useRenderToTexture!==void 0?n.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(e){return super.copy.call(this,e),this.samples=e.samples,this.useRenderToTexture=e.useRenderToTexture,this.useRenderbuffer=e.useRenderbuffer,this}}ha.prototype.isWebGLMultisampleRenderTarget=!0;class At{constructor(e=0,t=0,n=0,r=1){this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,s,a,o){let u=n[r+0],h=n[r+1],c=n[r+2],l=n[r+3];const f=s[a+0],d=s[a+1],v=s[a+2],m=s[a+3];if(o===0){e[t+0]=u,e[t+1]=h,e[t+2]=c,e[t+3]=l;return}if(o===1){e[t+0]=f,e[t+1]=d,e[t+2]=v,e[t+3]=m;return}if(l!==m||u!==f||h!==d||c!==v){let _=1-o;const p=u*f+h*d+c*v+l*m,g=p>=0?1:-1,y=1-p*p;if(y>Number.EPSILON){const M=Math.sqrt(y),S=Math.atan2(M,p*g);_=Math.sin(_*S)/M,o=Math.sin(o*S)/M}const x=o*g;if(u=u*_+f*x,h=h*_+d*x,c=c*_+v*x,l=l*_+m*x,_===1-o){const M=1/Math.sqrt(u*u+h*h+c*c+l*l);u*=M,h*=M,c*=M,l*=M}}e[t]=u,e[t+1]=h,e[t+2]=c,e[t+3]=l}static multiplyQuaternionsFlat(e,t,n,r,s,a){const o=n[r],u=n[r+1],h=n[r+2],c=n[r+3],l=s[a],f=s[a+1],d=s[a+2],v=s[a+3];return e[t]=o*v+c*l+u*d-h*f,e[t+1]=u*v+c*f+h*l-o*d,e[t+2]=h*v+c*d+o*f-u*l,e[t+3]=c*v-o*l-u*f-h*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,s=e._z,a=e._order,o=Math.cos,u=Math.sin,h=o(n/2),c=o(r/2),l=o(s/2),f=u(n/2),d=u(r/2),v=u(s/2);switch(a){case"XYZ":this._x=f*c*l+h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l-f*d*v;break;case"YXZ":this._x=f*c*l+h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l+f*d*v;break;case"ZXY":this._x=f*c*l-h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l-f*d*v;break;case"ZYX":this._x=f*c*l-h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l+f*d*v;break;case"YZX":this._x=f*c*l+h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l-f*d*v;break;case"XZY":this._x=f*c*l-h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l+f*d*v;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],s=t[8],a=t[1],o=t[5],u=t[9],h=t[2],c=t[6],l=t[10],f=n+o+l;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(c-u)*d,this._y=(s-h)*d,this._z=(a-r)*d}else if(n>o&&n>l){const d=2*Math.sqrt(1+n-o-l);this._w=(c-u)/d,this._x=.25*d,this._y=(r+a)/d,this._z=(s+h)/d}else if(o>l){const d=2*Math.sqrt(1+o-n-l);this._w=(s-h)/d,this._x=(r+a)/d,this._y=.25*d,this._z=(u+c)/d}else{const d=2*Math.sqrt(1+l-n-o);this._w=(a-r)/d,this._x=(s+h)/d,this._y=(u+c)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(zt(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,s=e._z,a=e._w,o=t._x,u=t._y,h=t._z,c=t._w;return this._x=n*c+a*o+r*h-s*u,this._y=r*c+a*u+s*o-n*h,this._z=s*c+a*h+n*u-r*o,this._w=a*c-n*o-r*u-s*h,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*e._w+n*e._x+r*e._y+s*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const u=1-o*o;if(u<=Number.EPSILON){const d=1-t;return this._w=d*a+t*this._w,this._x=d*n+t*this._x,this._y=d*r+t*this._y,this._z=d*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(u),c=Math.atan2(h,o),l=Math.sin((1-t)*c)/h,f=Math.sin(t*c)/h;return this._w=a*l+this._w*f,this._x=n*l+this._x*f,this._y=r*l+this._y*f,this._z=s*l+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(s),n*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}At.prototype.isQuaternion=!0;class P{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(gl.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(gl.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*r,this.y=s[1]*t+s[4]*n+s[7]*r,this.z=s[2]*t+s[5]*n+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,s=e.elements,a=1/(s[3]*t+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*t+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*t+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,s=e.x,a=e.y,o=e.z,u=e.w,h=u*t+a*r-o*n,c=u*n+o*t-s*r,l=u*r+s*n-a*t,f=-s*t-a*n-o*r;return this.x=h*u+f*-s+c*-o-l*-a,this.y=c*u+f*-a+l*-s-h*-o,this.z=l*u+f*-o+h*-a-c*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*r,this.y=s[1]*t+s[5]*n+s[9]*r,this.z=s[2]*t+s[6]*n+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,s=e.z,a=t.x,o=t.y,u=t.z;return this.x=r*u-s*o,this.y=s*a-n*u,this.z=n*o-r*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return fa.copy(this).projectOnVector(e),this.sub(fa)}reflect(e){return this.sub(fa.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(zt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}P.prototype.isVector3=!0;const fa=new P,gl=new At;class Wt{constructor(e=new P(1/0,1/0,1/0),t=new P(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let u=0,h=e.length;u<h;u+=3){const c=e[u],l=e[u+1],f=e[u+2];c<t&&(t=c),l<n&&(n=l),f<r&&(r=f),c>s&&(s=c),l>a&&(a=l),f>o&&(o=f)}return this.min.set(t,n,r),this.max.set(s,a,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let u=0,h=e.count;u<h;u++){const c=e.getX(u),l=e.getY(u),f=e.getZ(u);c<t&&(t=c),l<n&&(n=l),f<r&&(r=f),c>s&&(s=c),l>a&&(a=l),f>o&&(o=f)}return this.min.set(t,n,r),this.max.set(s,a,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=tr.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),da.copy(t.boundingBox),da.applyMatrix4(e.matrixWorld),this.union(da));const n=e.children;for(let r=0,s=n.length;r<s;r++)this.expandByObject(n[r]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,tr),tr.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(nr),Hr.subVectors(this.max,nr),ui.subVectors(e.a,nr),hi.subVectors(e.b,nr),fi.subVectors(e.c,nr),xn.subVectors(hi,ui),wn.subVectors(fi,hi),Xn.subVectors(ui,fi);let t=[0,-xn.z,xn.y,0,-wn.z,wn.y,0,-Xn.z,Xn.y,xn.z,0,-xn.x,wn.z,0,-wn.x,Xn.z,0,-Xn.x,-xn.y,xn.x,0,-wn.y,wn.x,0,-Xn.y,Xn.x,0];return!pa(t,ui,hi,fi,Hr)||(t=[1,0,0,0,1,0,0,0,1],!pa(t,ui,hi,fi,Hr))?!1:(Gr.crossVectors(xn,wn),t=[Gr.x,Gr.y,Gr.z],pa(t,ui,hi,fi,Hr))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return tr.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(tr).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(an[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),an[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),an[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),an[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),an[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),an[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),an[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),an[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(an),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Wt.prototype.isBox3=!0;const an=[new P,new P,new P,new P,new P,new P,new P,new P],tr=new P,da=new Wt,ui=new P,hi=new P,fi=new P,xn=new P,wn=new P,Xn=new P,nr=new P,Hr=new P,Gr=new P,Zn=new P;function pa(i,e,t,n,r){for(let s=0,a=i.length-3;s<=a;s+=3){Zn.fromArray(i,s);const o=r.x*Math.abs(Zn.x)+r.y*Math.abs(Zn.y)+r.z*Math.abs(Zn.z),u=e.dot(Zn),h=t.dot(Zn),c=n.dot(Zn);if(Math.max(-Math.max(u,h,c),Math.min(u,h,c))>o)return!1}return!0}const qf=new Wt,vl=new P,ma=new P,ga=new P;class di{constructor(e=new P,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):qf.setFromPoints(e).getCenter(n);let r=0;for(let s=0,a=e.length;s<a;s++)r=Math.max(r,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){ga.subVectors(e,this.center);const t=ga.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),r=(n-this.radius)*.5;this.center.add(ga.multiplyScalar(r/n)),this.radius+=r}return this}union(e){return ma.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(vl.copy(e.center).add(ma)),this.expandByPoint(vl.copy(e.center).sub(ma)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const on=new P,va=new P,kr=new P,Mn=new P,_a=new P,Wr=new P,ya=new P;class pi{constructor(e=new P,t=new P(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,on)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=on.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(on.copy(this.direction).multiplyScalar(t).add(this.origin),on.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){va.copy(e).add(t).multiplyScalar(.5),kr.copy(t).sub(e).normalize(),Mn.copy(this.origin).sub(va);const s=e.distanceTo(t)*.5,a=-this.direction.dot(kr),o=Mn.dot(this.direction),u=-Mn.dot(kr),h=Mn.lengthSq(),c=Math.abs(1-a*a);let l,f,d,v;if(c>0)if(l=a*u-o,f=a*o-u,v=s*c,l>=0)if(f>=-v)if(f<=v){const m=1/c;l*=m,f*=m,d=l*(l+a*f+2*o)+f*(a*l+f+2*u)+h}else f=s,l=Math.max(0,-(a*f+o)),d=-l*l+f*(f+2*u)+h;else f=-s,l=Math.max(0,-(a*f+o)),d=-l*l+f*(f+2*u)+h;else f<=-v?(l=Math.max(0,-(-a*s+o)),f=l>0?-s:Math.min(Math.max(-s,-u),s),d=-l*l+f*(f+2*u)+h):f<=v?(l=0,f=Math.min(Math.max(-s,-u),s),d=f*(f+2*u)+h):(l=Math.max(0,-(a*s+o)),f=l>0?s:Math.min(Math.max(-s,-u),s),d=-l*l+f*(f+2*u)+h);else f=a>0?-s:s,l=Math.max(0,-(a*f+o)),d=-l*l+f*(f+2*u)+h;return n&&n.copy(this.direction).multiplyScalar(l).add(this.origin),r&&r.copy(kr).multiplyScalar(f).add(va),d}intersectSphere(e,t){on.subVectors(e.center,this.origin);const n=on.dot(this.direction),r=on.dot(on)-n*n,s=e.radius*e.radius;if(r>s)return null;const a=Math.sqrt(s-r),o=n-a,u=n+a;return o<0&&u<0?null:o<0?this.at(u,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,s,a,o,u;const h=1/this.direction.x,c=1/this.direction.y,l=1/this.direction.z,f=this.origin;return h>=0?(n=(e.min.x-f.x)*h,r=(e.max.x-f.x)*h):(n=(e.max.x-f.x)*h,r=(e.min.x-f.x)*h),c>=0?(s=(e.min.y-f.y)*c,a=(e.max.y-f.y)*c):(s=(e.max.y-f.y)*c,a=(e.min.y-f.y)*c),n>a||s>r||((s>n||n!==n)&&(n=s),(a<r||r!==r)&&(r=a),l>=0?(o=(e.min.z-f.z)*l,u=(e.max.z-f.z)*l):(o=(e.max.z-f.z)*l,u=(e.min.z-f.z)*l),n>u||o>r)||((o>n||n!==n)&&(n=o),(u<r||r!==r)&&(r=u),r<0)?null:this.at(n>=0?n:r,t)}intersectsBox(e){return this.intersectBox(e,on)!==null}intersectTriangle(e,t,n,r,s){_a.subVectors(t,e),Wr.subVectors(n,e),ya.crossVectors(_a,Wr);let a=this.direction.dot(ya),o;if(a>0){if(r)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Mn.subVectors(this.origin,e);const u=o*this.direction.dot(Wr.crossVectors(Mn,Wr));if(u<0)return null;const h=o*this.direction.dot(_a.cross(Mn));if(h<0||u+h>a)return null;const c=-o*Mn.dot(ya);return c<0?null:this.at(c/a,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Re{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,s,a,o,u,h,c,l,f,d,v,m,_){const p=this.elements;return p[0]=e,p[4]=t,p[8]=n,p[12]=r,p[1]=s,p[5]=a,p[9]=o,p[13]=u,p[2]=h,p[6]=c,p[10]=l,p[14]=f,p[3]=d,p[7]=v,p[11]=m,p[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Re().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/mi.setFromMatrixColumn(e,0).length(),s=1/mi.setFromMatrixColumn(e,1).length(),a=1/mi.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,s=e.z,a=Math.cos(n),o=Math.sin(n),u=Math.cos(r),h=Math.sin(r),c=Math.cos(s),l=Math.sin(s);if(e.order==="XYZ"){const f=a*c,d=a*l,v=o*c,m=o*l;t[0]=u*c,t[4]=-u*l,t[8]=h,t[1]=d+v*h,t[5]=f-m*h,t[9]=-o*u,t[2]=m-f*h,t[6]=v+d*h,t[10]=a*u}else if(e.order==="YXZ"){const f=u*c,d=u*l,v=h*c,m=h*l;t[0]=f+m*o,t[4]=v*o-d,t[8]=a*h,t[1]=a*l,t[5]=a*c,t[9]=-o,t[2]=d*o-v,t[6]=m+f*o,t[10]=a*u}else if(e.order==="ZXY"){const f=u*c,d=u*l,v=h*c,m=h*l;t[0]=f-m*o,t[4]=-a*l,t[8]=v+d*o,t[1]=d+v*o,t[5]=a*c,t[9]=m-f*o,t[2]=-a*h,t[6]=o,t[10]=a*u}else if(e.order==="ZYX"){const f=a*c,d=a*l,v=o*c,m=o*l;t[0]=u*c,t[4]=v*h-d,t[8]=f*h+m,t[1]=u*l,t[5]=m*h+f,t[9]=d*h-v,t[2]=-h,t[6]=o*u,t[10]=a*u}else if(e.order==="YZX"){const f=a*u,d=a*h,v=o*u,m=o*h;t[0]=u*c,t[4]=m-f*l,t[8]=v*l+d,t[1]=l,t[5]=a*c,t[9]=-o*c,t[2]=-h*c,t[6]=d*l+v,t[10]=f-m*l}else if(e.order==="XZY"){const f=a*u,d=a*h,v=o*u,m=o*h;t[0]=u*c,t[4]=-l,t[8]=h*c,t[1]=f*l+m,t[5]=a*c,t[9]=d*l-v,t[2]=v*l-d,t[6]=o*c,t[10]=m*l+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Xf,e,Zf)}lookAt(e,t,n){const r=this.elements;return Bt.subVectors(e,t),Bt.lengthSq()===0&&(Bt.z=1),Bt.normalize(),bn.crossVectors(n,Bt),bn.lengthSq()===0&&(Math.abs(n.z)===1?Bt.x+=1e-4:Bt.z+=1e-4,Bt.normalize(),bn.crossVectors(n,Bt)),bn.normalize(),qr.crossVectors(Bt,bn),r[0]=bn.x,r[4]=qr.x,r[8]=Bt.x,r[1]=bn.y,r[5]=qr.y,r[9]=Bt.y,r[2]=bn.z,r[6]=qr.z,r[10]=Bt.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,s=this.elements,a=n[0],o=n[4],u=n[8],h=n[12],c=n[1],l=n[5],f=n[9],d=n[13],v=n[2],m=n[6],_=n[10],p=n[14],g=n[3],y=n[7],x=n[11],M=n[15],S=r[0],w=r[4],C=r[8],I=r[12],D=r[1],T=r[5],O=r[9],B=r[13],F=r[2],z=r[6],N=r[10],U=r[14],Y=r[3],ee=r[7],k=r[11],q=r[15];return s[0]=a*S+o*D+u*F+h*Y,s[4]=a*w+o*T+u*z+h*ee,s[8]=a*C+o*O+u*N+h*k,s[12]=a*I+o*B+u*U+h*q,s[1]=c*S+l*D+f*F+d*Y,s[5]=c*w+l*T+f*z+d*ee,s[9]=c*C+l*O+f*N+d*k,s[13]=c*I+l*B+f*U+d*q,s[2]=v*S+m*D+_*F+p*Y,s[6]=v*w+m*T+_*z+p*ee,s[10]=v*C+m*O+_*N+p*k,s[14]=v*I+m*B+_*U+p*q,s[3]=g*S+y*D+x*F+M*Y,s[7]=g*w+y*T+x*z+M*ee,s[11]=g*C+y*O+x*N+M*k,s[15]=g*I+y*B+x*U+M*q,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],s=e[12],a=e[1],o=e[5],u=e[9],h=e[13],c=e[2],l=e[6],f=e[10],d=e[14],v=e[3],m=e[7],_=e[11],p=e[15];return v*(+s*u*l-r*h*l-s*o*f+n*h*f+r*o*d-n*u*d)+m*(+t*u*d-t*h*f+s*a*f-r*a*d+r*h*c-s*u*c)+_*(+t*h*l-t*o*d-s*a*l+n*a*d+s*o*c-n*h*c)+p*(-r*o*c-t*u*l+t*o*f+r*a*l-n*a*f+n*u*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],o=e[5],u=e[6],h=e[7],c=e[8],l=e[9],f=e[10],d=e[11],v=e[12],m=e[13],_=e[14],p=e[15],g=l*_*h-m*f*h+m*u*d-o*_*d-l*u*p+o*f*p,y=v*f*h-c*_*h-v*u*d+a*_*d+c*u*p-a*f*p,x=c*m*h-v*l*h+v*o*d-a*m*d-c*o*p+a*l*p,M=v*l*u-c*m*u-v*o*f+a*m*f+c*o*_-a*l*_,S=t*g+n*y+r*x+s*M;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/S;return e[0]=g*w,e[1]=(m*f*s-l*_*s-m*r*d+n*_*d+l*r*p-n*f*p)*w,e[2]=(o*_*s-m*u*s+m*r*h-n*_*h-o*r*p+n*u*p)*w,e[3]=(l*u*s-o*f*s-l*r*h+n*f*h+o*r*d-n*u*d)*w,e[4]=y*w,e[5]=(c*_*s-v*f*s+v*r*d-t*_*d-c*r*p+t*f*p)*w,e[6]=(v*u*s-a*_*s-v*r*h+t*_*h+a*r*p-t*u*p)*w,e[7]=(a*f*s-c*u*s+c*r*h-t*f*h-a*r*d+t*u*d)*w,e[8]=x*w,e[9]=(v*l*s-c*m*s-v*n*d+t*m*d+c*n*p-t*l*p)*w,e[10]=(a*m*s-v*o*s+v*n*h-t*m*h-a*n*p+t*o*p)*w,e[11]=(c*o*s-a*l*s-c*n*h+t*l*h+a*n*d-t*o*d)*w,e[12]=M*w,e[13]=(c*m*r-v*l*r+v*n*f-t*m*f-c*n*_+t*l*_)*w,e[14]=(v*o*r-a*m*r-v*n*u+t*m*u+a*n*_-t*o*_)*w,e[15]=(a*l*r-c*o*r+c*n*u-t*l*u-a*n*f+t*o*f)*w,this}scale(e){const t=this.elements,n=e.x,r=e.y,s=e.z;return t[0]*=n,t[4]*=r,t[8]*=s,t[1]*=n,t[5]*=r,t[9]*=s,t[2]*=n,t[6]*=r,t[10]*=s,t[3]*=n,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),s=1-n,a=e.x,o=e.y,u=e.z,h=s*a,c=s*o;return this.set(h*a+n,h*o-r*u,h*u+r*o,0,h*o+r*u,c*o+n,c*u-r*a,0,h*u-r*o,c*u+r*a,s*u*u+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,r,s,a){return this.set(1,n,s,0,e,1,a,0,t,r,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,s=t._x,a=t._y,o=t._z,u=t._w,h=s+s,c=a+a,l=o+o,f=s*h,d=s*c,v=s*l,m=a*c,_=a*l,p=o*l,g=u*h,y=u*c,x=u*l,M=n.x,S=n.y,w=n.z;return r[0]=(1-(m+p))*M,r[1]=(d+x)*M,r[2]=(v-y)*M,r[3]=0,r[4]=(d-x)*S,r[5]=(1-(f+p))*S,r[6]=(_+g)*S,r[7]=0,r[8]=(v+y)*w,r[9]=(_-g)*w,r[10]=(1-(f+m))*w,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let s=mi.set(r[0],r[1],r[2]).length();const a=mi.set(r[4],r[5],r[6]).length(),o=mi.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],qt.copy(this);const h=1/s,c=1/a,l=1/o;return qt.elements[0]*=h,qt.elements[1]*=h,qt.elements[2]*=h,qt.elements[4]*=c,qt.elements[5]*=c,qt.elements[6]*=c,qt.elements[8]*=l,qt.elements[9]*=l,qt.elements[10]*=l,t.setFromRotationMatrix(qt),n.x=s,n.y=a,n.z=o,this}makePerspective(e,t,n,r,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,u=2*s/(t-e),h=2*s/(n-r),c=(t+e)/(t-e),l=(n+r)/(n-r),f=-(a+s)/(a-s),d=-2*a*s/(a-s);return o[0]=u,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=l,o[13]=0,o[2]=0,o[6]=0,o[10]=f,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,r,s,a){const o=this.elements,u=1/(t-e),h=1/(n-r),c=1/(a-s),l=(t+e)*u,f=(n+r)*h,d=(a+s)*c;return o[0]=2*u,o[4]=0,o[8]=0,o[12]=-l,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-f,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<16;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Re.prototype.isMatrix4=!0;const mi=new P,qt=new Re,Xf=new P(0,0,0),Zf=new P(1,1,1),bn=new P,qr=new P,Bt=new P,_l=new Re,yl=new At;class gi{constructor(e=0,t=0,n=0,r=gi.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r=this._order){return this._x=e,this._y=t,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const r=e.elements,s=r[0],a=r[4],o=r[8],u=r[1],h=r[5],c=r[9],l=r[2],f=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(zt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-zt(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(u,h)):(this._y=Math.atan2(-l,s),this._z=0);break;case"ZXY":this._x=Math.asin(zt(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-l,d),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-zt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(f,d),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(zt(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-l,s)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-zt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return _l.makeRotationFromQuaternion(e),this.setFromRotationMatrix(_l,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return yl.setFromEuler(this),this.setFromQuaternion(yl,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new P(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}gi.prototype.isEuler=!0;gi.DefaultOrder="XYZ";gi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Yf{constructor(){this.mask=1|0}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=4294967295|0}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}}let Jf=0;const xl=new P,vi=new At,ln=new Re,Xr=new P,ir=new P,jf=new P,$f=new At,wl=new P(1,0,0),Ml=new P(0,1,0),bl=new P(0,0,1),Qf={type:"added"},Sl={type:"removed"};class He extends qn{constructor(){super();Object.defineProperty(this,"id",{value:Jf++}),this.uuid=Qt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=He.DefaultUp.clone();const e=new P,t=new gi,n=new At,r=new P(1,1,1);function s(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Re},normalMatrix:{value:new pt}}),this.matrix=new Re,this.matrixWorld=new Re,this.matrixAutoUpdate=He.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Yf,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return vi.setFromAxisAngle(e,t),this.quaternion.multiply(vi),this}rotateOnWorldAxis(e,t){return vi.setFromAxisAngle(e,t),this.quaternion.premultiply(vi),this}rotateX(e){return this.rotateOnAxis(wl,e)}rotateY(e){return this.rotateOnAxis(Ml,e)}rotateZ(e){return this.rotateOnAxis(bl,e)}translateOnAxis(e,t){return xl.copy(e).applyQuaternion(this.quaternion),this.position.add(xl.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(wl,e)}translateY(e){return this.translateOnAxis(Ml,e)}translateZ(e){return this.translateOnAxis(bl,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(ln.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?Xr.copy(e):Xr.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),ir.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ln.lookAt(ir,Xr,this.up):ln.lookAt(Xr,ir,this.up),this.quaternion.setFromRotationMatrix(ln),r&&(ln.extractRotation(r.matrixWorld),vi.setFromRotationMatrix(ln),this.quaternion.premultiply(vi.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Qf)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Sl)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Sl)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),ln.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ln.multiply(e.parent.matrixWorld)),e.applyMatrix4(ln),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ir,e,jf),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ir,$f,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,a=r.length;s<a;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(o,u){return o[u.uuid]===void 0&&(o[u.uuid]=u.toJSON(e)),u.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const u=o.shapes;if(Array.isArray(u))for(let h=0,c=u.length;h<c;h++){const l=u[h];s(e.shapes,l)}else s(e.shapes,u)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let u=0,h=this.material.length;u<h;u++)o.push(s(e.materials,this.material[u]));r.material=o}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const u=this.animations[o];r.animations.push(s(e.animations,u))}}if(t){const o=a(e.geometries),u=a(e.materials),h=a(e.textures),c=a(e.images),l=a(e.shapes),f=a(e.skeletons),d=a(e.animations);o.length>0&&(n.geometries=o),u.length>0&&(n.materials=u),h.length>0&&(n.textures=h),c.length>0&&(n.images=c),l.length>0&&(n.shapes=l),f.length>0&&(n.skeletons=f),d.length>0&&(n.animations=d)}return n.object=r,n;function a(o){const u=[];for(const h in o){const c=o[h];delete c.metadata,u.push(c)}return u}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const r=e.children[n];this.add(r.clone())}return this}}He.DefaultUp=new P(0,1,0);He.DefaultMatrixAutoUpdate=!0;He.prototype.isObject3D=!0;const Xt=new P,cn=new P,xa=new P,un=new P,_i=new P,yi=new P,El=new P,wa=new P,Ma=new P,ba=new P;class st{constructor(e=new P,t=new P,n=new P){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t),Xt.subVectors(e,t),r.cross(Xt);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,n,r,s){Xt.subVectors(r,t),cn.subVectors(n,t),xa.subVectors(e,t);const a=Xt.dot(Xt),o=Xt.dot(cn),u=Xt.dot(xa),h=cn.dot(cn),c=cn.dot(xa),l=a*h-o*o;if(l===0)return s.set(-2,-1,-1);const f=1/l,d=(h*u-o*c)*f,v=(a*c-o*u)*f;return s.set(1-d-v,v,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,un),un.x>=0&&un.y>=0&&un.x+un.y<=1}static getUV(e,t,n,r,s,a,o,u){return this.getBarycoord(e,t,n,r,un),u.set(0,0),u.addScaledVector(s,un.x),u.addScaledVector(a,un.y),u.addScaledVector(o,un.z),u}static isFrontFacing(e,t,n,r){return Xt.subVectors(n,t),cn.subVectors(e,t),Xt.cross(cn).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,n,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Xt.subVectors(this.c,this.b),cn.subVectors(this.a,this.b),Xt.cross(cn).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return st.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return st.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,s){return st.getUV(e,this.a,this.b,this.c,t,n,r,s)}containsPoint(e){return st.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return st.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,s=this.c;let a,o;_i.subVectors(r,n),yi.subVectors(s,n),wa.subVectors(e,n);const u=_i.dot(wa),h=yi.dot(wa);if(u<=0&&h<=0)return t.copy(n);Ma.subVectors(e,r);const c=_i.dot(Ma),l=yi.dot(Ma);if(c>=0&&l<=c)return t.copy(r);const f=u*l-c*h;if(f<=0&&u>=0&&c<=0)return a=u/(u-c),t.copy(n).addScaledVector(_i,a);ba.subVectors(e,s);const d=_i.dot(ba),v=yi.dot(ba);if(v>=0&&d<=v)return t.copy(s);const m=d*h-u*v;if(m<=0&&h>=0&&v<=0)return o=h/(h-v),t.copy(n).addScaledVector(yi,o);const _=c*v-d*l;if(_<=0&&l-c>=0&&d-v>=0)return El.subVectors(s,r),o=(l-c)/(l-c+(d-v)),t.copy(r).addScaledVector(El,o);const p=1/(_+m+f);return a=m*p,o=f*p,t.copy(n).addScaledVector(_i,a).addScaledVector(yi,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Kf=0;class yt extends qn{constructor(){super();Object.defineProperty(this,"id",{value:Kf++}),this.uuid=Qt(),this.name="",this.type="Material",this.fog=!0,this.blending=ji,this.side=Ji,this.vertexColors=!1,this.opacity=1,this.format=bt,this.transparent=!1,this.blendSrc=Zo,this.blendDst=Yo,this.blendEquation=ti,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=js,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Vf,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=aa,this.stencilZFail=aa,this.stencilZPass=aa,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Ho;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==ji&&(n.blending=this.blending),this.side!==Ji&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==bt&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function r(s){const a=[];for(const o in s){const u=s[o];delete u.metadata,a.push(u)}return a}if(t){const s=r(e.textures),a=r(e.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const r=t.length;n=new Array(r);for(let s=0;s!==r;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}yt.prototype.isMaterial=!0;const Tl={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Zt={h:0,s:0,l:0},Zr={h:0,s:0,l:0};function Sa(i,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?i+(e-i)*6*t:t<1/2?e:t<2/3?i+(e-i)*6*(2/3-t):i}function Ea(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Ta(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}class Ee{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Hf(e,1),t=zt(t,0,1),n=zt(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,s=2*n-r;this.r=Sa(s,r,e+1/3),this.g=Sa(s,r,e),this.b=Sa(s,r,e-1/3)}return this}setStyle(e){function t(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,t(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,t(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(r[1])/360,u=parseInt(r[2],10)/100,h=parseInt(r[3],10)/100;return t(r[4]),this.setHSL(o,u,h)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=n[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Tl[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=Ea(e.r),this.g=Ea(e.g),this.b=Ea(e.b),this}copyLinearToSRGB(e){return this.r=Ta(e.r),this.g=Ta(e.g),this.b=Ta(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,n=this.g,r=this.b,s=Math.max(t,n,r),a=Math.min(t,n,r);let o,u;const h=(a+s)/2;if(a===s)o=0,u=0;else{const c=s-a;switch(u=h<=.5?c/(s+a):c/(2-s-a),s){case t:o=(n-r)/c+(n<r?6:0);break;case n:o=(r-t)/c+2;break;case r:o=(t-n)/c+4;break}o/=6}return e.h=o,e.s=u,e.l=h,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,n){return this.getHSL(Zt),Zt.h+=e,Zt.s+=t,Zt.l+=n,this.setHSL(Zt.h,Zt.s,Zt.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Zt),e.getHSL(Zr);const n=ca(Zt.h,Zr.h,t),r=ca(Zt.s,Zr.s,t),s=ca(Zt.l,Zr.l,t);return this.setHSL(n,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ee.NAMES=Tl;Ee.prototype.isColor=!0;Ee.prototype.r=1;Ee.prototype.g=1;Ee.prototype.b=1;class Aa extends yt{constructor(e){super();this.type="MeshBasicMaterial",this.color=new Ee(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}Aa.prototype.isMeshBasicMaterial=!0;const Xe=new P,Yr=new le;class lt{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=er,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let a=e[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),a=new Ee),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let a=e[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),a=new le),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let a=e[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),a=new P),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let a=e[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),a=new We),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Yr.fromBufferAttribute(this,t),Yr.applyMatrix3(e),this.setXY(t,Yr.x,Yr.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Xe.fromBufferAttribute(this,t),Xe.applyMatrix3(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.applyMatrix4(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.applyNormalMatrix(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.transformDirection(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==er&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}lt.prototype.isBufferAttribute=!0;class Al extends lt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Cl extends lt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class ed extends lt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}ed.prototype.isFloat16BufferAttribute=!0;class it extends lt{constructor(e,t,n){super(new Float32Array(e),t,n)}}let td=0;const Ht=new Re,Ca=new He,xi=new P,Ot=new Wt,rr=new Wt,ht=new P;class Ye extends qn{constructor(){super();Object.defineProperty(this,"id",{value:td++}),this.uuid=Qt(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(pl(e)>65535?Cl:Al)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new pt().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ht.makeRotationFromQuaternion(e),this.applyMatrix4(Ht),this}rotateX(e){return Ht.makeRotationX(e),this.applyMatrix4(Ht),this}rotateY(e){return Ht.makeRotationY(e),this.applyMatrix4(Ht),this}rotateZ(e){return Ht.makeRotationZ(e),this.applyMatrix4(Ht),this}translate(e,t,n){return Ht.makeTranslation(e,t,n),this.applyMatrix4(Ht),this}scale(e,t,n){return Ht.makeScale(e,t,n),this.applyMatrix4(Ht),this}lookAt(e){return Ca.lookAt(e),Ca.updateMatrix(),this.applyMatrix4(Ca.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(xi).negate(),this.translate(xi.x,xi.y,xi.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new it(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Wt);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new P(-1/0,-1/0,-1/0),new P(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,r=t.length;n<r;n++){const s=t[n];Ot.setFromBufferAttribute(s),this.morphTargetsRelative?(ht.addVectors(this.boundingBox.min,Ot.min),this.boundingBox.expandByPoint(ht),ht.addVectors(this.boundingBox.max,Ot.max),this.boundingBox.expandByPoint(ht)):(this.boundingBox.expandByPoint(Ot.min),this.boundingBox.expandByPoint(Ot.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new di);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new P,1/0);return}if(e){const n=this.boundingSphere.center;if(Ot.setFromBufferAttribute(e),t)for(let s=0,a=t.length;s<a;s++){const o=t[s];rr.setFromBufferAttribute(o),this.morphTargetsRelative?(ht.addVectors(Ot.min,rr.min),Ot.expandByPoint(ht),ht.addVectors(Ot.max,rr.max),Ot.expandByPoint(ht)):(Ot.expandByPoint(rr.min),Ot.expandByPoint(rr.max))}Ot.getCenter(n);let r=0;for(let s=0,a=e.count;s<a;s++)ht.fromBufferAttribute(e,s),r=Math.max(r,n.distanceToSquared(ht));if(t)for(let s=0,a=t.length;s<a;s++){const o=t[s],u=this.morphTargetsRelative;for(let h=0,c=o.count;h<c;h++)ht.fromBufferAttribute(o,h),u&&(xi.fromBufferAttribute(e,h),ht.add(xi)),r=Math.max(r,n.distanceToSquared(ht))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,r=t.position.array,s=t.normal.array,a=t.uv.array,o=r.length/3;t.tangent===void 0&&this.setAttribute("tangent",new lt(new Float32Array(4*o),4));const u=t.tangent.array,h=[],c=[];for(let D=0;D<o;D++)h[D]=new P,c[D]=new P;const l=new P,f=new P,d=new P,v=new le,m=new le,_=new le,p=new P,g=new P;function y(D,T,O){l.fromArray(r,D*3),f.fromArray(r,T*3),d.fromArray(r,O*3),v.fromArray(a,D*2),m.fromArray(a,T*2),_.fromArray(a,O*2),f.sub(l),d.sub(l),m.sub(v),_.sub(v);const B=1/(m.x*_.y-_.x*m.y);!isFinite(B)||(p.copy(f).multiplyScalar(_.y).addScaledVector(d,-m.y).multiplyScalar(B),g.copy(d).multiplyScalar(m.x).addScaledVector(f,-_.x).multiplyScalar(B),h[D].add(p),h[T].add(p),h[O].add(p),c[D].add(g),c[T].add(g),c[O].add(g))}let x=this.groups;x.length===0&&(x=[{start:0,count:n.length}]);for(let D=0,T=x.length;D<T;++D){const O=x[D],B=O.start,F=O.count;for(let z=B,N=B+F;z<N;z+=3)y(n[z+0],n[z+1],n[z+2])}const M=new P,S=new P,w=new P,C=new P;function I(D){w.fromArray(s,D*3),C.copy(w);const T=h[D];M.copy(T),M.sub(w.multiplyScalar(w.dot(T))).normalize(),S.crossVectors(C,T);const B=S.dot(c[D])<0?-1:1;u[D*4]=M.x,u[D*4+1]=M.y,u[D*4+2]=M.z,u[D*4+3]=B}for(let D=0,T=x.length;D<T;++D){const O=x[D],B=O.start,F=O.count;for(let z=B,N=B+F;z<N;z+=3)I(n[z+0]),I(n[z+1]),I(n[z+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new lt(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let f=0,d=n.count;f<d;f++)n.setXYZ(f,0,0,0);const r=new P,s=new P,a=new P,o=new P,u=new P,h=new P,c=new P,l=new P;if(e)for(let f=0,d=e.count;f<d;f+=3){const v=e.getX(f+0),m=e.getX(f+1),_=e.getX(f+2);r.fromBufferAttribute(t,v),s.fromBufferAttribute(t,m),a.fromBufferAttribute(t,_),c.subVectors(a,s),l.subVectors(r,s),c.cross(l),o.fromBufferAttribute(n,v),u.fromBufferAttribute(n,m),h.fromBufferAttribute(n,_),o.add(c),u.add(c),h.add(c),n.setXYZ(v,o.x,o.y,o.z),n.setXYZ(m,u.x,u.y,u.z),n.setXYZ(_,h.x,h.y,h.z)}else for(let f=0,d=t.count;f<d;f+=3)r.fromBufferAttribute(t,f+0),s.fromBufferAttribute(t,f+1),a.fromBufferAttribute(t,f+2),c.subVectors(a,s),l.subVectors(r,s),c.cross(l),n.setXYZ(f+0,c.x,c.y,c.z),n.setXYZ(f+1,c.x,c.y,c.z),n.setXYZ(f+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(e.attributes[r]===void 0)continue;const a=n[r].array,o=e.attributes[r],u=o.array,h=o.itemSize*t,c=Math.min(u.length,a.length-h);for(let l=0,f=h;l<c;l++,f++)a[f]=u[l]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)ht.fromBufferAttribute(e,t),ht.normalize(),e.setXYZ(t,ht.x,ht.y,ht.z)}toNonIndexed(){function e(o,u){const h=o.array,c=o.itemSize,l=o.normalized,f=new h.constructor(u.length*c);let d=0,v=0;for(let m=0,_=u.length;m<_;m++){o.isInterleavedBufferAttribute?d=u[m]*o.data.stride+o.offset:d=u[m]*c;for(let p=0;p<c;p++)f[v++]=h[d++]}return new lt(f,c,l)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Ye,n=this.index.array,r=this.attributes;for(const o in r){const u=r[o],h=e(u,n);t.setAttribute(o,h)}const s=this.morphAttributes;for(const o in s){const u=[],h=s[o];for(let c=0,l=h.length;c<l;c++){const f=h[c],d=e(f,n);u.push(d)}t.morphAttributes[o]=u}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,u=a.length;o<u;o++){const h=a[o];t.addGroup(h.start,h.count,h.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const h in u)u[h]!==void 0&&(e[h]=u[h]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const u in n){const h=n[u];e.data.attributes[u]=h.toJSON(e.data)}const r={};let s=!1;for(const u in this.morphAttributes){const h=this.morphAttributes[u],c=[];for(let l=0,f=h.length;l<f;l++){const d=h[l];c.push(d.toJSON(e.data))}c.length>0&&(r[u]=c,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const r=e.attributes;for(const h in r){const c=r[h];this.setAttribute(h,c.clone(t))}const s=e.morphAttributes;for(const h in s){const c=[],l=s[h];for(let f=0,d=l.length;f<d;f++)c.push(l[f].clone(t));this.morphAttributes[h]=c}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let h=0,c=a.length;h<c;h++){const l=a[h];this.addGroup(l.start,l.count,l.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const u=e.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Ye.prototype.isBufferGeometry=!0;const Ll=new Re,wi=new pi,La=new di,Sn=new P,En=new P,Tn=new P,Ra=new P,Pa=new P,Na=new P,Jr=new P,jr=new P,$r=new P,Qr=new le,Kr=new le,es=new le,Ia=new P,ts=new P;class Ct extends He{constructor(e=new Ye,t=new Aa){super();this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),La.copy(n.boundingSphere),La.applyMatrix4(s),e.ray.intersectsSphere(La)===!1)||(Ll.copy(s).invert(),wi.copy(e.ray).applyMatrix4(Ll),n.boundingBox!==null&&wi.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const o=n.index,u=n.attributes.position,h=n.morphAttributes.position,c=n.morphTargetsRelative,l=n.attributes.uv,f=n.attributes.uv2,d=n.groups,v=n.drawRange;if(o!==null)if(Array.isArray(r))for(let m=0,_=d.length;m<_;m++){const p=d[m],g=r[p.materialIndex],y=Math.max(p.start,v.start),x=Math.min(o.count,Math.min(p.start+p.count,v.start+v.count));for(let M=y,S=x;M<S;M+=3){const w=o.getX(M),C=o.getX(M+1),I=o.getX(M+2);a=ns(this,g,e,wi,u,h,c,l,f,w,C,I),a&&(a.faceIndex=Math.floor(M/3),a.face.materialIndex=p.materialIndex,t.push(a))}}else{const m=Math.max(0,v.start),_=Math.min(o.count,v.start+v.count);for(let p=m,g=_;p<g;p+=3){const y=o.getX(p),x=o.getX(p+1),M=o.getX(p+2);a=ns(this,r,e,wi,u,h,c,l,f,y,x,M),a&&(a.faceIndex=Math.floor(p/3),t.push(a))}}else if(u!==void 0)if(Array.isArray(r))for(let m=0,_=d.length;m<_;m++){const p=d[m],g=r[p.materialIndex],y=Math.max(p.start,v.start),x=Math.min(u.count,Math.min(p.start+p.count,v.start+v.count));for(let M=y,S=x;M<S;M+=3){const w=M,C=M+1,I=M+2;a=ns(this,g,e,wi,u,h,c,l,f,w,C,I),a&&(a.faceIndex=Math.floor(M/3),a.face.materialIndex=p.materialIndex,t.push(a))}}else{const m=Math.max(0,v.start),_=Math.min(u.count,v.start+v.count);for(let p=m,g=_;p<g;p+=3){const y=p,x=p+1,M=p+2;a=ns(this,r,e,wi,u,h,c,l,f,y,x,M),a&&(a.faceIndex=Math.floor(p/3),t.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Ct.prototype.isMesh=!0;function nd(i,e,t,n,r,s,a,o){let u;if(e.side===ot?u=n.intersectTriangle(a,s,r,!0,o):u=n.intersectTriangle(r,s,a,e.side!==ei,o),u===null)return null;ts.copy(o),ts.applyMatrix4(i.matrixWorld);const h=t.ray.origin.distanceTo(ts);return h<t.near||h>t.far?null:{distance:h,point:ts.clone(),object:i}}function ns(i,e,t,n,r,s,a,o,u,h,c,l){Sn.fromBufferAttribute(r,h),En.fromBufferAttribute(r,c),Tn.fromBufferAttribute(r,l);const f=i.morphTargetInfluences;if(s&&f){Jr.set(0,0,0),jr.set(0,0,0),$r.set(0,0,0);for(let v=0,m=s.length;v<m;v++){const _=f[v],p=s[v];_!==0&&(Ra.fromBufferAttribute(p,h),Pa.fromBufferAttribute(p,c),Na.fromBufferAttribute(p,l),a?(Jr.addScaledVector(Ra,_),jr.addScaledVector(Pa,_),$r.addScaledVector(Na,_)):(Jr.addScaledVector(Ra.sub(Sn),_),jr.addScaledVector(Pa.sub(En),_),$r.addScaledVector(Na.sub(Tn),_)))}Sn.add(Jr),En.add(jr),Tn.add($r)}i.isSkinnedMesh&&(i.boneTransform(h,Sn),i.boneTransform(c,En),i.boneTransform(l,Tn));const d=nd(i,e,t,n,Sn,En,Tn,Ia);if(d){o&&(Qr.fromBufferAttribute(o,h),Kr.fromBufferAttribute(o,c),es.fromBufferAttribute(o,l),d.uv=st.getUV(Ia,Sn,En,Tn,Qr,Kr,es,new le)),u&&(Qr.fromBufferAttribute(u,h),Kr.fromBufferAttribute(u,c),es.fromBufferAttribute(u,l),d.uv2=st.getUV(Ia,Sn,En,Tn,Qr,Kr,es,new le));const v={a:h,b:c,c:l,normal:new P,materialIndex:0};st.getNormal(Sn,En,Tn,v.normal),d.face=v}return d}class sr extends Ye{constructor(e=1,t=1,n=1,r=1,s=1,a=1){super();this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:s,depthSegments:a};const o=this;r=Math.floor(r),s=Math.floor(s),a=Math.floor(a);const u=[],h=[],c=[],l=[];let f=0,d=0;v("z","y","x",-1,-1,n,t,e,a,s,0),v("z","y","x",1,-1,n,t,-e,a,s,1),v("x","z","y",1,1,e,n,t,r,a,2),v("x","z","y",1,-1,e,n,-t,r,a,3),v("x","y","z",1,-1,e,t,n,r,s,4),v("x","y","z",-1,-1,e,t,-n,r,s,5),this.setIndex(u),this.setAttribute("position",new it(h,3)),this.setAttribute("normal",new it(c,3)),this.setAttribute("uv",new it(l,2));function v(m,_,p,g,y,x,M,S,w,C,I){const D=x/w,T=M/C,O=x/2,B=M/2,F=S/2,z=w+1,N=C+1;let U=0,Y=0;const ee=new P;for(let k=0;k<N;k++){const q=k*T-B;for(let oe=0;oe<z;oe++){const se=oe*D-O;ee[m]=se*g,ee[_]=q*y,ee[p]=F,h.push(ee.x,ee.y,ee.z),ee[m]=0,ee[_]=0,ee[p]=S>0?1:-1,c.push(ee.x,ee.y,ee.z),l.push(oe/w),l.push(1-k/C),U+=1}}for(let k=0;k<C;k++)for(let q=0;q<w;q++){const oe=f+q+z*k,se=f+q+z*(k+1),de=f+(q+1)+z*(k+1),Se=f+(q+1)+z*k;u.push(oe,se,Se),u.push(se,de,Se),Y+=6}o.addGroup(d,Y,I),d+=Y,f+=U}}static fromJSON(e){return new sr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Mi(i){const e={};for(const t in i){e[t]={};for(const n in i[t]){const r=i[t][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][n]=r.clone():Array.isArray(r)?e[t][n]=r.slice():e[t][n]=r}}return e}function xt(i){const e={};for(let t=0;t<i.length;t++){const n=Mi(i[t]);for(const r in n)e[r]=n[r]}return e}const id={clone:Mi,merge:xt};var rd=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,sd=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Yn extends yt{constructor(e){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=rd,this.fragmentShader=sd,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Mi(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const a=this.uniforms[r].value;a&&a.isTexture?t.uniforms[r]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[r]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[r]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[r]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[r]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[r]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[r]={type:"m4",value:a.toArray()}:t.uniforms[r]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)this.extensions[r]===!0&&(n[r]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}Yn.prototype.isShaderMaterial=!0;class Da extends He{constructor(){super();this.type="Camera",this.matrixWorldInverse=new Re,this.projectionMatrix=new Re,this.projectionMatrixInverse=new Re}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Da.prototype.isCamera=!0;class Lt extends Da{constructor(e=50,t=1,n=.1,r=2e3){super();this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=la*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(oa*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return la*2*Math.atan(Math.tan(oa*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,s,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(oa*.5*this.fov)/this.zoom,n=2*t,r=this.aspect*n,s=-.5*r;const a=this.view;if(this.view!==null&&this.view.enabled){const u=a.fullWidth,h=a.fullHeight;s+=a.offsetX*r/u,t-=a.offsetY*n/h,r*=a.width/u,n*=a.height/h}const o=this.filmOffset;o!==0&&(s+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Lt.prototype.isPerspectiveCamera=!0;const bi=90,Si=1;class Fa extends He{constructor(e,t,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new Lt(bi,Si,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new P(1,0,0)),this.add(r);const s=new Lt(bi,Si,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new P(-1,0,0)),this.add(s);const a=new Lt(bi,Si,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new P(0,1,0)),this.add(a);const o=new Lt(bi,Si,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new P(0,-1,0)),this.add(o);const u=new Lt(bi,Si,e,t);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new P(0,0,1)),this.add(u);const h=new Lt(bi,Si,e,t);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new P(0,0,-1)),this.add(h)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,a,o,u,h]=this.children,c=e.xr.enabled,l=e.getRenderTarget();e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,s),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,u),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,h),e.setRenderTarget(l),e.xr.enabled=c}}class is extends mt{constructor(e,t,n,r,s,a,o,u,h,c){e=e!==void 0?e:[],t=t!==void 0?t:$i;super(e,t,n,r,s,a,o,u,h,c);this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}is.prototype.isCubeTexture=!0;class Rl extends Vt{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n);super(e,e,t);t=t||{},this.texture=new is(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Ut,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=bt,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new sr(5,5,5),s=new Yn({name:"CubemapFromEquirect",uniforms:Mi(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ot,blending:vn});s.uniforms.tEquirect.value=t;const a=new Ct(r,s),o=t.minFilter;return t.minFilter===Ir&&(t.minFilter=Ut),new Fa(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,r){const s=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,r);e.setRenderTarget(s)}}Rl.prototype.isWebGLCubeRenderTarget=!0;const za=new P,ad=new P,od=new pt;class hn{constructor(e=new P(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=za.subVectors(n,t).cross(ad.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(za),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(n).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||od.getNormalMatrix(e),r=this.coplanarPoint(za).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}hn.prototype.isPlane=!0;const Ei=new di,rs=new P;class ss{constructor(e=new hn,t=new hn,n=new hn,r=new hn,s=new hn,a=new hn){this.planes=[e,t,n,r,s,a]}set(e,t,n,r,s,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(r),o[4].copy(s),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],s=n[1],a=n[2],o=n[3],u=n[4],h=n[5],c=n[6],l=n[7],f=n[8],d=n[9],v=n[10],m=n[11],_=n[12],p=n[13],g=n[14],y=n[15];return t[0].setComponents(o-r,l-u,m-f,y-_).normalize(),t[1].setComponents(o+r,l+u,m+f,y+_).normalize(),t[2].setComponents(o+s,l+h,m+d,y+p).normalize(),t[3].setComponents(o-s,l-h,m-d,y-p).normalize(),t[4].setComponents(o-a,l-c,m-v,y-g).normalize(),t[5].setComponents(o+a,l+c,m+v,y+g).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Ei.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ei)}intersectsSprite(e){return Ei.center.set(0,0,0),Ei.radius=.7071067811865476,Ei.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ei)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(rs.x=r.normal.x>0?e.max.x:e.min.x,rs.y=r.normal.y>0?e.max.y:e.min.y,rs.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(rs)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Pl(){let i=null,e=!1,t=null,n=null;function r(s,a){t(s,a),n=i.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(n=i.requestAnimationFrame(r),e=!0)},stop:function(){i.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){i=s}}}function ld(i,e){const t=e.isWebGL2,n=new WeakMap;function r(h,c){const l=h.array,f=h.usage,d=i.createBuffer();i.bindBuffer(c,d),i.bufferData(c,l,f),h.onUploadCallback();let v=5126;return l instanceof Float32Array?v=5126:l instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):l instanceof Uint16Array?h.isFloat16BufferAttribute?t?v=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):v=5123:l instanceof Int16Array?v=5122:l instanceof Uint32Array?v=5125:l instanceof Int32Array?v=5124:l instanceof Int8Array?v=5120:(l instanceof Uint8Array||l instanceof Uint8ClampedArray)&&(v=5121),{buffer:d,type:v,bytesPerElement:l.BYTES_PER_ELEMENT,version:h.version}}function s(h,c,l){const f=c.array,d=c.updateRange;i.bindBuffer(l,h),d.count===-1?i.bufferSubData(l,0,f):(t?i.bufferSubData(l,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):i.bufferSubData(l,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function a(h){return h.isInterleavedBufferAttribute&&(h=h.data),n.get(h)}function o(h){h.isInterleavedBufferAttribute&&(h=h.data);const c=n.get(h);c&&(i.deleteBuffer(c.buffer),n.delete(h))}function u(h,c){if(h.isGLBufferAttribute){const f=n.get(h);(!f||f.version<h.version)&&n.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const l=n.get(h);l===void 0?n.set(h,r(h,c)):l.version<h.version&&(s(l.buffer,h,c),l.version=h.version)}return{get:a,remove:o,update:u}}class Ba extends Ye{constructor(e=1,t=1,n=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const s=e/2,a=t/2,o=Math.floor(n),u=Math.floor(r),h=o+1,c=u+1,l=e/o,f=t/u,d=[],v=[],m=[],_=[];for(let p=0;p<c;p++){const g=p*f-a;for(let y=0;y<h;y++){const x=y*l-s;v.push(x,-g,0),m.push(0,0,1),_.push(y/o),_.push(1-p/u)}}for(let p=0;p<u;p++)for(let g=0;g<o;g++){const y=g+h*p,x=g+h*(p+1),M=g+1+h*(p+1),S=g+1+h*p;d.push(y,x,S),d.push(x,M,S)}this.setIndex(d),this.setAttribute("position",new it(v,3)),this.setAttribute("normal",new it(m,3)),this.setAttribute("uv",new it(_,2))}static fromJSON(e){return new Ba(e.width,e.height,e.widthSegments,e.heightSegments)}}var cd=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,ud=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hd=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,fd=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,dd=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,pd=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,md="vec3 transformed = vec3( position );",gd=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,vd=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,_d=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,yd=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,xd=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,wd=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Md=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,bd=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Sd=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Ed=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Td=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Ad=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Cd=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Ld=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Rd=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Pd=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Nd=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Id=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Dd="gl_FragColor = linearToOutputTexel( gl_FragColor );",Fd=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}`,zd=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Bd=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Od=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Ud=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Vd=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Hd=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Gd=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,kd=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Wd=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,qd=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Xd=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Zd=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Yd=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Jd=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,jd=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,$d=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Qd=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Kd=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,ep=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,tp=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,np=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ip=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,rp=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,sp=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,ap=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,op=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,lp=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,cp=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,up=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,hp=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,fp=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,dp=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,pp=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,mp=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,gp=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,vp=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,_p=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,yp=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,xp=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,wp=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Mp=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,bp=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Sp=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Ep=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Tp=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Ap=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Cp=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Lp=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Rp=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Pp=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Np=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Ip=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Dp=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Fp=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,zp=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Bp=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Op=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Up=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Vp=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Hp=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Gp=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,kp=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Wp=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,qp=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Xp=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Zp=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Yp=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,Jp=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,jp=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,$p=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Qp=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Kp=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,em=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,tm=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,nm=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const im=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,rm=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sm=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,am=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,om=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,lm=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,cm=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,um=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,hm=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fm=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,dm=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,pm=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,mm=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,gm=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vm=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,_m=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ym=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,xm=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wm=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Mm=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,bm=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Sm=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Em=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Tm=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Am=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Cm=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Lm=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Rm=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Pm=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Nm=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Im=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Dm=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Be={alphamap_fragment:cd,alphamap_pars_fragment:ud,alphatest_fragment:hd,alphatest_pars_fragment:fd,aomap_fragment:dd,aomap_pars_fragment:pd,begin_vertex:md,beginnormal_vertex:gd,bsdfs:vd,bumpmap_pars_fragment:_d,clipping_planes_fragment:yd,clipping_planes_pars_fragment:xd,clipping_planes_pars_vertex:wd,clipping_planes_vertex:Md,color_fragment:bd,color_pars_fragment:Sd,color_pars_vertex:Ed,color_vertex:Td,common:Ad,cube_uv_reflection_fragment:Cd,defaultnormal_vertex:Ld,displacementmap_pars_vertex:Rd,displacementmap_vertex:Pd,emissivemap_fragment:Nd,emissivemap_pars_fragment:Id,encodings_fragment:Dd,encodings_pars_fragment:Fd,envmap_fragment:zd,envmap_common_pars_fragment:Bd,envmap_pars_fragment:Od,envmap_pars_vertex:Ud,envmap_physical_pars_fragment:jd,envmap_vertex:Vd,fog_vertex:Hd,fog_pars_vertex:Gd,fog_fragment:kd,fog_pars_fragment:Wd,gradientmap_pars_fragment:qd,lightmap_fragment:Xd,lightmap_pars_fragment:Zd,lights_lambert_vertex:Yd,lights_pars_begin:Jd,lights_toon_fragment:$d,lights_toon_pars_fragment:Qd,lights_phong_fragment:Kd,lights_phong_pars_fragment:ep,lights_physical_fragment:tp,lights_physical_pars_fragment:np,lights_fragment_begin:ip,lights_fragment_maps:rp,lights_fragment_end:sp,logdepthbuf_fragment:ap,logdepthbuf_pars_fragment:op,logdepthbuf_pars_vertex:lp,logdepthbuf_vertex:cp,map_fragment:up,map_pars_fragment:hp,map_particle_fragment:fp,map_particle_pars_fragment:dp,metalnessmap_fragment:pp,metalnessmap_pars_fragment:mp,morphnormal_vertex:gp,morphtarget_pars_vertex:vp,morphtarget_vertex:_p,normal_fragment_begin:yp,normal_fragment_maps:xp,normal_pars_fragment:wp,normal_pars_vertex:Mp,normal_vertex:bp,normalmap_pars_fragment:Sp,clearcoat_normal_fragment_begin:Ep,clearcoat_normal_fragment_maps:Tp,clearcoat_pars_fragment:Ap,output_fragment:Cp,packing:Lp,premultiplied_alpha_fragment:Rp,project_vertex:Pp,dithering_fragment:Np,dithering_pars_fragment:Ip,roughnessmap_fragment:Dp,roughnessmap_pars_fragment:Fp,shadowmap_pars_fragment:zp,shadowmap_pars_vertex:Bp,shadowmap_vertex:Op,shadowmask_pars_fragment:Up,skinbase_vertex:Vp,skinning_pars_vertex:Hp,skinning_vertex:Gp,skinnormal_vertex:kp,specularmap_fragment:Wp,specularmap_pars_fragment:qp,tonemapping_fragment:Xp,tonemapping_pars_fragment:Zp,transmission_fragment:Yp,transmission_pars_fragment:Jp,uv_pars_fragment:jp,uv_pars_vertex:$p,uv_vertex:Qp,uv2_pars_fragment:Kp,uv2_pars_vertex:em,uv2_vertex:tm,worldpos_vertex:nm,background_vert:im,background_frag:rm,cube_vert:sm,cube_frag:am,depth_vert:om,depth_frag:lm,distanceRGBA_vert:cm,distanceRGBA_frag:um,equirect_vert:hm,equirect_frag:fm,linedashed_vert:dm,linedashed_frag:pm,meshbasic_vert:mm,meshbasic_frag:gm,meshlambert_vert:vm,meshlambert_frag:_m,meshmatcap_vert:ym,meshmatcap_frag:xm,meshnormal_vert:wm,meshnormal_frag:Mm,meshphong_vert:bm,meshphong_frag:Sm,meshphysical_vert:Em,meshphysical_frag:Tm,meshtoon_vert:Am,meshtoon_frag:Cm,points_vert:Lm,points_frag:Rm,shadow_vert:Pm,shadow_frag:Nm,sprite_vert:Im,sprite_frag:Dm},ge={common:{diffuse:{value:new Ee(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new pt},uv2Transform:{value:new pt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new le(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ee(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ee(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new pt}},sprite:{diffuse:{value:new Ee(16777215)},opacity:{value:1},center:{value:new le(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new pt}}},Kt={basic:{uniforms:xt([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.fog]),vertexShader:Be.meshbasic_vert,fragmentShader:Be.meshbasic_frag},lambert:{uniforms:xt([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.fog,ge.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Be.meshlambert_vert,fragmentShader:Be.meshlambert_frag},phong:{uniforms:xt([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)},specular:{value:new Ee(1118481)},shininess:{value:30}}]),vertexShader:Be.meshphong_vert,fragmentShader:Be.meshphong_frag},standard:{uniforms:xt([ge.common,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.roughnessmap,ge.metalnessmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Be.meshphysical_vert,fragmentShader:Be.meshphysical_frag},toon:{uniforms:xt([ge.common,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.gradientmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Be.meshtoon_vert,fragmentShader:Be.meshtoon_frag},matcap:{uniforms:xt([ge.common,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.fog,{matcap:{value:null}}]),vertexShader:Be.meshmatcap_vert,fragmentShader:Be.meshmatcap_frag},points:{uniforms:xt([ge.points,ge.fog]),vertexShader:Be.points_vert,fragmentShader:Be.points_frag},dashed:{uniforms:xt([ge.common,ge.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Be.linedashed_vert,fragmentShader:Be.linedashed_frag},depth:{uniforms:xt([ge.common,ge.displacementmap]),vertexShader:Be.depth_vert,fragmentShader:Be.depth_frag},normal:{uniforms:xt([ge.common,ge.bumpmap,ge.normalmap,ge.displacementmap,{opacity:{value:1}}]),vertexShader:Be.meshnormal_vert,fragmentShader:Be.meshnormal_frag},sprite:{uniforms:xt([ge.sprite,ge.fog]),vertexShader:Be.sprite_vert,fragmentShader:Be.sprite_frag},background:{uniforms:{uvTransform:{value:new pt},t2D:{value:null}},vertexShader:Be.background_vert,fragmentShader:Be.background_frag},cube:{uniforms:xt([ge.envmap,{opacity:{value:1}}]),vertexShader:Be.cube_vert,fragmentShader:Be.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Be.equirect_vert,fragmentShader:Be.equirect_frag},distanceRGBA:{uniforms:xt([ge.common,ge.displacementmap,{referencePosition:{value:new P},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Be.distanceRGBA_vert,fragmentShader:Be.distanceRGBA_frag},shadow:{uniforms:xt([ge.lights,ge.fog,{color:{value:new Ee(0)},opacity:{value:1}}]),vertexShader:Be.shadow_vert,fragmentShader:Be.shadow_frag}};Kt.physical={uniforms:xt([Kt.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new le(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Ee(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new le},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Ee(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Ee(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Be.meshphysical_vert,fragmentShader:Be.meshphysical_frag};function Fm(i,e,t,n,r){const s=new Ee(0);let a=0,o,u,h=null,c=0,l=null;function f(v,m){let _=!1,p=m.isScene===!0?m.background:null;p&&p.isTexture&&(p=e.get(p));const g=i.xr,y=g.getSession&&g.getSession();y&&y.environmentBlendMode==="additive"&&(p=null),p===null?d(s,a):p&&p.isColor&&(d(p,1),_=!0),(i.autoClear||_)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),p&&(p.isCubeTexture||p.mapping===Nr)?(u===void 0&&(u=new Ct(new sr(1,1,1),new Yn({name:"BackgroundCubeMaterial",uniforms:Mi(Kt.cube.uniforms),vertexShader:Kt.cube.vertexShader,fragmentShader:Kt.cube.fragmentShader,side:ot,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(x,M,S){this.matrixWorld.copyPosition(S.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(u)),u.material.uniforms.envMap.value=p,u.material.uniforms.flipEnvMap.value=p.isCubeTexture&&p.isRenderTargetTexture===!1?-1:1,(h!==p||c!==p.version||l!==i.toneMapping)&&(u.material.needsUpdate=!0,h=p,c=p.version,l=i.toneMapping),v.unshift(u,u.geometry,u.material,0,0,null)):p&&p.isTexture&&(o===void 0&&(o=new Ct(new Ba(2,2),new Yn({name:"BackgroundMaterial",uniforms:Mi(Kt.background.uniforms),vertexShader:Kt.background.vertexShader,fragmentShader:Kt.background.fragmentShader,side:Ji,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=p,p.matrixAutoUpdate===!0&&p.updateMatrix(),o.material.uniforms.uvTransform.value.copy(p.matrix),(h!==p||c!==p.version||l!==i.toneMapping)&&(o.material.needsUpdate=!0,h=p,c=p.version,l=i.toneMapping),v.unshift(o,o.geometry,o.material,0,0,null))}function d(v,m){t.buffers.color.setClear(v.r,v.g,v.b,m,r)}return{getClearColor:function(){return s},setClearColor:function(v,m=1){s.set(v),a=m,d(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(v){a=v,d(s,a)},render:f}}function zm(i,e,t,n){const r=i.getParameter(34921),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},u=m(null);let h=u;function c(B,F,z,N,U){let Y=!1;if(a){const ee=v(N,z,F);h!==ee&&(h=ee,f(h.object)),Y=_(N,U),Y&&p(N,U)}else{const ee=F.wireframe===!0;(h.geometry!==N.id||h.program!==z.id||h.wireframe!==ee)&&(h.geometry=N.id,h.program=z.id,h.wireframe=ee,Y=!0)}B.isInstancedMesh===!0&&(Y=!0),U!==null&&t.update(U,34963),Y&&(w(B,F,z,N),U!==null&&i.bindBuffer(34963,t.get(U).buffer))}function l(){return n.isWebGL2?i.createVertexArray():s.createVertexArrayOES()}function f(B){return n.isWebGL2?i.bindVertexArray(B):s.bindVertexArrayOES(B)}function d(B){return n.isWebGL2?i.deleteVertexArray(B):s.deleteVertexArrayOES(B)}function v(B,F,z){const N=z.wireframe===!0;let U=o[B.id];U===void 0&&(U={},o[B.id]=U);let Y=U[F.id];Y===void 0&&(Y={},U[F.id]=Y);let ee=Y[N];return ee===void 0&&(ee=m(l()),Y[N]=ee),ee}function m(B){const F=[],z=[],N=[];for(let U=0;U<r;U++)F[U]=0,z[U]=0,N[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:F,enabledAttributes:z,attributeDivisors:N,object:B,attributes:{},index:null}}function _(B,F){const z=h.attributes,N=B.attributes;let U=0;for(const Y in N){const ee=z[Y],k=N[Y];if(ee===void 0||ee.attribute!==k||ee.data!==k.data)return!0;U++}return h.attributesNum!==U||h.index!==F}function p(B,F){const z={},N=B.attributes;let U=0;for(const Y in N){const ee=N[Y],k={};k.attribute=ee,ee.data&&(k.data=ee.data),z[Y]=k,U++}h.attributes=z,h.attributesNum=U,h.index=F}function g(){const B=h.newAttributes;for(let F=0,z=B.length;F<z;F++)B[F]=0}function y(B){x(B,0)}function x(B,F){const z=h.newAttributes,N=h.enabledAttributes,U=h.attributeDivisors;z[B]=1,N[B]===0&&(i.enableVertexAttribArray(B),N[B]=1),U[B]!==F&&((n.isWebGL2?i:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](B,F),U[B]=F)}function M(){const B=h.newAttributes,F=h.enabledAttributes;for(let z=0,N=F.length;z<N;z++)F[z]!==B[z]&&(i.disableVertexAttribArray(z),F[z]=0)}function S(B,F,z,N,U,Y){n.isWebGL2===!0&&(z===5124||z===5125)?i.vertexAttribIPointer(B,F,z,U,Y):i.vertexAttribPointer(B,F,z,N,U,Y)}function w(B,F,z,N){if(n.isWebGL2===!1&&(B.isInstancedMesh||N.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;g();const U=N.attributes,Y=z.getAttributes(),ee=F.defaultAttributeValues;for(const k in Y){const q=Y[k];if(q.location>=0){let oe=U[k];if(oe===void 0&&(k==="instanceMatrix"&&B.instanceMatrix&&(oe=B.instanceMatrix),k==="instanceColor"&&B.instanceColor&&(oe=B.instanceColor)),oe!==void 0){const se=oe.normalized,de=oe.itemSize,Se=t.get(oe);if(Se===void 0)continue;const Q=Se.buffer,ve=Se.type,xe=Se.bytesPerElement;if(oe.isInterleavedBufferAttribute){const fe=oe.data,pe=fe.stride,Pe=oe.offset;if(fe&&fe.isInstancedInterleavedBuffer){for(let Z=0;Z<q.locationSize;Z++)x(q.location+Z,fe.meshPerAttribute);B.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=fe.meshPerAttribute*fe.count)}else for(let Z=0;Z<q.locationSize;Z++)y(q.location+Z);i.bindBuffer(34962,Q);for(let Z=0;Z<q.locationSize;Z++)S(q.location+Z,de/q.locationSize,ve,se,pe*xe,(Pe+de/q.locationSize*Z)*xe)}else{if(oe.isInstancedBufferAttribute){for(let fe=0;fe<q.locationSize;fe++)x(q.location+fe,oe.meshPerAttribute);B.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=oe.meshPerAttribute*oe.count)}else for(let fe=0;fe<q.locationSize;fe++)y(q.location+fe);i.bindBuffer(34962,Q);for(let fe=0;fe<q.locationSize;fe++)S(q.location+fe,de/q.locationSize,ve,se,de*xe,de/q.locationSize*fe*xe)}}else if(ee!==void 0){const se=ee[k];if(se!==void 0)switch(se.length){case 2:i.vertexAttrib2fv(q.location,se);break;case 3:i.vertexAttrib3fv(q.location,se);break;case 4:i.vertexAttrib4fv(q.location,se);break;default:i.vertexAttrib1fv(q.location,se)}}}}M()}function C(){T();for(const B in o){const F=o[B];for(const z in F){const N=F[z];for(const U in N)d(N[U].object),delete N[U];delete F[z]}delete o[B]}}function I(B){if(o[B.id]===void 0)return;const F=o[B.id];for(const z in F){const N=F[z];for(const U in N)d(N[U].object),delete N[U];delete F[z]}delete o[B.id]}function D(B){for(const F in o){const z=o[F];if(z[B.id]===void 0)continue;const N=z[B.id];for(const U in N)d(N[U].object),delete N[U];delete z[B.id]}}function T(){O(),h!==u&&(h=u,f(h.object))}function O(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:c,reset:T,resetDefaultState:O,dispose:C,releaseStatesOfGeometry:I,releaseStatesOfProgram:D,initAttributes:g,enableAttribute:y,disableUnusedAttributes:M}}function Bm(i,e,t,n){const r=n.isWebGL2;let s;function a(h){s=h}function o(h,c){i.drawArrays(s,h,c),t.update(c,s,1)}function u(h,c,l){if(l===0)return;let f,d;if(r)f=i,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](s,h,c,l),t.update(c,s,l)}this.setMode=a,this.render=o,this.renderInstances=u}function Om(i,e,t){let n;function r(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const w=e.get("EXT_texture_filter_anisotropic");n=i.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(w){if(w==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";w="mediump"}return w==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&i instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const u=s(o);u!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",u,"instead."),o=u);const h=a||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,l=i.getParameter(34930),f=i.getParameter(35660),d=i.getParameter(3379),v=i.getParameter(34076),m=i.getParameter(34921),_=i.getParameter(36347),p=i.getParameter(36348),g=i.getParameter(36349),y=f>0,x=a||e.has("OES_texture_float"),M=y&&x,S=a?i.getParameter(36183):0;return{isWebGL2:a,drawBuffers:h,getMaxAnisotropy:r,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:c,maxTextures:l,maxVertexTextures:f,maxTextureSize:d,maxCubemapSize:v,maxAttributes:m,maxVertexUniforms:_,maxVaryings:p,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:x,floatVertexTextures:M,maxSamples:S}}function Um(i){const e=this;let t=null,n=0,r=!1,s=!1;const a=new hn,o=new pt,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(l,f,d){const v=l.length!==0||f||n!==0||r;return r=f,t=c(l,d,0),n=l.length,v},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1,h()},this.setState=function(l,f,d){const v=l.clippingPlanes,m=l.clipIntersection,_=l.clipShadows,p=i.get(l);if(!r||v===null||v.length===0||s&&!_)s?c(null):h();else{const g=s?0:n,y=g*4;let x=p.clippingState||null;u.value=x,x=c(v,f,y,d);for(let M=0;M!==y;++M)x[M]=t[M];p.clippingState=x,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=g}};function h(){u.value!==t&&(u.value=t,u.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function c(l,f,d,v){const m=l!==null?l.length:0;let _=null;if(m!==0){if(_=u.value,v!==!0||_===null){const p=d+m*4,g=f.matrixWorldInverse;o.getNormalMatrix(g),(_===null||_.length<p)&&(_=new Float32Array(p));for(let y=0,x=d;y!==m;++y,x+=4)a.copy(l[y]).applyMatrix4(g,o),a.normal.toArray(_,x),_[x+3]=a.constant}u.value=_,u.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,_}}function Vm(i){let e=new WeakMap;function t(a,o){return o===$s?a.mapping=$i:o===Qs&&(a.mapping=Qi),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===$s||o===Qs)if(e.has(a)){const u=e.get(a).texture;return t(u,a.mapping)}else{const u=a.image;if(u&&u.height>0){const h=i.getRenderTarget(),c=new Rl(u.height/2);return c.fromEquirectangularTexture(i,a),e.set(a,c),i.setRenderTarget(h),a.addEventListener("dispose",r),t(c.texture,a.mapping)}else return null}}return a}function r(a){const o=a.target;o.removeEventListener("dispose",r);const u=e.get(o);u!==void 0&&(e.delete(o),u.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class Oa extends Da{constructor(e=-1,t=1,n=1,r=-1,s=.1,a=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-e,a=n+e,o=r+t,u=r-t;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=h*this.view.offsetX,a=s+h*this.view.width,o-=c*this.view.offsetY,u=o-c*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,u,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Oa.prototype.isOrthographicCamera=!0;class as extends Yn{constructor(e){super(e);this.type="RawShaderMaterial"}}as.prototype.isRawShaderMaterial=!0;const Ti=4,An=8,en=Math.pow(2,An),Nl=[.125,.215,.35,.446,.526,.582],Il=An-Ti+1+Nl.length,Ai=20,Jn={[Tt]:0,[Or]:1,[sa]:2,[cl]:3,[ul]:4,[hl]:5,[ra]:6},Ua=new Oa,{_lodPlanes:ar,_sizeLods:Dl,_sigmas:os}=km(),Fl=new Ee;let Va=null;const jn=(1+Math.sqrt(5))/2,Ci=1/jn,zl=[new P(1,1,1),new P(-1,1,1),new P(1,1,-1),new P(-1,1,-1),new P(0,jn,Ci),new P(0,jn,-Ci),new P(Ci,0,jn),new P(-Ci,0,jn),new P(jn,Ci,0),new P(-jn,Ci,0)];class Hm{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=Wm(Ai),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){Va=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(e,n,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Ul(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Ol(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<ar.length;e++)ar[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Va),e.scissorTest=!1,ls(e,0,0,e.width,e.height)}_fromTexture(e){Va=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:ut,minFilter:ut,generateMipmaps:!1,type:_n,format:Jh,encoding:Gm(e)?e.encoding:sa,depthBuffer:!1},n=Bl(t);return n.depthBuffer=!e,this._pingPongRenderTarget=Bl(t),n}_compileMaterial(e){const t=new Ct(ar[0],e);this._renderer.compile(t,Ua)}_sceneToCubeUV(e,t,n,r){const s=90,a=1,o=new Lt(s,a,t,n),u=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],c=this._renderer,l=c.autoClear,f=c.outputEncoding,d=c.toneMapping;c.getClearColor(Fl),c.toneMapping=Gn,c.outputEncoding=Tt,c.autoClear=!1;const v=new Aa({name:"PMREM.Background",side:ot,depthWrite:!1,depthTest:!1}),m=new Ct(new sr,v);let _=!1;const p=e.background;p?p.isColor&&(v.color.copy(p),e.background=null,_=!0):(v.color.copy(Fl),_=!0);for(let g=0;g<6;g++){const y=g%3;y==0?(o.up.set(0,u[g],0),o.lookAt(h[g],0,0)):y==1?(o.up.set(0,0,u[g]),o.lookAt(0,h[g],0)):(o.up.set(0,u[g],0),o.lookAt(0,0,h[g])),ls(r,y*en,g>2?en:0,en,en),c.setRenderTarget(r),_&&c.render(m,o),c.render(e,o)}m.geometry.dispose(),m.material.dispose(),c.toneMapping=d,c.outputEncoding=f,c.autoClear=l,e.background=p}_setEncoding(e,t){e.value=Jn[t.encoding]}_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===$i||e.mapping===Qi;r?this._cubemapShader==null&&(this._cubemapShader=Ul()):this._equirectShader==null&&(this._equirectShader=Ol());const s=r?this._cubemapShader:this._equirectShader,a=new Ct(ar[0],s),o=s.uniforms;o.envMap.value=e,r||o.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(o.inputEncoding,e),this._setEncoding(o.outputEncoding,t.texture),ls(t,0,0,3*en,2*en),n.setRenderTarget(t),n.render(a,Ua)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let r=1;r<Il;r++){const s=Math.sqrt(os[r]*os[r]-os[r-1]*os[r-1]),a=zl[(r-1)%zl.length];this._blur(e,r-1,r,s,a)}t.autoClear=n}_blur(e,t,n,r,s){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",s),this._halfBlur(a,e,n,n,r,"longitudinal",s)}_halfBlur(e,t,n,r,s,a,o){const u=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,l=new Ct(ar[r],h),f=h.uniforms,d=Dl[n]-1,v=isFinite(s)?Math.PI/(2*d):2*Math.PI/(2*Ai-1),m=s/v,_=isFinite(s)?1+Math.floor(c*m):Ai;_>Ai&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${Ai}`);const p=[];let g=0;for(let S=0;S<Ai;++S){const w=S/m,C=Math.exp(-w*w/2);p.push(C),S==0?g+=C:S<_&&(g+=2*C)}for(let S=0;S<p.length;S++)p[S]=p[S]/g;f.envMap.value=e.texture,f.samples.value=_,f.weights.value=p,f.latitudinal.value=a==="latitudinal",o&&(f.poleAxis.value=o),f.dTheta.value=v,f.mipInt.value=An-n,this._setEncoding(f.inputEncoding,e.texture),this._setEncoding(f.outputEncoding,e.texture);const y=Dl[r],x=3*Math.max(0,en-2*y),M=(r===0?0:2*en)+2*y*(r>An-Ti?r-An+Ti:0);ls(t,x,M,3*y,2*y),u.setRenderTarget(t),u.render(l,Ua)}}function Gm(i){return i===void 0||i.type!==_n?!1:i.encoding===Tt||i.encoding===Or||i.encoding===ra}function km(){const i=[],e=[],t=[];let n=An;for(let r=0;r<Il;r++){const s=Math.pow(2,n);e.push(s);let a=1/s;r>An-Ti?a=Nl[r-An+Ti-1]:r==0&&(a=0),t.push(a);const o=1/(s-1),u=-o/2,h=1+o/2,c=[u,u,h,u,h,h,u,u,h,h,u,h],l=6,f=6,d=3,v=2,m=1,_=new Float32Array(d*f*l),p=new Float32Array(v*f*l),g=new Float32Array(m*f*l);for(let x=0;x<l;x++){const M=x%3*2/3-1,S=x>2?0:-1,w=[M,S,0,M+2/3,S,0,M+2/3,S+1,0,M,S,0,M+2/3,S+1,0,M,S+1,0];_.set(w,d*f*x),p.set(c,v*f*x);const C=[x,x,x,x,x,x];g.set(C,m*f*x)}const y=new Ye;y.setAttribute("position",new lt(_,d)),y.setAttribute("uv",new lt(p,v)),y.setAttribute("faceIndex",new lt(g,m)),i.push(y),n>Ti&&n--}return{_lodPlanes:i,_sizeLods:e,_sigmas:t}}function Bl(i){const e=new Vt(3*en,3*en,i);return e.texture.mapping=Nr,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ls(i,e,t,n,r){i.viewport.set(e,t,n,r),i.scissor.set(e,t,n,r)}function Wm(i){const e=new Float32Array(i),t=new P(0,1,0);return new as({name:"SphericalGaussianBlur",defines:{n:i},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Jn[Tt]},outputEncoding:{value:Jn[Tt]}},vertexShader:Ha(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ga()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:vn,depthTest:!1,depthWrite:!1})}function Ol(){const i=new le(1,1);return new as({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:i},inputEncoding:{value:Jn[Tt]},outputEncoding:{value:Jn[Tt]}},vertexShader:Ha(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ga()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:vn,depthTest:!1,depthWrite:!1})}function Ul(){return new as({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Jn[Tt]},outputEncoding:{value:Jn[Tt]}},vertexShader:Ha(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ga()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:vn,depthTest:!1,depthWrite:!1})}function Ha(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Ga(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function qm(i){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const u=o.mapping,h=u===$s||u===Qs,c=u===$i||u===Qi;if(h||c){if(e.has(o))return e.get(o).texture;{const l=o.image;if(h&&l&&l.height>0||c&&l&&r(l)){const f=i.getRenderTarget();t===null&&(t=new Hm(i));const d=h?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,d),i.setRenderTarget(f),o.addEventListener("dispose",s),d.texture}else return null}}}return o}function r(o){let u=0;const h=6;for(let c=0;c<h;c++)o[c]!==void 0&&u++;return u===h}function s(o){const u=o.target;u.removeEventListener("dispose",s);const h=e.get(u);h!==void 0&&(e.delete(u),h.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function Xm(i){const e={};function t(n){if(e[n]!==void 0)return e[n];let r;switch(n){case"WEBGL_depth_texture":r=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=i.getExtension(n)}return e[n]=r,r}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const r=t(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function Zm(i,e,t,n){const r={},s=new WeakMap;function a(l){const f=l.target;f.index!==null&&e.remove(f.index);for(const v in f.attributes)e.remove(f.attributes[v]);f.removeEventListener("dispose",a),delete r[f.id];const d=s.get(f);d&&(e.remove(d),s.delete(f)),n.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function o(l,f){return r[f.id]===!0||(f.addEventListener("dispose",a),r[f.id]=!0,t.memory.geometries++),f}function u(l){const f=l.attributes;for(const v in f)e.update(f[v],34962);const d=l.morphAttributes;for(const v in d){const m=d[v];for(let _=0,p=m.length;_<p;_++)e.update(m[_],34962)}}function h(l){const f=[],d=l.index,v=l.attributes.position;let m=0;if(d!==null){const g=d.array;m=d.version;for(let y=0,x=g.length;y<x;y+=3){const M=g[y+0],S=g[y+1],w=g[y+2];f.push(M,S,S,w,w,M)}}else{const g=v.array;m=v.version;for(let y=0,x=g.length/3-1;y<x;y+=3){const M=y+0,S=y+1,w=y+2;f.push(M,S,S,w,w,M)}}const _=new(pl(f)>65535?Cl:Al)(f,1);_.version=m;const p=s.get(l);p&&e.remove(p),s.set(l,_)}function c(l){const f=s.get(l);if(f){const d=l.index;d!==null&&f.version<d.version&&h(l)}else h(l);return s.get(l)}return{get:o,update:u,getWireframeAttribute:c}}function Ym(i,e,t,n){const r=n.isWebGL2;let s;function a(f){s=f}let o,u;function h(f){o=f.type,u=f.bytesPerElement}function c(f,d){i.drawElements(s,d,o,f*u),t.update(d,s,1)}function l(f,d,v){if(v===0)return;let m,_;if(r)m=i,_="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),_="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[_](s,d,o,f*u,v),t.update(d,s,v)}this.setMode=a,this.setIndex=h,this.render=c,this.renderInstances=l}function Jm(i){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(t.calls++,a){case 4:t.triangles+=o*(s/3);break;case 1:t.lines+=o*(s/2);break;case 3:t.lines+=o*(s-1);break;case 2:t.lines+=o*s;break;case 0:t.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:n}}class ka extends mt{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r},this.magFilter=ut,this.minFilter=ut,this.wrapR=Ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ka.prototype.isDataTexture2DArray=!0;function jm(i,e){return i[0]-e[0]}function $m(i,e){return Math.abs(e[1])-Math.abs(i[1])}function Vl(i,e){let t=1;const n=e.isInterleavedBufferAttribute?e.data.array:e.array;n instanceof Int8Array?t=127:n instanceof Int16Array?t=32767:n instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),i.divideScalar(t)}function Qm(i,e,t){const n={},r=new Float32Array(8),s=new WeakMap,a=new P,o=[];for(let h=0;h<8;h++)o[h]=[h,0];function u(h,c,l,f){const d=h.morphTargetInfluences;if(e.isWebGL2===!0){const v=c.morphAttributes.position.length;let m=s.get(c);if(m===void 0||m.count!==v){m!==void 0&&m.texture.dispose();const g=c.morphAttributes.normal!==void 0,y=c.morphAttributes.position,x=c.morphAttributes.normal||[],M=c.attributes.position.count,S=g===!0?2:1;let w=M*S,C=1;w>e.maxTextureSize&&(C=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);const I=new Float32Array(w*C*4*v),D=new ka(I,w,C,v);D.format=bt,D.type=yn;const T=S*4;for(let O=0;O<v;O++){const B=y[O],F=x[O],z=w*C*4*O;for(let N=0;N<B.count;N++){a.fromBufferAttribute(B,N),B.normalized===!0&&Vl(a,B);const U=N*T;I[z+U+0]=a.x,I[z+U+1]=a.y,I[z+U+2]=a.z,I[z+U+3]=0,g===!0&&(a.fromBufferAttribute(F,N),F.normalized===!0&&Vl(a,F),I[z+U+4]=a.x,I[z+U+5]=a.y,I[z+U+6]=a.z,I[z+U+7]=0)}}m={count:v,texture:D,size:new le(w,C)},s.set(c,m)}let _=0;for(let g=0;g<d.length;g++)_+=d[g];const p=c.morphTargetsRelative?1:1-_;f.getUniforms().setValue(i,"morphTargetBaseInfluence",p),f.getUniforms().setValue(i,"morphTargetInfluences",d),f.getUniforms().setValue(i,"morphTargetsTexture",m.texture,t),f.getUniforms().setValue(i,"morphTargetsTextureSize",m.size)}else{const v=d===void 0?0:d.length;let m=n[c.id];if(m===void 0||m.length!==v){m=[];for(let x=0;x<v;x++)m[x]=[x,0];n[c.id]=m}for(let x=0;x<v;x++){const M=m[x];M[0]=x,M[1]=d[x]}m.sort($m);for(let x=0;x<8;x++)x<v&&m[x][1]?(o[x][0]=m[x][0],o[x][1]=m[x][1]):(o[x][0]=Number.MAX_SAFE_INTEGER,o[x][1]=0);o.sort(jm);const _=c.morphAttributes.position,p=c.morphAttributes.normal;let g=0;for(let x=0;x<8;x++){const M=o[x],S=M[0],w=M[1];S!==Number.MAX_SAFE_INTEGER&&w?(_&&c.getAttribute("morphTarget"+x)!==_[S]&&c.setAttribute("morphTarget"+x,_[S]),p&&c.getAttribute("morphNormal"+x)!==p[S]&&c.setAttribute("morphNormal"+x,p[S]),r[x]=w,g+=w):(_&&c.hasAttribute("morphTarget"+x)===!0&&c.deleteAttribute("morphTarget"+x),p&&c.hasAttribute("morphNormal"+x)===!0&&c.deleteAttribute("morphNormal"+x),r[x]=0)}const y=c.morphTargetsRelative?1:1-g;f.getUniforms().setValue(i,"morphTargetBaseInfluence",y),f.getUniforms().setValue(i,"morphTargetInfluences",r)}}return{update:u}}function Km(i,e,t,n){let r=new WeakMap;function s(u){const h=n.render.frame,c=u.geometry,l=e.get(u,c);return r.get(l)!==h&&(e.update(l),r.set(l,h)),u.isInstancedMesh&&(u.hasEventListener("dispose",o)===!1&&u.addEventListener("dispose",o),t.update(u.instanceMatrix,34962),u.instanceColor!==null&&t.update(u.instanceColor,34962)),l}function a(){r=new WeakMap}function o(u){const h=u.target;h.removeEventListener("dispose",o),t.remove(h.instanceMatrix),h.instanceColor!==null&&t.remove(h.instanceColor)}return{update:s,dispose:a}}class Hl extends mt{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r},this.magFilter=ut,this.minFilter=ut,this.wrapR=Ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Hl.prototype.isDataTexture3D=!0;const Gl=new mt,kl=new ka,Wl=new Hl,ql=new is,Xl=[],Zl=[],Yl=new Float32Array(16),Jl=new Float32Array(9),jl=new Float32Array(4);function Li(i,e,t){const n=i[0];if(n<=0||n>0)return i;const r=e*t;let s=Xl[r];if(s===void 0&&(s=new Float32Array(r),Xl[r]=s),e!==0){n.toArray(s,0);for(let a=1,o=0;a!==e;++a)o+=t,i[a].toArray(s,o)}return s}function St(i,e){if(i.length!==e.length)return!1;for(let t=0,n=i.length;t<n;t++)if(i[t]!==e[t])return!1;return!0}function wt(i,e){for(let t=0,n=e.length;t<n;t++)i[t]=e[t]}function cs(i,e){let t=Zl[e];t===void 0&&(t=new Int32Array(e),Zl[e]=t);for(let n=0;n!==e;++n)t[n]=i.allocateTextureUnit();return t}function eg(i,e){const t=this.cache;t[0]!==e&&(i.uniform1f(this.addr,e),t[0]=e)}function tg(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(i.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(St(t,e))return;i.uniform2fv(this.addr,e),wt(t,e)}}function ng(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(i.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(i.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(St(t,e))return;i.uniform3fv(this.addr,e),wt(t,e)}}function ig(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(i.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(St(t,e))return;i.uniform4fv(this.addr,e),wt(t,e)}}function rg(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(St(t,e))return;i.uniformMatrix2fv(this.addr,!1,e),wt(t,e)}else{if(St(t,n))return;jl.set(n),i.uniformMatrix2fv(this.addr,!1,jl),wt(t,n)}}function sg(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(St(t,e))return;i.uniformMatrix3fv(this.addr,!1,e),wt(t,e)}else{if(St(t,n))return;Jl.set(n),i.uniformMatrix3fv(this.addr,!1,Jl),wt(t,n)}}function ag(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(St(t,e))return;i.uniformMatrix4fv(this.addr,!1,e),wt(t,e)}else{if(St(t,n))return;Yl.set(n),i.uniformMatrix4fv(this.addr,!1,Yl),wt(t,n)}}function og(i,e){const t=this.cache;t[0]!==e&&(i.uniform1i(this.addr,e),t[0]=e)}function lg(i,e){const t=this.cache;St(t,e)||(i.uniform2iv(this.addr,e),wt(t,e))}function cg(i,e){const t=this.cache;St(t,e)||(i.uniform3iv(this.addr,e),wt(t,e))}function ug(i,e){const t=this.cache;St(t,e)||(i.uniform4iv(this.addr,e),wt(t,e))}function hg(i,e){const t=this.cache;t[0]!==e&&(i.uniform1ui(this.addr,e),t[0]=e)}function fg(i,e){const t=this.cache;St(t,e)||(i.uniform2uiv(this.addr,e),wt(t,e))}function dg(i,e){const t=this.cache;St(t,e)||(i.uniform3uiv(this.addr,e),wt(t,e))}function pg(i,e){const t=this.cache;St(t,e)||(i.uniform4uiv(this.addr,e),wt(t,e))}function mg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.safeSetTexture2D(e||Gl,r)}function gg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.setTexture3D(e||Wl,r)}function vg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.safeSetTextureCube(e||ql,r)}function _g(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.setTexture2DArray(e||kl,r)}function yg(i){switch(i){case 5126:return eg;case 35664:return tg;case 35665:return ng;case 35666:return ig;case 35674:return rg;case 35675:return sg;case 35676:return ag;case 5124:case 35670:return og;case 35667:case 35671:return lg;case 35668:case 35672:return cg;case 35669:case 35673:return ug;case 5125:return hg;case 36294:return fg;case 36295:return dg;case 36296:return pg;case 35678:case 36198:case 36298:case 36306:case 35682:return mg;case 35679:case 36299:case 36307:return gg;case 35680:case 36300:case 36308:case 36293:return vg;case 36289:case 36303:case 36311:case 36292:return _g}}function xg(i,e){i.uniform1fv(this.addr,e)}function wg(i,e){const t=Li(e,this.size,2);i.uniform2fv(this.addr,t)}function Mg(i,e){const t=Li(e,this.size,3);i.uniform3fv(this.addr,t)}function bg(i,e){const t=Li(e,this.size,4);i.uniform4fv(this.addr,t)}function Sg(i,e){const t=Li(e,this.size,4);i.uniformMatrix2fv(this.addr,!1,t)}function Eg(i,e){const t=Li(e,this.size,9);i.uniformMatrix3fv(this.addr,!1,t)}function Tg(i,e){const t=Li(e,this.size,16);i.uniformMatrix4fv(this.addr,!1,t)}function Ag(i,e){i.uniform1iv(this.addr,e)}function Cg(i,e){i.uniform2iv(this.addr,e)}function Lg(i,e){i.uniform3iv(this.addr,e)}function Rg(i,e){i.uniform4iv(this.addr,e)}function Pg(i,e){i.uniform1uiv(this.addr,e)}function Ng(i,e){i.uniform2uiv(this.addr,e)}function Ig(i,e){i.uniform3uiv(this.addr,e)}function Dg(i,e){i.uniform4uiv(this.addr,e)}function Fg(i,e,t){const n=e.length,r=cs(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.safeSetTexture2D(e[s]||Gl,r[s])}function zg(i,e,t){const n=e.length,r=cs(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.setTexture3D(e[s]||Wl,r[s])}function Bg(i,e,t){const n=e.length,r=cs(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.safeSetTextureCube(e[s]||ql,r[s])}function Og(i,e,t){const n=e.length,r=cs(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.setTexture2DArray(e[s]||kl,r[s])}function Ug(i){switch(i){case 5126:return xg;case 35664:return wg;case 35665:return Mg;case 35666:return bg;case 35674:return Sg;case 35675:return Eg;case 35676:return Tg;case 5124:case 35670:return Ag;case 35667:case 35671:return Cg;case 35668:case 35672:return Lg;case 35669:case 35673:return Rg;case 5125:return Pg;case 36294:return Ng;case 36295:return Ig;case 36296:return Dg;case 35678:case 36198:case 36298:case 36306:case 35682:return Fg;case 35679:case 36299:case 36307:return zg;case 35680:case 36300:case 36308:case 36293:return Bg;case 36289:case 36303:case 36311:case 36292:return Og}}function Vg(i,e,t){this.id=i,this.addr=t,this.cache=[],this.setValue=yg(e.type)}function $l(i,e,t){this.id=i,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Ug(e.type)}$l.prototype.updateCache=function(i){const e=this.cache;i instanceof Float32Array&&e.length!==i.length&&(this.cache=new Float32Array(i.length)),wt(e,i)};function Ql(i){this.id=i,this.seq=[],this.map={}}Ql.prototype.setValue=function(i,e,t){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const a=n[r];a.setValue(i,e[a.id],t)}};const Wa=/(\w+)(\])?(\[|\.)?/g;function Kl(i,e){i.seq.push(e),i.map[e.id]=e}function Hg(i,e,t){const n=i.name,r=n.length;for(Wa.lastIndex=0;;){const s=Wa.exec(n),a=Wa.lastIndex;let o=s[1];const u=s[2]==="]",h=s[3];if(u&&(o=o|0),h===void 0||h==="["&&a+2===r){Kl(t,h===void 0?new Vg(o,i,e):new $l(o,i,e));break}else{let l=t.map[o];l===void 0&&(l=new Ql(o),Kl(t,l)),t=l}}}function Cn(i,e){this.seq=[],this.map={};const t=i.getProgramParameter(e,35718);for(let n=0;n<t;++n){const r=i.getActiveUniform(e,n),s=i.getUniformLocation(e,r.name);Hg(r,s,this)}}Cn.prototype.setValue=function(i,e,t,n){const r=this.map[e];r!==void 0&&r.setValue(i,t,n)};Cn.prototype.setOptional=function(i,e,t){const n=e[t];n!==void 0&&this.setValue(i,t,n)};Cn.upload=function(i,e,t,n){for(let r=0,s=e.length;r!==s;++r){const a=e[r],o=t[a.id];o.needsUpdate!==!1&&a.setValue(i,o.value,n)}};Cn.seqWithValue=function(i,e){const t=[];for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.id in e&&t.push(s)}return t};function ec(i,e,t){const n=i.createShader(e);return i.shaderSource(n,t),i.compileShader(n),n}let Gg=0;function kg(i){const e=i.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function tc(i){switch(i){case Tt:return["Linear","( value )"];case Or:return["sRGB","( value )"];case sa:return["RGBE","( value )"];case cl:return["RGBM","( value, 7.0 )"];case ul:return["RGBM","( value, 16.0 )"];case hl:return["RGBD","( value, 256.0 )"];case ra:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function nc(i,e,t){const n=i.getShaderParameter(e,35713),r=i.getShaderInfoLog(e).trim();return n&&r===""?"":t.toUpperCase()+`

`+r+`

`+kg(i.getShaderSource(e))}function $n(i,e){const t=tc(e);return"vec4 "+i+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Wg(i,e){const t=tc(e);return"vec4 "+i+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function qg(i,e){let t;switch(e){case Dh:t="Linear";break;case Fh:t="Reinhard";break;case zh:t="OptimizedCineon";break;case Bh:t="ACESFilmic";break;case Oh:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+i+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xg(i){return[i.extensionDerivatives||i.envMapCubeUV||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap||i.transmission)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(or).join(`
`)}function Zg(i){const e=[];for(const t in i){const n=i[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function Yg(i,e){const t={},n=i.getProgramParameter(e,35721);for(let r=0;r<n;r++){const s=i.getActiveAttrib(e,r),a=s.name;let o=1;s.type===35674&&(o=2),s.type===35675&&(o=3),s.type===35676&&(o=4),t[a]={type:s.type,location:i.getAttribLocation(e,a),locationSize:o}}return t}function or(i){return i!==""}function ic(i,e){return i.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function rc(i,e){return i.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Jg=/^[ \t]*#include +<([\w\d./]+)>/gm;function qa(i){return i.replace(Jg,jg)}function jg(i,e){const t=Be[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return qa(t)}const $g=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Qg=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function sc(i){return i.replace(Qg,ac).replace($g,Kg)}function Kg(i,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),ac(i,e,t,n)}function ac(i,e,t,n){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function oc(i){let e="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?e+=`
#define HIGH_PRECISION`:i.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function ev(i){let e="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===Vo?e="SHADOWMAP_TYPE_PCF":i.shadowMapType===fh?e="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===Yi&&(e="SHADOWMAP_TYPE_VSM"),e}function tv(i){let e="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case $i:case Qi:e="ENVMAP_TYPE_CUBE";break;case Nr:case Ks:e="ENVMAP_TYPE_CUBE_UV";break}return e}function nv(i){let e="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case Qi:case Ks:e="ENVMAP_MODE_REFRACTION";break}return e}function iv(i){let e="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case Pr:e="ENVMAP_BLENDING_MULTIPLY";break;case Nh:e="ENVMAP_BLENDING_MIX";break;case Ih:e="ENVMAP_BLENDING_ADD";break}return e}function rv(i,e,t,n){const r=i.getContext(),s=t.defines;let a=t.vertexShader,o=t.fragmentShader;const u=ev(t),h=tv(t),c=nv(t),l=iv(t),f=i.gammaFactor>0?i.gammaFactor:1,d=t.isWebGL2?"":Xg(t),v=Zg(s),m=r.createProgram();let _,p,g=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(_=[v].filter(or).join(`
`),_.length>0&&(_+=`
`),p=[d,v].filter(or).join(`
`),p.length>0&&(p+=`
`)):(_=[oc(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(or).join(`
`),p=[d,oc(t),"#define SHADER_NAME "+t.shaderName,v,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.envMap?"#define "+c:"",t.envMap?"#define "+l:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Gn?"#define TONE_MAPPING":"",t.toneMapping!==Gn?Be.tonemapping_pars_fragment:"",t.toneMapping!==Gn?qg("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===kn?"#define OPAQUE":"",Be.encodings_pars_fragment,t.map?$n("mapTexelToLinear",t.mapEncoding):"",t.matcap?$n("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?$n("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?$n("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularColorMap?$n("specularColorMapTexelToLinear",t.specularColorMapEncoding):"",t.sheenColorMap?$n("sheenColorMapTexelToLinear",t.sheenColorMapEncoding):"",t.lightMap?$n("lightMapTexelToLinear",t.lightMapEncoding):"",Wg("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(or).join(`
`)),a=qa(a),a=ic(a,t),a=rc(a,t),o=qa(o),o=ic(o,t),o=rc(o,t),a=sc(a),o=sc(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(g=`#version 300 es
`,_=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+_,p=["#define varying in",t.glslVersion===fl?"":"out highp vec4 pc_fragColor;",t.glslVersion===fl?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+p);const y=g+_+a,x=g+p+o,M=ec(r,35633,y),S=ec(r,35632,x);if(r.attachShader(m,M),r.attachShader(m,S),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),i.debug.checkShaderErrors){const I=r.getProgramInfoLog(m).trim(),D=r.getShaderInfoLog(M).trim(),T=r.getShaderInfoLog(S).trim();let O=!0,B=!0;if(r.getProgramParameter(m,35714)===!1){O=!1;const F=nc(r,M,"vertex"),z=nc(r,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,35715)+`

Program Info Log: `+I+`
`+F+`
`+z)}else I!==""?console.warn("THREE.WebGLProgram: Program Info Log:",I):(D===""||T==="")&&(B=!1);B&&(this.diagnostics={runnable:O,programLog:I,vertexShader:{log:D,prefix:_},fragmentShader:{log:T,prefix:p}})}r.deleteShader(M),r.deleteShader(S);let w;this.getUniforms=function(){return w===void 0&&(w=new Cn(r,m)),w};let C;return this.getAttributes=function(){return C===void 0&&(C=Yg(r,m)),C},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Gg++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=M,this.fragmentShader=S,this}function sv(i,e,t,n,r,s,a){const o=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,c=r.floatVertexTextures,l=r.maxVertexUniforms,f=r.vertexTextures;let d=r.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function _(w){const I=w.skeleton.bones;if(c)return 1024;{const T=Math.floor((l-20)/4),O=Math.min(T,I.length);return O<I.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+I.length+" bones. This GPU supports "+O+"."),0):O}}function p(w){let C;return w&&w.isTexture?C=w.encoding:w&&w.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),C=w.texture.encoding):C=Tt,C}function g(w,C,I,D,T){const O=D.fog,B=w.isMeshStandardMaterial?D.environment:null,F=(w.isMeshStandardMaterial?t:e).get(w.envMap||B),z=v[w.type],N=T.isSkinnedMesh?_(T):0;w.precision!==null&&(d=r.getMaxPrecision(w.precision),d!==w.precision&&console.warn("THREE.WebGLProgram.getParameters:",w.precision,"not supported, using",d,"instead."));let U,Y;if(z){const se=Kt[z];U=se.vertexShader,Y=se.fragmentShader}else U=w.vertexShader,Y=w.fragmentShader;const ee=i.getRenderTarget(),k=w.alphaTest>0,q=w.clearcoat>0;return{isWebGL2:u,shaderID:z,shaderName:w.type,vertexShader:U,fragmentShader:Y,defines:w.defines,isRawShaderMaterial:w.isRawShaderMaterial===!0,glslVersion:w.glslVersion,precision:d,instancing:T.isInstancedMesh===!0,instancingColor:T.isInstancedMesh===!0&&T.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ee!==null?p(ee.texture):i.outputEncoding,map:!!w.map,mapEncoding:p(w.map),matcap:!!w.matcap,matcapEncoding:p(w.matcap),envMap:!!F,envMapMode:F&&F.mapping,envMapEncoding:p(F),envMapCubeUV:!!F&&(F.mapping===Nr||F.mapping===Ks),lightMap:!!w.lightMap,lightMapEncoding:p(w.lightMap),aoMap:!!w.aoMap,emissiveMap:!!w.emissiveMap,emissiveMapEncoding:p(w.emissiveMap),bumpMap:!!w.bumpMap,normalMap:!!w.normalMap,objectSpaceNormalMap:w.normalMapType===Uf,tangentSpaceNormalMap:w.normalMapType===oi,clearcoat:q,clearcoatMap:q&&!!w.clearcoatMap,clearcoatRoughnessMap:q&&!!w.clearcoatRoughnessMap,clearcoatNormalMap:q&&!!w.clearcoatNormalMap,displacementMap:!!w.displacementMap,roughnessMap:!!w.roughnessMap,metalnessMap:!!w.metalnessMap,specularMap:!!w.specularMap,specularIntensityMap:!!w.specularIntensityMap,specularColorMap:!!w.specularColorMap,specularColorMapEncoding:p(w.specularColorMap),alphaMap:!!w.alphaMap,alphaTest:k,gradientMap:!!w.gradientMap,sheen:w.sheen>0,sheenColorMap:!!w.sheenColorMap,sheenColorMapEncoding:p(w.sheenColorMap),sheenRoughnessMap:!!w.sheenRoughnessMap,transmission:w.transmission>0,transmissionMap:!!w.transmissionMap,thicknessMap:!!w.thicknessMap,combine:w.combine,vertexTangents:!!w.normalMap&&!!T.geometry&&!!T.geometry.attributes.tangent,vertexColors:w.vertexColors,vertexAlphas:w.vertexColors===!0&&!!T.geometry&&!!T.geometry.attributes.color&&T.geometry.attributes.color.itemSize===4,vertexUvs:!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatMap||!!w.clearcoatRoughnessMap||!!w.clearcoatNormalMap||!!w.displacementMap||!!w.transmissionMap||!!w.thicknessMap||!!w.specularIntensityMap||!!w.specularColorMap||!!w.sheenColorMap||w.sheenRoughnessMap,uvsVertexOnly:!(!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatNormalMap||w.transmission>0||!!w.transmissionMap||!!w.thicknessMap||!!w.specularIntensityMap||!!w.specularColorMap||w.sheen>0||!!w.sheenColorMap||!!w.sheenRoughnessMap)&&!!w.displacementMap,fog:!!O,useFog:w.fog,fogExp2:O&&O.isFogExp2,flatShading:!!w.flatShading,sizeAttenuation:w.sizeAttenuation,logarithmicDepthBuffer:h,skinning:T.isSkinnedMesh===!0&&N>0,maxBones:N,useVertexTexture:c,morphTargets:!!T.geometry&&!!T.geometry.morphAttributes.position,morphNormals:!!T.geometry&&!!T.geometry.morphAttributes.normal,morphTargetsCount:!!T.geometry&&!!T.geometry.morphAttributes.position?T.geometry.morphAttributes.position.length:0,numDirLights:C.directional.length,numPointLights:C.point.length,numSpotLights:C.spot.length,numRectAreaLights:C.rectArea.length,numHemiLights:C.hemi.length,numDirLightShadows:C.directionalShadowMap.length,numPointLightShadows:C.pointShadowMap.length,numSpotLightShadows:C.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:w.format,dithering:w.dithering,shadowMapEnabled:i.shadowMap.enabled&&I.length>0,shadowMapType:i.shadowMap.type,toneMapping:w.toneMapped?i.toneMapping:Gn,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:w.premultipliedAlpha,doubleSided:w.side===ei,flipSided:w.side===ot,depthPacking:w.depthPacking!==void 0?w.depthPacking:!1,index0AttributeName:w.index0AttributeName,extensionDerivatives:w.extensions&&w.extensions.derivatives,extensionFragDepth:w.extensions&&w.extensions.fragDepth,extensionDrawBuffers:w.extensions&&w.extensions.drawBuffers,extensionShaderTextureLOD:w.extensions&&w.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:w.customProgramCacheKey()}}function y(w){const C=[];if(w.shaderID?C.push(w.shaderID):(C.push(ml(w.fragmentShader)),C.push(ml(w.vertexShader))),w.defines!==void 0)for(const I in w.defines)C.push(I),C.push(w.defines[I]);if(w.isRawShaderMaterial===!1){for(let I=0;I<m.length;I++)C.push(w[m[I]]);C.push(i.outputEncoding),C.push(i.gammaFactor)}return C.push(w.customProgramCacheKey),C.join()}function x(w){const C=v[w.type];let I;if(C){const D=Kt[C];I=id.clone(D.uniforms)}else I=w.uniforms;return I}function M(w,C){let I;for(let D=0,T=o.length;D<T;D++){const O=o[D];if(O.cacheKey===C){I=O,++I.usedTimes;break}}return I===void 0&&(I=new rv(i,C,w,s),o.push(I)),I}function S(w){if(--w.usedTimes==0){const C=o.indexOf(w);o[C]=o[o.length-1],o.pop(),w.destroy()}}return{getParameters:g,getProgramCacheKey:y,getUniforms:x,acquireProgram:M,releaseProgram:S,programs:o}}function av(){let i=new WeakMap;function e(s){let a=i.get(s);return a===void 0&&(a={},i.set(s,a)),a}function t(s){i.delete(s)}function n(s,a,o){i.get(s)[a]=o}function r(){i=new WeakMap}return{get:e,remove:t,update:n,dispose:r}}function ov(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.program!==e.program?i.program.id-e.program.id:i.material.id!==e.material.id?i.material.id-e.material.id:i.z!==e.z?i.z-e.z:i.id-e.id}function lc(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.z!==e.z?e.z-i.z:i.id-e.id}function cc(i){const e=[];let t=0;const n=[],r=[],s=[],a={id:-1};function o(){t=0,n.length=0,r.length=0,s.length=0}function u(d,v,m,_,p,g){let y=e[t];const x=i.get(m);return y===void 0?(y={id:d.id,object:d,geometry:v,material:m,program:x.program||a,groupOrder:_,renderOrder:d.renderOrder,z:p,group:g},e[t]=y):(y.id=d.id,y.object=d,y.geometry=v,y.material=m,y.program=x.program||a,y.groupOrder=_,y.renderOrder=d.renderOrder,y.z=p,y.group=g),t++,y}function h(d,v,m,_,p,g){const y=u(d,v,m,_,p,g);m.transmission>0?r.push(y):m.transparent===!0?s.push(y):n.push(y)}function c(d,v,m,_,p,g){const y=u(d,v,m,_,p,g);m.transmission>0?r.unshift(y):m.transparent===!0?s.unshift(y):n.unshift(y)}function l(d,v){n.length>1&&n.sort(d||ov),r.length>1&&r.sort(v||lc),s.length>1&&s.sort(v||lc)}function f(){for(let d=t,v=e.length;d<v;d++){const m=e[d];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.program=null,m.group=null}}return{opaque:n,transmissive:r,transparent:s,init:o,push:h,unshift:c,finish:f,sort:l}}function lv(i){let e=new WeakMap;function t(r,s){let a;return e.has(r)===!1?(a=new cc(i),e.set(r,[a])):s>=e.get(r).length?(a=new cc(i),e.get(r).push(a)):a=e.get(r)[s],a}function n(){e=new WeakMap}return{get:t,dispose:n}}function cv(){const i={};return{get:function(e){if(i[e.id]!==void 0)return i[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new P,color:new Ee};break;case"SpotLight":t={position:new P,direction:new P,color:new Ee,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new P,color:new Ee,distance:0,decay:0};break;case"HemisphereLight":t={direction:new P,skyColor:new Ee,groundColor:new Ee};break;case"RectAreaLight":t={color:new Ee,position:new P,halfWidth:new P,halfHeight:new P};break}return i[e.id]=t,t}}}function uv(){const i={};return{get:function(e){if(i[e.id]!==void 0)return i[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[e.id]=t,t}}}let hv=0;function fv(i,e){return(e.castShadow?1:0)-(i.castShadow?1:0)}function dv(i,e){const t=new cv,n=uv(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let c=0;c<9;c++)r.probe.push(new P);const s=new P,a=new Re,o=new Re;function u(c,l){let f=0,d=0,v=0;for(let I=0;I<9;I++)r.probe[I].set(0,0,0);let m=0,_=0,p=0,g=0,y=0,x=0,M=0,S=0;c.sort(fv);const w=l!==!0?Math.PI:1;for(let I=0,D=c.length;I<D;I++){const T=c[I],O=T.color,B=T.intensity,F=T.distance,z=T.shadow&&T.shadow.map?T.shadow.map.texture:null;if(T.isAmbientLight)f+=O.r*B*w,d+=O.g*B*w,v+=O.b*B*w;else if(T.isLightProbe)for(let N=0;N<9;N++)r.probe[N].addScaledVector(T.sh.coefficients[N],B);else if(T.isDirectionalLight){const N=t.get(T);if(N.color.copy(T.color).multiplyScalar(T.intensity*w),T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,r.directionalShadow[m]=Y,r.directionalShadowMap[m]=z,r.directionalShadowMatrix[m]=T.shadow.matrix,x++}r.directional[m]=N,m++}else if(T.isSpotLight){const N=t.get(T);if(N.position.setFromMatrixPosition(T.matrixWorld),N.color.copy(O).multiplyScalar(B*w),N.distance=F,N.coneCos=Math.cos(T.angle),N.penumbraCos=Math.cos(T.angle*(1-T.penumbra)),N.decay=T.decay,T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,r.spotShadow[p]=Y,r.spotShadowMap[p]=z,r.spotShadowMatrix[p]=T.shadow.matrix,S++}r.spot[p]=N,p++}else if(T.isRectAreaLight){const N=t.get(T);N.color.copy(O).multiplyScalar(B),N.halfWidth.set(T.width*.5,0,0),N.halfHeight.set(0,T.height*.5,0),r.rectArea[g]=N,g++}else if(T.isPointLight){const N=t.get(T);if(N.color.copy(T.color).multiplyScalar(T.intensity*w),N.distance=T.distance,N.decay=T.decay,T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,Y.shadowCameraNear=U.camera.near,Y.shadowCameraFar=U.camera.far,r.pointShadow[_]=Y,r.pointShadowMap[_]=z,r.pointShadowMatrix[_]=T.shadow.matrix,M++}r.point[_]=N,_++}else if(T.isHemisphereLight){const N=t.get(T);N.skyColor.copy(T.color).multiplyScalar(B*w),N.groundColor.copy(T.groundColor).multiplyScalar(B*w),r.hemi[y]=N,y++}}g>0&&(e.isWebGL2||i.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=ge.LTC_FLOAT_1,r.rectAreaLTC2=ge.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=ge.LTC_HALF_1,r.rectAreaLTC2=ge.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=f,r.ambient[1]=d,r.ambient[2]=v;const C=r.hash;(C.directionalLength!==m||C.pointLength!==_||C.spotLength!==p||C.rectAreaLength!==g||C.hemiLength!==y||C.numDirectionalShadows!==x||C.numPointShadows!==M||C.numSpotShadows!==S)&&(r.directional.length=m,r.spot.length=p,r.rectArea.length=g,r.point.length=_,r.hemi.length=y,r.directionalShadow.length=x,r.directionalShadowMap.length=x,r.pointShadow.length=M,r.pointShadowMap.length=M,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=x,r.pointShadowMatrix.length=M,r.spotShadowMatrix.length=S,C.directionalLength=m,C.pointLength=_,C.spotLength=p,C.rectAreaLength=g,C.hemiLength=y,C.numDirectionalShadows=x,C.numPointShadows=M,C.numSpotShadows=S,r.version=hv++)}function h(c,l){let f=0,d=0,v=0,m=0,_=0;const p=l.matrixWorldInverse;for(let g=0,y=c.length;g<y;g++){const x=c[g];if(x.isDirectionalLight){const M=r.directional[f];M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(p),f++}else if(x.isSpotLight){const M=r.spot[v];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(p),v++}else if(x.isRectAreaLight){const M=r.rectArea[m];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),o.identity(),a.copy(x.matrixWorld),a.premultiply(p),o.extractRotation(a),M.halfWidth.set(x.width*.5,0,0),M.halfHeight.set(0,x.height*.5,0),M.halfWidth.applyMatrix4(o),M.halfHeight.applyMatrix4(o),m++}else if(x.isPointLight){const M=r.point[d];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),d++}else if(x.isHemisphereLight){const M=r.hemi[_];M.direction.setFromMatrixPosition(x.matrixWorld),M.direction.transformDirection(p),M.direction.normalize(),_++}}}return{setup:u,setupView:h,state:r}}function uc(i,e){const t=new dv(i,e),n=[],r=[];function s(){n.length=0,r.length=0}function a(l){n.push(l)}function o(l){r.push(l)}function u(l){t.setup(n,l)}function h(l){t.setupView(n,l)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:t},setupLights:u,setupLightsView:h,pushLight:a,pushShadow:o}}function pv(i,e){let t=new WeakMap;function n(s,a=0){let o;return t.has(s)===!1?(o=new uc(i,e),t.set(s,[o])):a>=t.get(s).length?(o=new uc(i,e),t.get(s).push(o)):o=t.get(s)[a],o}function r(){t=new WeakMap}return{get:n,dispose:r}}class hc extends yt{constructor(e){super();this.type="MeshDepthMaterial",this.depthPacking=Bf,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}hc.prototype.isMeshDepthMaterial=!0;class fc extends yt{constructor(e){super();this.type="MeshDistanceMaterial",this.referencePosition=new P,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}fc.prototype.isMeshDistanceMaterial=!0;const mv=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,gv=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function dc(i,e,t){let n=new ss;const r=new le,s=new le,a=new We,o=new hc({depthPacking:Of}),u=new fc,h={},c=t.maxTextureSize,l={0:ot,1:Ji,2:ei},f=new Yn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new le},radius:{value:4}},vertexShader:mv,fragmentShader:gv}),d=f.clone();d.defines.HORIZONTAL_PASS=1;const v=new Ye;v.setAttribute("position",new lt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new Ct(v,f),_=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Vo,this.render=function(x,M,S){if(_.enabled===!1||_.autoUpdate===!1&&_.needsUpdate===!1||x.length===0)return;const w=i.getRenderTarget(),C=i.getActiveCubeFace(),I=i.getActiveMipmapLevel(),D=i.state;D.setBlending(vn),D.buffers.color.setClear(1,1,1,1),D.buffers.depth.setTest(!0),D.setScissorTest(!1);for(let T=0,O=x.length;T<O;T++){const B=x[T],F=B.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",B,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;r.copy(F.mapSize);const z=F.getFrameExtents();if(r.multiply(z),s.copy(F.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(s.x=Math.floor(c/z.x),r.x=s.x*z.x,F.mapSize.x=s.x),r.y>c&&(s.y=Math.floor(c/z.y),r.y=s.y*z.y,F.mapSize.y=s.y)),F.map===null&&!F.isPointLightShadow&&this.type===Yi){const U={minFilter:Ut,magFilter:Ut,format:bt};F.map=new Vt(r.x,r.y,U),F.map.texture.name=B.name+".shadowMap",F.mapPass=new Vt(r.x,r.y,U),F.camera.updateProjectionMatrix()}if(F.map===null){const U={minFilter:ut,magFilter:ut,format:bt};F.map=new Vt(r.x,r.y,U),F.map.texture.name=B.name+".shadowMap",F.camera.updateProjectionMatrix()}i.setRenderTarget(F.map),i.clear();const N=F.getViewportCount();for(let U=0;U<N;U++){const Y=F.getViewport(U);a.set(s.x*Y.x,s.y*Y.y,s.x*Y.z,s.y*Y.w),D.viewport(a),F.updateMatrices(B,U),n=F.getFrustum(),y(M,S,F.camera,B,this.type)}!F.isPointLightShadow&&this.type===Yi&&p(F,S),F.needsUpdate=!1}_.needsUpdate=!1,i.setRenderTarget(w,C,I)};function p(x,M){const S=e.update(m);f.defines.VSM_SAMPLES!==x.blurSamples&&(f.defines.VSM_SAMPLES=x.blurSamples,d.defines.VSM_SAMPLES=x.blurSamples,f.needsUpdate=!0,d.needsUpdate=!0),f.uniforms.shadow_pass.value=x.map.texture,f.uniforms.resolution.value=x.mapSize,f.uniforms.radius.value=x.radius,i.setRenderTarget(x.mapPass),i.clear(),i.renderBufferDirect(M,null,S,f,m,null),d.uniforms.shadow_pass.value=x.mapPass.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,i.setRenderTarget(x.map),i.clear(),i.renderBufferDirect(M,null,S,d,m,null)}function g(x,M,S,w,C,I,D){let T=null;const O=w.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(O!==void 0?T=O:T=w.isPointLight===!0?u:o,i.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const B=T.uuid,F=S.uuid;let z=h[B];z===void 0&&(z={},h[B]=z);let N=z[F];N===void 0&&(N=T.clone(),z[F]=N),T=N}return T.visible=S.visible,T.wireframe=S.wireframe,D===Yi?T.side=S.shadowSide!==null?S.shadowSide:S.side:T.side=S.shadowSide!==null?S.shadowSide:l[S.side],T.alphaMap=S.alphaMap,T.alphaTest=S.alphaTest,T.clipShadows=S.clipShadows,T.clippingPlanes=S.clippingPlanes,T.clipIntersection=S.clipIntersection,T.displacementMap=S.displacementMap,T.displacementScale=S.displacementScale,T.displacementBias=S.displacementBias,T.wireframeLinewidth=S.wireframeLinewidth,T.linewidth=S.linewidth,w.isPointLight===!0&&T.isMeshDistanceMaterial===!0&&(T.referencePosition.setFromMatrixPosition(w.matrixWorld),T.nearDistance=C,T.farDistance=I),T}function y(x,M,S,w,C){if(x.visible===!1)return;if(x.layers.test(M.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&C===Yi)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse,x.matrixWorld);const T=e.update(x),O=x.material;if(Array.isArray(O)){const B=T.groups;for(let F=0,z=B.length;F<z;F++){const N=B[F],U=O[N.materialIndex];if(U&&U.visible){const Y=g(x,T,U,w,S.near,S.far,C);i.renderBufferDirect(S,null,T,Y,x,N)}}}else if(O.visible){const B=g(x,T,O,w,S.near,S.far,C);i.renderBufferDirect(S,null,T,B,x,null)}}const D=x.children;for(let T=0,O=D.length;T<O;T++)y(D[T],M,S,w,C)}}function vv(i,e,t){const n=t.isWebGL2;function r(){let L=!1;const $=new We;let te=null;const ue=new We(0,0,0,0);return{setMask:function(ce){te!==ce&&!L&&(i.colorMask(ce,ce,ce,ce),te=ce)},setLocked:function(ce){L=ce},setClear:function(ce,_e,we,Fe,je){je===!0&&(ce*=Fe,_e*=Fe,we*=Fe),$.set(ce,_e,we,Fe),ue.equals($)===!1&&(i.clearColor(ce,_e,we,Fe),ue.copy($))},reset:function(){L=!1,te=null,ue.set(-1,0,0,0)}}}function s(){let L=!1,$=null,te=null,ue=null;return{setTest:function(ce){ce?se(2929):de(2929)},setMask:function(ce){$!==ce&&!L&&(i.depthMask(ce),$=ce)},setFunc:function(ce){if(te!==ce){if(ce)switch(ce){case Eh:i.depthFunc(512);break;case Th:i.depthFunc(519);break;case Ah:i.depthFunc(513);break;case js:i.depthFunc(515);break;case Ch:i.depthFunc(514);break;case Lh:i.depthFunc(518);break;case Rh:i.depthFunc(516);break;case Ph:i.depthFunc(517);break;default:i.depthFunc(515)}else i.depthFunc(515);te=ce}},setLocked:function(ce){L=ce},setClear:function(ce){ue!==ce&&(i.clearDepth(ce),ue=ce)},reset:function(){L=!1,$=null,te=null,ue=null}}}function a(){let L=!1,$=null,te=null,ue=null,ce=null,_e=null,we=null,Fe=null,je=null;return{setTest:function(Ue){L||(Ue?se(2960):de(2960))},setMask:function(Ue){$!==Ue&&!L&&(i.stencilMask(Ue),$=Ue)},setFunc:function(Ue,It,Dt){(te!==Ue||ue!==It||ce!==Dt)&&(i.stencilFunc(Ue,It,Dt),te=Ue,ue=It,ce=Dt)},setOp:function(Ue,It,Dt){(_e!==Ue||we!==It||Fe!==Dt)&&(i.stencilOp(Ue,It,Dt),_e=Ue,we=It,Fe=Dt)},setLocked:function(Ue){L=Ue},setClear:function(Ue){je!==Ue&&(i.clearStencil(Ue),je=Ue)},reset:function(){L=!1,$=null,te=null,ue=null,ce=null,_e=null,we=null,Fe=null,je=null}}}const o=new r,u=new s,h=new a;let c={},l={},f=null,d=!1,v=null,m=null,_=null,p=null,g=null,y=null,x=null,M=!1,S=null,w=null,C=null,I=null,D=null;const T=i.getParameter(35661);let O=!1,B=0;const F=i.getParameter(7938);F.indexOf("WebGL")!==-1?(B=parseFloat(/^WebGL (\d)/.exec(F)[1]),O=B>=1):F.indexOf("OpenGL ES")!==-1&&(B=parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),O=B>=2);let z=null,N={};const U=i.getParameter(3088),Y=i.getParameter(2978),ee=new We().fromArray(U),k=new We().fromArray(Y);function q(L,$,te){const ue=new Uint8Array(4),ce=i.createTexture();i.bindTexture(L,ce),i.texParameteri(L,10241,9728),i.texParameteri(L,10240,9728);for(let _e=0;_e<te;_e++)i.texImage2D($+_e,0,6408,1,1,0,6408,5121,ue);return ce}const oe={};oe[3553]=q(3553,3553,1),oe[34067]=q(34067,34069,6),o.setClear(0,0,0,1),u.setClear(1),h.setClear(0),se(2929),u.setFunc(js),Pe(!1),Z(Uo),se(2884),fe(vn);function se(L){c[L]!==!0&&(i.enable(L),c[L]=!0)}function de(L){c[L]!==!1&&(i.disable(L),c[L]=!1)}function Se(L,$){return l[L]!==$?(i.bindFramebuffer(L,$),l[L]=$,n&&(L===36009&&(l[36160]=$),L===36160&&(l[36009]=$)),!0):!1}function Q(L){return f!==L?(i.useProgram(L),f=L,!0):!1}const ve={[ti]:32774,[ph]:32778,[mh]:32779};if(n)ve[qo]=32775,ve[Xo]=32776;else{const L=e.get("EXT_blend_minmax");L!==null&&(ve[qo]=L.MIN_EXT,ve[Xo]=L.MAX_EXT)}const xe={[gh]:0,[vh]:1,[_h]:768,[Zo]:770,[Sh]:776,[Mh]:774,[xh]:772,[yh]:769,[Yo]:771,[bh]:775,[wh]:773};function fe(L,$,te,ue,ce,_e,we,Fe){if(L===vn){d===!0&&(de(3042),d=!1);return}if(d===!1&&(se(3042),d=!0),L!==dh){if(L!==v||Fe!==M){if((m!==ti||g!==ti)&&(i.blendEquation(32774),m=ti,g=ti),Fe)switch(L){case ji:i.blendFuncSeparate(1,771,1,771);break;case Go:i.blendFunc(1,1);break;case ko:i.blendFuncSeparate(0,0,769,771);break;case Wo:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",L);break}else switch(L){case ji:i.blendFuncSeparate(770,771,1,771);break;case Go:i.blendFunc(770,1);break;case ko:i.blendFunc(0,769);break;case Wo:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",L);break}_=null,p=null,y=null,x=null,v=L,M=Fe}return}ce=ce||$,_e=_e||te,we=we||ue,($!==m||ce!==g)&&(i.blendEquationSeparate(ve[$],ve[ce]),m=$,g=ce),(te!==_||ue!==p||_e!==y||we!==x)&&(i.blendFuncSeparate(xe[te],xe[ue],xe[_e],xe[we]),_=te,p=ue,y=_e,x=we),v=L,M=null}function pe(L,$){L.side===ei?de(2884):se(2884);let te=L.side===ot;$&&(te=!te),Pe(te),L.blending===ji&&L.transparent===!1?fe(vn):fe(L.blending,L.blendEquation,L.blendSrc,L.blendDst,L.blendEquationAlpha,L.blendSrcAlpha,L.blendDstAlpha,L.premultipliedAlpha),u.setFunc(L.depthFunc),u.setTest(L.depthTest),u.setMask(L.depthWrite),o.setMask(L.colorWrite);const ue=L.stencilWrite;h.setTest(ue),ue&&(h.setMask(L.stencilWriteMask),h.setFunc(L.stencilFunc,L.stencilRef,L.stencilFuncMask),h.setOp(L.stencilFail,L.stencilZFail,L.stencilZPass)),ae(L.polygonOffset,L.polygonOffsetFactor,L.polygonOffsetUnits),L.alphaToCoverage===!0?se(32926):de(32926)}function Pe(L){S!==L&&(L?i.frontFace(2304):i.frontFace(2305),S=L)}function Z(L){L!==uh?(se(2884),L!==w&&(L===Uo?i.cullFace(1029):L===hh?i.cullFace(1028):i.cullFace(1032))):de(2884),w=L}function K(L){L!==C&&(O&&i.lineWidth(L),C=L)}function ae(L,$,te){L?(se(32823),(I!==$||D!==te)&&(i.polygonOffset($,te),I=$,D=te)):de(32823)}function me(L){L?se(3089):de(3089)}function he(L){L===void 0&&(L=33984+T-1),z!==L&&(i.activeTexture(L),z=L)}function Te(L,$){z===null&&he();let te=N[z];te===void 0&&(te={type:void 0,texture:void 0},N[z]=te),(te.type!==L||te.texture!==$)&&(i.bindTexture(L,$||oe[L]),te.type=L,te.texture=$)}function Le(){const L=N[z];L!==void 0&&L.type!==void 0&&(i.bindTexture(L.type,null),L.type=void 0,L.texture=void 0)}function R(){try{i.compressedTexImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function H(){try{i.texSubImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function E(){try{i.texStorage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function b(){try{i.texImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function V(){try{i.texImage3D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function G(L){ee.equals(L)===!1&&(i.scissor(L.x,L.y,L.z,L.w),ee.copy(L))}function ie(L){k.equals(L)===!1&&(i.viewport(L.x,L.y,L.z,L.w),k.copy(L))}function j(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),n===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),c={},z=null,N={},l={},f=null,d=!1,v=null,m=null,_=null,p=null,g=null,y=null,x=null,M=!1,S=null,w=null,C=null,I=null,D=null,ee.set(0,0,i.canvas.width,i.canvas.height),k.set(0,0,i.canvas.width,i.canvas.height),o.reset(),u.reset(),h.reset()}return{buffers:{color:o,depth:u,stencil:h},enable:se,disable:de,bindFramebuffer:Se,useProgram:Q,setBlending:fe,setMaterial:pe,setFlipSided:Pe,setCullFace:Z,setLineWidth:K,setPolygonOffset:ae,setScissorTest:me,activeTexture:he,bindTexture:Te,unbindTexture:Le,compressedTexImage2D:R,texImage2D:b,texImage3D:V,texStorage2D:E,texSubImage2D:H,scissor:G,viewport:ie,reset:j}}function _v(i,e,t,n,r,s,a){const o=r.isWebGL2,u=r.maxTextures,h=r.maxCubemapSize,c=r.maxTextureSize,l=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,v=new WeakMap;let m,_=!1;try{_=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(E,b){return _?new OffscreenCanvas(E,b):Vr("canvas")}function g(E,b,V,G){let ie=1;if((E.width>G||E.height>G)&&(ie=G/Math.max(E.width,E.height)),ie<1||b===!0)if(typeof HTMLImageElement!="undefined"&&E instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&E instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&E instanceof ImageBitmap){const j=b?Gf:Math.floor,L=j(ie*E.width),$=j(ie*E.height);m===void 0&&(m=p(L,$));const te=V?p(L,$):m;return te.width=L,te.height=$,te.getContext("2d").drawImage(E,0,0,L,$),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+E.width+"x"+E.height+") to ("+L+"x"+$+")."),te}else return"data"in E&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+E.width+"x"+E.height+")."),E;return E}function y(E){return dl(E.width)&&dl(E.height)}function x(E){return o?!1:E.wrapS!==Ft||E.wrapT!==Ft||E.minFilter!==ut&&E.minFilter!==Ut}function M(E,b){return E.generateMipmaps&&b&&E.minFilter!==ut&&E.minFilter!==Ut}function S(E){i.generateMipmap(E)}function w(E,b,V){if(o===!1)return b;if(E!==null){if(i[E]!==void 0)return i[E];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+E+"'")}let G=b;return b===6403&&(V===5126&&(G=33326),V===5131&&(G=33325),V===5121&&(G=33321)),b===6407&&(V===5126&&(G=34837),V===5131&&(G=34843),V===5121&&(G=32849)),b===6408&&(V===5126&&(G=34836),V===5131&&(G=34842),V===5121&&(G=32856)),(G===33325||G===33326||G===34842||G===34836)&&e.get("EXT_color_buffer_float"),G}function C(E,b,V){return M(E,V)===!0?Math.log2(Math.max(b.width,b.height))+1:E.mipmaps.length>0?E.mipmaps.length:1}function I(E){return E===ut||E===jo||E===$o?9728:9729}function D(E){const b=E.target;b.removeEventListener("dispose",D),O(b),b.isVideoTexture&&v.delete(b),a.memory.textures--}function T(E){const b=E.target;b.removeEventListener("dispose",T),B(b)}function O(E){const b=n.get(E);b.__webglInit!==void 0&&(i.deleteTexture(b.__webglTexture),n.remove(E))}function B(E){const b=E.texture,V=n.get(E),G=n.get(b);if(!!E){if(G.__webglTexture!==void 0&&(i.deleteTexture(G.__webglTexture),a.memory.textures--),E.depthTexture&&E.depthTexture.dispose(),E.isWebGLCubeRenderTarget)for(let ie=0;ie<6;ie++)i.deleteFramebuffer(V.__webglFramebuffer[ie]),V.__webglDepthbuffer&&i.deleteRenderbuffer(V.__webglDepthbuffer[ie]);else i.deleteFramebuffer(V.__webglFramebuffer),V.__webglDepthbuffer&&i.deleteRenderbuffer(V.__webglDepthbuffer),V.__webglMultisampledFramebuffer&&i.deleteFramebuffer(V.__webglMultisampledFramebuffer),V.__webglColorRenderbuffer&&i.deleteRenderbuffer(V.__webglColorRenderbuffer),V.__webglDepthRenderbuffer&&i.deleteRenderbuffer(V.__webglDepthRenderbuffer);if(E.isWebGLMultipleRenderTargets)for(let ie=0,j=b.length;ie<j;ie++){const L=n.get(b[ie]);L.__webglTexture&&(i.deleteTexture(L.__webglTexture),a.memory.textures--),n.remove(b[ie])}n.remove(b),n.remove(E)}}let F=0;function z(){F=0}function N(){const E=F;return E>=u&&console.warn("THREE.WebGLTextures: Trying to use "+E+" texture units while this GPU supports only "+u),F+=1,E}function U(E,b){const V=n.get(E);if(E.isVideoTexture&&he(E),E.version>0&&V.__version!==E.version){const G=E.image;if(G===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(G.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Se(V,E,b);return}}t.activeTexture(33984+b),t.bindTexture(3553,V.__webglTexture)}function Y(E,b){const V=n.get(E);if(E.version>0&&V.__version!==E.version){Se(V,E,b);return}t.activeTexture(33984+b),t.bindTexture(35866,V.__webglTexture)}function ee(E,b){const V=n.get(E);if(E.version>0&&V.__version!==E.version){Se(V,E,b);return}t.activeTexture(33984+b),t.bindTexture(32879,V.__webglTexture)}function k(E,b){const V=n.get(E);if(E.version>0&&V.__version!==E.version){Q(V,E,b);return}t.activeTexture(33984+b),t.bindTexture(34067,V.__webglTexture)}const q={[ea]:10497,[Ft]:33071,[ta]:33648},oe={[ut]:9728,[jo]:9984,[$o]:9986,[Ut]:9729,[Uh]:9985,[Ir]:9987};function se(E,b,V){if(V?(i.texParameteri(E,10242,q[b.wrapS]),i.texParameteri(E,10243,q[b.wrapT]),(E===32879||E===35866)&&i.texParameteri(E,32882,q[b.wrapR]),i.texParameteri(E,10240,oe[b.magFilter]),i.texParameteri(E,10241,oe[b.minFilter])):(i.texParameteri(E,10242,33071),i.texParameteri(E,10243,33071),(E===32879||E===35866)&&i.texParameteri(E,32882,33071),(b.wrapS!==Ft||b.wrapT!==Ft)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(E,10240,I(b.magFilter)),i.texParameteri(E,10241,I(b.minFilter)),b.minFilter!==ut&&b.minFilter!==Ut&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const G=e.get("EXT_texture_filter_anisotropic");if(b.type===yn&&e.has("OES_texture_float_linear")===!1||o===!1&&b.type===ni&&e.has("OES_texture_half_float_linear")===!1)return;(b.anisotropy>1||n.get(b).__currentAnisotropy)&&(i.texParameterf(E,G.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,r.getMaxAnisotropy())),n.get(b).__currentAnisotropy=b.anisotropy)}}function de(E,b){E.__webglInit===void 0&&(E.__webglInit=!0,b.addEventListener("dispose",D),E.__webglTexture=i.createTexture(),a.memory.textures++)}function Se(E,b,V){let G=3553;b.isDataTexture2DArray&&(G=35866),b.isDataTexture3D&&(G=32879),de(E,b),t.activeTexture(33984+V),t.bindTexture(G,E.__webglTexture),i.pixelStorei(37440,b.flipY),i.pixelStorei(37441,b.premultiplyAlpha),i.pixelStorei(3317,b.unpackAlignment),i.pixelStorei(37443,0);const ie=x(b)&&y(b.image)===!1,j=g(b.image,ie,!1,c),L=y(j)||o,$=s.convert(b.format);let te=s.convert(b.type),ue=w(b.internalFormat,$,te,b.encoding);se(G,b,L);let ce;const _e=b.mipmaps;if(b.isDepthTexture)ue=6402,o?b.type===yn?ue=36012:b.type===Dr?ue=33190:b.type===ii?ue=35056:ue=33189:b.type===yn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),b.format===Wn&&ue===6402&&b.type!==Ki&&b.type!==Dr&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),b.type=Ki,te=s.convert(b.type)),b.format===ri&&ue===6402&&(ue=34041,b.type!==ii&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),b.type=ii,te=s.convert(b.type))),t.texImage2D(3553,0,ue,j.width,j.height,0,$,te,null);else if(b.isDataTexture)if(_e.length>0&&L){for(let we=0,Fe=_e.length;we<Fe;we++)ce=_e[we],t.texImage2D(3553,we,ue,ce.width,ce.height,0,$,te,ce.data);b.generateMipmaps=!1}else t.texImage2D(3553,0,ue,j.width,j.height,0,$,te,j.data);else if(b.isCompressedTexture)for(let we=0,Fe=_e.length;we<Fe;we++)ce=_e[we],b.format!==bt&&b.format!==kn?$!==null?t.compressedTexImage2D(3553,we,ue,ce.width,ce.height,0,ce.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,we,ue,ce.width,ce.height,0,$,te,ce.data);else if(b.isDataTexture2DArray)t.texImage3D(35866,0,ue,j.width,j.height,j.depth,0,$,te,j.data);else if(b.isDataTexture3D)t.texImage3D(32879,0,ue,j.width,j.height,j.depth,0,$,te,j.data);else{const we=C(b,j,L),Fe=o&&b.isVideoTexture!==!0,je=E.__version===void 0;if(_e.length>0&&L){Fe&&je&&t.texStorage2D(3553,we,ue,_e[0].width,_e[0].height);for(let Ue=0,It=_e.length;Ue<It;Ue++)ce=_e[Ue],Fe?t.texSubImage2D(3553,Ue,0,0,$,te,ce):t.texImage2D(3553,Ue,ue,$,te,ce);b.generateMipmaps=!1}else Fe?(je&&t.texStorage2D(3553,we,ue,j.width,j.height),t.texSubImage2D(3553,0,0,0,$,te,j)):t.texImage2D(3553,0,ue,$,te,j)}M(b,L)&&S(G),E.__version=b.version,b.onUpdate&&b.onUpdate(b)}function Q(E,b,V){if(b.image.length!==6)return;de(E,b),t.activeTexture(33984+V),t.bindTexture(34067,E.__webglTexture),i.pixelStorei(37440,b.flipY),i.pixelStorei(37441,b.premultiplyAlpha),i.pixelStorei(3317,b.unpackAlignment),i.pixelStorei(37443,0);const G=b&&(b.isCompressedTexture||b.image[0].isCompressedTexture),ie=b.image[0]&&b.image[0].isDataTexture,j=[];for(let we=0;we<6;we++)!G&&!ie?j[we]=g(b.image[we],!1,!0,h):j[we]=ie?b.image[we].image:b.image[we];const L=j[0],$=y(L)||o,te=s.convert(b.format),ue=s.convert(b.type),ce=w(b.internalFormat,te,ue,b.encoding);se(34067,b,$);let _e;if(G)for(let we=0;we<6;we++){_e=j[we].mipmaps;for(let Fe=0;Fe<_e.length;Fe++){const je=_e[Fe];b.format!==bt&&b.format!==kn?te!==null?t.compressedTexImage2D(34069+we,Fe,ce,je.width,je.height,0,je.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+we,Fe,ce,je.width,je.height,0,te,ue,je.data)}}else{_e=b.mipmaps;for(let we=0;we<6;we++)if(ie){t.texImage2D(34069+we,0,ce,j[we].width,j[we].height,0,te,ue,j[we].data);for(let Fe=0;Fe<_e.length;Fe++){const Ue=_e[Fe].image[we].image;t.texImage2D(34069+we,Fe+1,ce,Ue.width,Ue.height,0,te,ue,Ue.data)}}else{t.texImage2D(34069+we,0,ce,te,ue,j[we]);for(let Fe=0;Fe<_e.length;Fe++){const je=_e[Fe];t.texImage2D(34069+we,Fe+1,ce,te,ue,je.image[we])}}}M(b,$)&&S(34067),E.__version=b.version,b.onUpdate&&b.onUpdate(b)}function ve(E,b,V,G,ie){const j=s.convert(V.format),L=s.convert(V.type),$=w(V.internalFormat,j,L,V.encoding);n.get(b).__hasExternalTextures||(ie===32879||ie===35866?t.texImage3D(ie,0,$,b.width,b.height,b.depth,0,j,L,null):t.texImage2D(ie,0,$,b.width,b.height,0,j,L,null)),t.bindFramebuffer(36160,E),b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,G,ie,n.get(V).__webglTexture,0,me(b)):i.framebufferTexture2D(36160,G,ie,n.get(V).__webglTexture,0),t.bindFramebuffer(36160,null)}function xe(E,b,V){if(i.bindRenderbuffer(36161,E),b.depthBuffer&&!b.stencilBuffer){let G=33189;if(V||b.useRenderToTexture){const ie=b.depthTexture;ie&&ie.isDepthTexture&&(ie.type===yn?G=36012:ie.type===Dr&&(G=33190));const j=me(b);b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,j,G,b.width,b.height):i.renderbufferStorageMultisample(36161,j,G,b.width,b.height)}else i.renderbufferStorage(36161,G,b.width,b.height);i.framebufferRenderbuffer(36160,36096,36161,E)}else if(b.depthBuffer&&b.stencilBuffer){const G=me(b);V&&b.useRenderbuffer?i.renderbufferStorageMultisample(36161,G,35056,b.width,b.height):b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,G,35056,b.width,b.height):i.renderbufferStorage(36161,34041,b.width,b.height),i.framebufferRenderbuffer(36160,33306,36161,E)}else{const G=b.isWebGLMultipleRenderTargets===!0?b.texture[0]:b.texture,ie=s.convert(G.format),j=s.convert(G.type),L=w(G.internalFormat,ie,j,G.encoding),$=me(b);V&&b.useRenderbuffer?i.renderbufferStorageMultisample(36161,$,L,b.width,b.height):b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,$,L,b.width,b.height):i.renderbufferStorage(36161,L,b.width,b.height)}i.bindRenderbuffer(36161,null)}function fe(E,b){if(b&&b.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,E),!(b.depthTexture&&b.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(b.depthTexture).__webglTexture||b.depthTexture.image.width!==b.width||b.depthTexture.image.height!==b.height)&&(b.depthTexture.image.width=b.width,b.depthTexture.image.height=b.height,b.depthTexture.needsUpdate=!0),U(b.depthTexture,0);const G=n.get(b.depthTexture).__webglTexture,ie=me(b);if(b.depthTexture.format===Wn)b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,G,0,ie):i.framebufferTexture2D(36160,36096,3553,G,0);else if(b.depthTexture.format===ri)b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,G,0,ie):i.framebufferTexture2D(36160,33306,3553,G,0);else throw new Error("Unknown depthTexture format")}function pe(E){const b=n.get(E),V=E.isWebGLCubeRenderTarget===!0;if(E.depthTexture&&!b.__autoAllocateDepthBuffer){if(V)throw new Error("target.depthTexture not supported in Cube render targets");fe(b.__webglFramebuffer,E)}else if(V){b.__webglDepthbuffer=[];for(let G=0;G<6;G++)t.bindFramebuffer(36160,b.__webglFramebuffer[G]),b.__webglDepthbuffer[G]=i.createRenderbuffer(),xe(b.__webglDepthbuffer[G],E,!1)}else t.bindFramebuffer(36160,b.__webglFramebuffer),b.__webglDepthbuffer=i.createRenderbuffer(),xe(b.__webglDepthbuffer,E,!1);t.bindFramebuffer(36160,null)}function Pe(E,b,V){const G=n.get(E);b!==void 0&&ve(G.__webglFramebuffer,E,E.texture,36064,3553),V!==void 0&&pe(E)}function Z(E){const b=E.texture,V=n.get(E),G=n.get(b);E.addEventListener("dispose",T),E.isWebGLMultipleRenderTargets!==!0&&(G.__webglTexture===void 0&&(G.__webglTexture=i.createTexture()),G.__version=b.version,a.memory.textures++);const ie=E.isWebGLCubeRenderTarget===!0,j=E.isWebGLMultipleRenderTargets===!0,L=b.isDataTexture3D||b.isDataTexture2DArray,$=y(E)||o;if(o&&b.format===kn&&(b.type===yn||b.type===ni)&&(b.format=bt,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ie){V.__webglFramebuffer=[];for(let te=0;te<6;te++)V.__webglFramebuffer[te]=i.createFramebuffer()}else if(V.__webglFramebuffer=i.createFramebuffer(),j)if(r.drawBuffers){const te=E.texture;for(let ue=0,ce=te.length;ue<ce;ue++){const _e=n.get(te[ue]);_e.__webglTexture===void 0&&(_e.__webglTexture=i.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(E.useRenderbuffer)if(o){V.__webglMultisampledFramebuffer=i.createFramebuffer(),V.__webglColorRenderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(36161,V.__webglColorRenderbuffer);const te=s.convert(b.format),ue=s.convert(b.type),ce=w(b.internalFormat,te,ue,b.encoding),_e=me(E);i.renderbufferStorageMultisample(36161,_e,ce,E.width,E.height),t.bindFramebuffer(36160,V.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064,36161,V.__webglColorRenderbuffer),i.bindRenderbuffer(36161,null),E.depthBuffer&&(V.__webglDepthRenderbuffer=i.createRenderbuffer(),xe(V.__webglDepthRenderbuffer,E,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ie){t.bindTexture(34067,G.__webglTexture),se(34067,b,$);for(let te=0;te<6;te++)ve(V.__webglFramebuffer[te],E,b,36064,34069+te);M(b,$)&&S(34067),t.unbindTexture()}else if(j){const te=E.texture;for(let ue=0,ce=te.length;ue<ce;ue++){const _e=te[ue],we=n.get(_e);t.bindTexture(3553,we.__webglTexture),se(3553,_e,$),ve(V.__webglFramebuffer,E,_e,36064+ue,3553),M(_e,$)&&S(3553)}t.unbindTexture()}else{let te=3553;L&&(o?te=b.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(te,G.__webglTexture),se(te,b,$),ve(V.__webglFramebuffer,E,b,36064,te),M(b,$)&&S(te),t.unbindTexture()}E.depthBuffer&&pe(E)}function K(E){const b=y(E)||o,V=E.isWebGLMultipleRenderTargets===!0?E.texture:[E.texture];for(let G=0,ie=V.length;G<ie;G++){const j=V[G];if(M(j,b)){const L=E.isWebGLCubeRenderTarget?34067:3553,$=n.get(j).__webglTexture;t.bindTexture(L,$),S(L),t.unbindTexture()}}}function ae(E){if(E.useRenderbuffer)if(o){const b=E.width,V=E.height;let G=16384;const ie=[36064],j=E.stencilBuffer?33306:36096;E.depthBuffer&&ie.push(j),E.ignoreDepthForMultisampleCopy||(E.depthBuffer&&(G|=256),E.stencilBuffer&&(G|=1024));const L=n.get(E);t.bindFramebuffer(36008,L.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,L.__webglFramebuffer),E.ignoreDepthForMultisampleCopy&&(i.invalidateFramebuffer(36008,[j]),i.invalidateFramebuffer(36009,[j])),i.blitFramebuffer(0,0,b,V,0,0,b,V,G,9728),i.invalidateFramebuffer(36008,ie),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,L.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function me(E){return o&&(E.useRenderbuffer||E.useRenderToTexture)?Math.min(l,E.samples):0}function he(E){const b=a.render.frame;v.get(E)!==b&&(v.set(E,b),E.update())}let Te=!1,Le=!1;function R(E,b){E&&E.isWebGLRenderTarget&&(Te===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Te=!0),E=E.texture),U(E,b)}function H(E,b){E&&E.isWebGLCubeRenderTarget&&(Le===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Le=!0),E=E.texture),k(E,b)}this.allocateTextureUnit=N,this.resetTextureUnits=z,this.setTexture2D=U,this.setTexture2DArray=Y,this.setTexture3D=ee,this.setTextureCube=k,this.rebindTextures=Pe,this.setupRenderTarget=Z,this.updateRenderTargetMipmap=K,this.updateMultisampleRenderTarget=ae,this.setupDepthRenderbuffer=pe,this.setupFrameBufferTexture=ve,this.safeSetTexture2D=R,this.safeSetTextureCube=H}function yv(i,e,t){const n=t.isWebGL2;function r(s){let a;if(s===_n)return 5121;if(s===kh)return 32819;if(s===Wh)return 32820;if(s===qh)return 33635;if(s===Vh)return 5120;if(s===Hh)return 5122;if(s===Ki)return 5123;if(s===Gh)return 5124;if(s===Dr)return 5125;if(s===yn)return 5126;if(s===ni)return n?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===Xh)return 6406;if(s===kn)return 6407;if(s===bt)return 6408;if(s===Zh)return 6409;if(s===Yh)return 6410;if(s===Wn)return 6402;if(s===ri)return 34041;if(s===jh)return 6403;if(s===$h)return 36244;if(s===Qh)return 33319;if(s===Kh)return 33320;if(s===ef)return 36248;if(s===tf)return 36249;if(s===Qo||s===Ko||s===el||s===tl)if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Qo)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Ko)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===el)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===tl)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===nl||s===il||s===rl||s===sl)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===nl)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===il)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===rl)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===sl)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===nf)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===al||s===ol)&&(a=e.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===al)return a.COMPRESSED_RGB8_ETC2;if(s===ol)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===rf||s===sf||s===af||s===of||s===lf||s===cf||s===uf||s===hf||s===ff||s===df||s===pf||s===mf||s===gf||s===vf||s===yf||s===xf||s===wf||s===Mf||s===bf||s===Sf||s===Ef||s===Tf||s===Af||s===Cf||s===Lf||s===Rf||s===Pf||s===Nf)return a=e.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===_f)return a=e.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===ii)return n?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class pc extends Lt{constructor(e=[]){super();this.cameras=e}}pc.prototype.isArrayCamera=!0;class lr extends He{constructor(){super();this.type="Group"}}lr.prototype.isGroup=!0;const xv={type:"move"};class Xa{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new lr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new lr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new P,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new P),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new lr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new P,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new P),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let r=null,s=null,a=null;const o=this._targetRay,u=this._grip,h=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(r=t.getPose(e.targetRaySpace,n),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(xv))),h&&e.hand){a=!0;for(const m of e.hand.values()){const _=t.getJointPose(m,n);if(h.joints[m.jointName]===void 0){const g=new lr;g.matrixAutoUpdate=!1,g.visible=!1,h.joints[m.jointName]=g,h.add(g)}const p=h.joints[m.jointName];_!==null&&(p.matrix.fromArray(_.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),p.jointRadius=_.radius),p.visible=_!==null}const c=h.joints["index-finger-tip"],l=h.joints["thumb-tip"],f=c.position.distanceTo(l.position),d=.02,v=.005;h.inputState.pinching&&f>d+v?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!h.inputState.pinching&&f<=d-v&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else u!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));return o!==null&&(o.visible=r!==null),u!==null&&(u.visible=s!==null),h!==null&&(h.visible=a!==null),this}}class Za extends mt{constructor(e,t,n,r,s,a,o,u,h,c){if(c=c!==void 0?c:Wn,c!==Wn&&c!==ri)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&c===Wn&&(n=Ki),n===void 0&&c===ri&&(n=ii);super(null,r,s,a,o,u,c,n,h);this.image={width:e,height:t},this.magFilter=o!==void 0?o:ut,this.minFilter=u!==void 0?u:ut,this.flipY=!1,this.generateMipmaps=!1}}Za.prototype.isDepthTexture=!0;class wv extends qn{constructor(e,t){super();const n=this;let r=null,s=1,a=null,o="local-floor";const u=e.extensions.has("WEBGL_multisampled_render_to_texture");let h=null,c=null,l=null,f=null,d=!1,v=null;const m=t.getContextAttributes();let _=null,p=null;const g=[],y=new Map,x=new Lt;x.layers.enable(1),x.viewport=new We;const M=new Lt;M.layers.enable(2),M.viewport=new We;const S=[x,M],w=new pc;w.layers.enable(1),w.layers.enable(2);let C=null,I=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(k){let q=g[k];return q===void 0&&(q=new Xa,g[k]=q),q.getTargetRaySpace()},this.getControllerGrip=function(k){let q=g[k];return q===void 0&&(q=new Xa,g[k]=q),q.getGripSpace()},this.getHand=function(k){let q=g[k];return q===void 0&&(q=new Xa,g[k]=q),q.getHandSpace()};function D(k){const q=y.get(k.inputSource);q&&q.dispatchEvent({type:k.type,data:k.inputSource})}function T(){y.forEach(function(k,q){k.disconnect(q)}),y.clear(),C=null,I=null,e.setRenderTarget(_),f=null,l=null,c=null,r=null,p=null,ee.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(k){s=k,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(k){o=k,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return l!==null?l:f},this.getBinding=function(){return c},this.getFrame=function(){return v},this.getSession=function(){return r},this.setSession=async function(k){if(r=k,r!==null){if(_=e.getRenderTarget(),r.addEventListener("select",D),r.addEventListener("selectstart",D),r.addEventListener("selectend",D),r.addEventListener("squeeze",D),r.addEventListener("squeezestart",D),r.addEventListener("squeezeend",D),r.addEventListener("end",T),r.addEventListener("inputsourceschange",O),m.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const q={antialias:r.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:s};f=new XRWebGLLayer(r,t,q),r.updateRenderState({baseLayer:f}),p=new Vt(f.framebufferWidth,f.framebufferHeight)}else{d=m.antialias;let q=null,oe=null,se=null;m.depth&&(se=m.stencil?35056:33189,q=m.stencil?ri:Wn,oe=m.stencil?ii:Ki);const de={colorFormat:m.alpha||d?32856:32849,depthFormat:se,scaleFactor:s};c=new XRWebGLBinding(r,t),l=c.createProjectionLayer(de),r.updateRenderState({layers:[l]}),d?p=new ha(l.textureWidth,l.textureHeight,{format:bt,type:_n,depthTexture:new Za(l.textureWidth,l.textureHeight,oe,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:m.stencil,ignoreDepth:l.ignoreDepthValues,useRenderToTexture:u}):p=new Vt(l.textureWidth,l.textureHeight,{format:m.alpha?bt:kn,type:_n,depthTexture:new Za(l.textureWidth,l.textureHeight,oe,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:m.stencil,ignoreDepth:l.ignoreDepthValues})}this.setFoveation(0),a=await r.requestReferenceSpace(o),ee.setContext(r),ee.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function O(k){const q=r.inputSources;for(let oe=0;oe<g.length;oe++)y.set(q[oe],g[oe]);for(let oe=0;oe<k.removed.length;oe++){const se=k.removed[oe],de=y.get(se);de&&(de.dispatchEvent({type:"disconnected",data:se}),y.delete(se))}for(let oe=0;oe<k.added.length;oe++){const se=k.added[oe],de=y.get(se);de&&de.dispatchEvent({type:"connected",data:se})}}const B=new P,F=new P;function z(k,q,oe){B.setFromMatrixPosition(q.matrixWorld),F.setFromMatrixPosition(oe.matrixWorld);const se=B.distanceTo(F),de=q.projectionMatrix.elements,Se=oe.projectionMatrix.elements,Q=de[14]/(de[10]-1),ve=de[14]/(de[10]+1),xe=(de[9]+1)/de[5],fe=(de[9]-1)/de[5],pe=(de[8]-1)/de[0],Pe=(Se[8]+1)/Se[0],Z=Q*pe,K=Q*Pe,ae=se/(-pe+Pe),me=ae*-pe;q.matrixWorld.decompose(k.position,k.quaternion,k.scale),k.translateX(me),k.translateZ(ae),k.matrixWorld.compose(k.position,k.quaternion,k.scale),k.matrixWorldInverse.copy(k.matrixWorld).invert();const he=Q+ae,Te=ve+ae,Le=Z-me,R=K+(se-me),H=xe*ve/Te*he,E=fe*ve/Te*he;k.projectionMatrix.makePerspective(Le,R,H,E,he,Te)}function N(k,q){q===null?k.matrixWorld.copy(k.matrix):k.matrixWorld.multiplyMatrices(q.matrixWorld,k.matrix),k.matrixWorldInverse.copy(k.matrixWorld).invert()}this.updateCamera=function(k){if(r===null)return;w.near=M.near=x.near=k.near,w.far=M.far=x.far=k.far,(C!==w.near||I!==w.far)&&(r.updateRenderState({depthNear:w.near,depthFar:w.far}),C=w.near,I=w.far);const q=k.parent,oe=w.cameras;N(w,q);for(let de=0;de<oe.length;de++)N(oe[de],q);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),k.position.copy(w.position),k.quaternion.copy(w.quaternion),k.scale.copy(w.scale),k.matrix.copy(w.matrix),k.matrixWorld.copy(w.matrixWorld);const se=k.children;for(let de=0,Se=se.length;de<Se;de++)se[de].updateMatrixWorld(!0);oe.length===2?z(w,x,M):w.projectionMatrix.copy(x.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){if(l!==null)return l.fixedFoveation;if(f!==null)return f.fixedFoveation},this.setFoveation=function(k){l!==null&&(l.fixedFoveation=k),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=k)};let U=null;function Y(k,q){if(h=q.getViewerPose(a),v=q,h!==null){const se=h.views;f!==null&&(e.setRenderTargetFramebuffer(p,f.framebuffer),e.setRenderTarget(p));let de=!1;se.length!==w.cameras.length&&(w.cameras.length=0,de=!0);for(let Se=0;Se<se.length;Se++){const Q=se[Se];let ve=null;if(f!==null)ve=f.getViewport(Q);else{const fe=c.getViewSubImage(l,Q);ve=fe.viewport,Se===0&&(e.setRenderTargetTextures(p,fe.colorTexture,l.ignoreDepthValues?void 0:fe.depthStencilTexture),e.setRenderTarget(p))}const xe=S[Se];xe.matrix.fromArray(Q.transform.matrix),xe.projectionMatrix.fromArray(Q.projectionMatrix),xe.viewport.set(ve.x,ve.y,ve.width,ve.height),Se===0&&w.matrix.copy(xe.matrix),de===!0&&w.cameras.push(xe)}}const oe=r.inputSources;for(let se=0;se<g.length;se++){const de=g[se],Se=oe[se];de.update(Se,q,a)}U&&U(k,q),v=null}const ee=new Pl;ee.setAnimationLoop(Y),this.setAnimationLoop=function(k){U=k},this.dispose=function(){}}}function Mv(i){function e(p,g){p.fogColor.value.copy(g.color),g.isFog?(p.fogNear.value=g.near,p.fogFar.value=g.far):g.isFogExp2&&(p.fogDensity.value=g.density)}function t(p,g,y,x,M){g.isMeshBasicMaterial?n(p,g):g.isMeshLambertMaterial?(n(p,g),u(p,g)):g.isMeshToonMaterial?(n(p,g),c(p,g)):g.isMeshPhongMaterial?(n(p,g),h(p,g)):g.isMeshStandardMaterial?(n(p,g),g.isMeshPhysicalMaterial?f(p,g,M):l(p,g)):g.isMeshMatcapMaterial?(n(p,g),d(p,g)):g.isMeshDepthMaterial?(n(p,g),v(p,g)):g.isMeshDistanceMaterial?(n(p,g),m(p,g)):g.isMeshNormalMaterial?(n(p,g),_(p,g)):g.isLineBasicMaterial?(r(p,g),g.isLineDashedMaterial&&s(p,g)):g.isPointsMaterial?a(p,g,y,x):g.isSpriteMaterial?o(p,g):g.isShadowMaterial?(p.color.value.copy(g.color),p.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function n(p,g){p.opacity.value=g.opacity,g.color&&p.diffuse.value.copy(g.color),g.emissive&&p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.specularMap&&(p.specularMap.value=g.specularMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);const y=i.get(g).envMap;y&&(p.envMap.value=y,p.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=g.reflectivity,p.ior.value=g.ior,p.refractionRatio.value=g.refractionRatio),g.lightMap&&(p.lightMap.value=g.lightMap,p.lightMapIntensity.value=g.lightMapIntensity),g.aoMap&&(p.aoMap.value=g.aoMap,p.aoMapIntensity.value=g.aoMapIntensity);let x;g.map?x=g.map:g.specularMap?x=g.specularMap:g.displacementMap?x=g.displacementMap:g.normalMap?x=g.normalMap:g.bumpMap?x=g.bumpMap:g.roughnessMap?x=g.roughnessMap:g.metalnessMap?x=g.metalnessMap:g.alphaMap?x=g.alphaMap:g.emissiveMap?x=g.emissiveMap:g.clearcoatMap?x=g.clearcoatMap:g.clearcoatNormalMap?x=g.clearcoatNormalMap:g.clearcoatRoughnessMap?x=g.clearcoatRoughnessMap:g.specularIntensityMap?x=g.specularIntensityMap:g.specularColorMap?x=g.specularColorMap:g.transmissionMap?x=g.transmissionMap:g.thicknessMap?x=g.thicknessMap:g.sheenColorMap?x=g.sheenColorMap:g.sheenRoughnessMap&&(x=g.sheenRoughnessMap),x!==void 0&&(x.isWebGLRenderTarget&&(x=x.texture),x.matrixAutoUpdate===!0&&x.updateMatrix(),p.uvTransform.value.copy(x.matrix));let M;g.aoMap?M=g.aoMap:g.lightMap&&(M=g.lightMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uv2Transform.value.copy(M.matrix))}function r(p,g){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity}function s(p,g){p.dashSize.value=g.dashSize,p.totalSize.value=g.dashSize+g.gapSize,p.scale.value=g.scale}function a(p,g,y,x){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity,p.size.value=g.size*y,p.scale.value=x*.5,g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);let M;g.map?M=g.map:g.alphaMap&&(M=g.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uvTransform.value.copy(M.matrix))}function o(p,g){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity,p.rotation.value=g.rotation,g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);let y;g.map?y=g.map:g.alphaMap&&(y=g.alphaMap),y!==void 0&&(y.matrixAutoUpdate===!0&&y.updateMatrix(),p.uvTransform.value.copy(y.matrix))}function u(p,g){g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap)}function h(p,g){p.specular.value.copy(g.specular),p.shininess.value=Math.max(g.shininess,1e-4),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===ot&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===ot&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function c(p,g){g.gradientMap&&(p.gradientMap.value=g.gradientMap),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===ot&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===ot&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function l(p,g){p.roughness.value=g.roughness,p.metalness.value=g.metalness,g.roughnessMap&&(p.roughnessMap.value=g.roughnessMap),g.metalnessMap&&(p.metalnessMap.value=g.metalnessMap),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===ot&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===ot&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias),i.get(g).envMap&&(p.envMapIntensity.value=g.envMapIntensity)}function f(p,g,y){l(p,g),p.ior.value=g.ior,g.sheen>0&&(p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),p.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(p.sheenColorMap.value=g.sheenColorMap),g.sheenRoughnessMap&&(p.sheenRoughnessMap.value=g.sheenRoughnessMap)),g.clearcoat>0&&(p.clearcoat.value=g.clearcoat,p.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(p.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),p.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===ot&&p.clearcoatNormalScale.value.negate())),g.transmission>0&&(p.transmission.value=g.transmission,p.transmissionSamplerMap.value=y.texture,p.transmissionSamplerSize.value.set(y.width,y.height),g.transmissionMap&&(p.transmissionMap.value=g.transmissionMap),p.thickness.value=g.thickness,g.thicknessMap&&(p.thicknessMap.value=g.thicknessMap),p.attenuationDistance.value=g.attenuationDistance,p.attenuationColor.value.copy(g.attenuationColor)),p.specularIntensity.value=g.specularIntensity,p.specularColor.value.copy(g.specularColor),g.specularIntensityMap&&(p.specularIntensityMap.value=g.specularIntensityMap),g.specularColorMap&&(p.specularColorMap.value=g.specularColorMap)}function d(p,g){g.matcap&&(p.matcap.value=g.matcap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===ot&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===ot&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function v(p,g){g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function m(p,g){g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias),p.referencePosition.value.copy(g.referencePosition),p.nearDistance.value=g.nearDistance,p.farDistance.value=g.farDistance}function _(p,g){g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===ot&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===ot&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function bv(){const i=Vr("canvas");return i.style.display="block",i}function ke(i={}){const e=i.canvas!==void 0?i.canvas:bv(),t=i.context!==void 0?i.context:null,n=i.alpha!==void 0?i.alpha:!1,r=i.depth!==void 0?i.depth:!0,s=i.stencil!==void 0?i.stencil:!0,a=i.antialias!==void 0?i.antialias:!1,o=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,u=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,h=i.powerPreference!==void 0?i.powerPreference:"default",c=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let l=null,f=null;const d=[],v=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Tt,this.physicallyCorrectLights=!1,this.toneMapping=Gn,this.toneMappingExposure=1;const m=this;let _=!1,p=0,g=0,y=null,x=-1,M=null;const S=new We,w=new We;let C=null,I=e.width,D=e.height,T=1,O=null,B=null;const F=new We(0,0,I,D),z=new We(0,0,I,D);let N=!1;const U=[],Y=new ss;let ee=!1,k=!1,q=null;const oe=new Re,se=new P,de={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Se(){return y===null?T:1}let Q=t;function ve(A,W){for(let J=0;J<A.length;J++){const X=A[J],ne=e.getContext(X,W);if(ne!==null)return ne}return null}try{const A={alpha:n,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:u,powerPreference:h,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Js}`),e.addEventListener("webglcontextlost",we,!1),e.addEventListener("webglcontextrestored",Fe,!1),Q===null){const W=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&W.shift(),Q=ve(W,A),Q===null)throw ve(W)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Q.getShaderPrecisionFormat===void 0&&(Q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(A){throw console.error("THREE.WebGLRenderer: "+A.message),A}let xe,fe,pe,Pe,Z,K,ae,me,he,Te,Le,R,H,E,b,V,G,ie,j,L,$,te,ue;function ce(){xe=new Xm(Q),fe=new Om(Q,xe,i),xe.init(fe),te=new yv(Q,xe,fe),pe=new vv(Q,xe,fe),U[0]=1029,Pe=new Jm(Q),Z=new av,K=new _v(Q,xe,pe,Z,fe,te,Pe),ae=new Vm(m),me=new qm(m),he=new ld(Q,fe),ue=new zm(Q,xe,he,fe),Te=new Zm(Q,he,Pe,ue),Le=new Km(Q,Te,he,Pe),j=new Qm(Q,fe,K),V=new Um(Z),R=new sv(m,ae,me,xe,fe,ue,V),H=new Mv(Z),E=new lv(Z),b=new pv(xe,fe),ie=new Fm(m,ae,pe,Le,o),G=new dc(m,Le,fe),L=new Bm(Q,xe,Pe,fe),$=new Ym(Q,xe,Pe,fe),Pe.programs=R.programs,m.capabilities=fe,m.extensions=xe,m.properties=Z,m.renderLists=E,m.shadowMap=G,m.state=pe,m.info=Pe}ce();const _e=new wv(m,Q);this.xr=_e,this.getContext=function(){return Q},this.getContextAttributes=function(){return Q.getContextAttributes()},this.forceContextLoss=function(){const A=xe.get("WEBGL_lose_context");A&&A.loseContext()},this.forceContextRestore=function(){const A=xe.get("WEBGL_lose_context");A&&A.restoreContext()},this.getPixelRatio=function(){return T},this.setPixelRatio=function(A){A!==void 0&&(T=A,this.setSize(I,D,!1))},this.getSize=function(A){return A.set(I,D)},this.setSize=function(A,W,J){if(_e.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}I=A,D=W,e.width=Math.floor(A*T),e.height=Math.floor(W*T),J!==!1&&(e.style.width=A+"px",e.style.height=W+"px"),this.setViewport(0,0,A,W)},this.getDrawingBufferSize=function(A){return A.set(I*T,D*T).floor()},this.setDrawingBufferSize=function(A,W,J){I=A,D=W,T=J,e.width=Math.floor(A*J),e.height=Math.floor(W*J),this.setViewport(0,0,A,W)},this.getCurrentViewport=function(A){return A.copy(S)},this.getViewport=function(A){return A.copy(F)},this.setViewport=function(A,W,J,X){A.isVector4?F.set(A.x,A.y,A.z,A.w):F.set(A,W,J,X),pe.viewport(S.copy(F).multiplyScalar(T).floor())},this.getScissor=function(A){return A.copy(z)},this.setScissor=function(A,W,J,X){A.isVector4?z.set(A.x,A.y,A.z,A.w):z.set(A,W,J,X),pe.scissor(w.copy(z).multiplyScalar(T).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(A){pe.setScissorTest(N=A)},this.setOpaqueSort=function(A){O=A},this.setTransparentSort=function(A){B=A},this.getClearColor=function(A){return A.copy(ie.getClearColor())},this.setClearColor=function(){ie.setClearColor.apply(ie,arguments)},this.getClearAlpha=function(){return ie.getClearAlpha()},this.setClearAlpha=function(){ie.setClearAlpha.apply(ie,arguments)},this.clear=function(A,W,J){let X=0;(A===void 0||A)&&(X|=16384),(W===void 0||W)&&(X|=256),(J===void 0||J)&&(X|=1024),Q.clear(X)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",we,!1),e.removeEventListener("webglcontextrestored",Fe,!1),E.dispose(),b.dispose(),Z.dispose(),ae.dispose(),me.dispose(),Le.dispose(),ue.dispose(),_e.dispose(),_e.removeEventListener("sessionstart",Ar),_e.removeEventListener("sessionend",Cr),q&&(q.dispose(),q=null),sn.stop()};function we(A){A.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function Fe(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const A=Pe.autoReset,W=G.enabled,J=G.autoUpdate,X=G.needsUpdate,ne=G.type;ce(),Pe.autoReset=A,G.enabled=W,G.autoUpdate=J,G.needsUpdate=X,G.type=ne}function je(A){const W=A.target;W.removeEventListener("dispose",je),Ue(W)}function Ue(A){It(A),Z.remove(A)}function It(A){const W=Z.get(A).programs;W!==void 0&&W.forEach(function(J){R.releaseProgram(J)})}this.renderBufferDirect=function(A,W,J,X,ne,Ne){W===null&&(W=de);const Ae=ne.isMesh&&ne.matrixWorld.determinant()<0,ye=Xs(A,W,J,X,ne);pe.setMaterial(X,Ae);let Me=J.index;const De=J.attributes.position;if(Me===null){if(De===void 0||De.count===0)return}else if(Me.count===0)return;let ze=1;X.wireframe===!0&&(Me=Te.getWireframeAttribute(J),ze=2),ue.setup(ne,X,ye,J,Me);let Oe,et=L;Me!==null&&(Oe=he.get(Me),et=$,et.setIndex(Oe));const On=Me!==null?Me.count:De.count,Ve=J.drawRange.start*ze,Xi=J.drawRange.count*ze,Ze=Ne!==null?Ne.start*ze:0,Un=Ne!==null?Ne.count*ze:1/0,Vn=Math.max(Ve,Ze),Hn=Math.min(On,Ve+Xi,Ze+Un)-1,gn=Math.max(0,Hn-Vn+1);if(gn!==0){if(ne.isMesh)X.wireframe===!0?(pe.setLineWidth(X.wireframeLinewidth*Se()),et.setMode(1)):et.setMode(4);else if(ne.isLine){let tt=X.linewidth;tt===void 0&&(tt=1),pe.setLineWidth(tt*Se()),ne.isLineSegments?et.setMode(1):ne.isLineLoop?et.setMode(2):et.setMode(3)}else ne.isPoints?et.setMode(0):ne.isSprite&&et.setMode(4);if(ne.isInstancedMesh)et.renderInstances(Vn,gn,ne.count);else if(J.isInstancedBufferGeometry){const tt=Math.min(J.instanceCount,J._maxInstanceCount);et.renderInstances(Vn,gn,tt)}else et.render(Vn,gn)}},this.compile=function(A,W){f=b.get(A),f.init(),v.push(f),A.traverseVisible(function(J){J.isLight&&J.layers.test(W.layers)&&(f.pushLight(J),J.castShadow&&f.pushShadow(J))}),f.setupLights(m.physicallyCorrectLights),A.traverse(function(J){const X=J.material;if(X)if(Array.isArray(X))for(let ne=0;ne<X.length;ne++){const Ne=X[ne];qi(Ne,A,J)}else qi(X,A,J)}),v.pop(),f=null};let Dt=null;function ks(A){Dt&&Dt(A)}function Ar(){sn.stop()}function Cr(){sn.start()}const sn=new Pl;sn.setAnimationLoop(ks),typeof window!="undefined"&&sn.setContext(window),this.setAnimationLoop=function(A){Dt=A,_e.setAnimationLoop(A),A===null?sn.stop():sn.start()},_e.addEventListener("sessionstart",Ar),_e.addEventListener("sessionend",Cr),this.render=function(A,W){if(W!==void 0&&W.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;A.autoUpdate===!0&&A.updateMatrixWorld(),W.parent===null&&W.updateMatrixWorld(),_e.enabled===!0&&_e.isPresenting===!0&&(_e.cameraAutoUpdate===!0&&_e.updateCamera(W),W=_e.getCamera()),A.isScene===!0&&A.onBeforeRender(m,A,W,y),f=b.get(A,v.length),f.init(),v.push(f),oe.multiplyMatrices(W.projectionMatrix,W.matrixWorldInverse),Y.setFromProjectionMatrix(oe),k=this.localClippingEnabled,ee=V.init(this.clippingPlanes,k,W),l=E.get(A,d.length),l.init(),d.push(l),$t(A,W,0,m.sortObjects),l.finish(),m.sortObjects===!0&&l.sort(O,B),ee===!0&&V.beginShadows();const J=f.state.shadowsArray;if(G.render(J,A,W),ee===!0&&V.endShadows(),this.info.autoReset===!0&&this.info.reset(),ie.render(l,A),f.setupLights(m.physicallyCorrectLights),W.isArrayCamera){const X=W.cameras;for(let ne=0,Ne=X.length;ne<Ne;ne++){const Ae=X[ne];Lr(l,A,Ae,Ae.viewport)}}else Lr(l,A,W);y!==null&&(K.updateMultisampleRenderTarget(y),K.updateRenderTargetMipmap(y)),A.isScene===!0&&A.onAfterRender(m,A,W),pe.buffers.depth.setTest(!0),pe.buffers.depth.setMask(!0),pe.buffers.color.setMask(!0),pe.setPolygonOffset(!1),ue.resetDefaultState(),x=-1,M=null,v.pop(),v.length>0?f=v[v.length-1]:f=null,d.pop(),d.length>0?l=d[d.length-1]:l=null};function $t(A,W,J,X){if(A.visible===!1)return;if(A.layers.test(W.layers)){if(A.isGroup)J=A.renderOrder;else if(A.isLOD)A.autoUpdate===!0&&A.update(W);else if(A.isLight)f.pushLight(A),A.castShadow&&f.pushShadow(A);else if(A.isSprite){if(!A.frustumCulled||Y.intersectsSprite(A)){X&&se.setFromMatrixPosition(A.matrixWorld).applyMatrix4(oe);const Ae=Le.update(A),ye=A.material;ye.visible&&l.push(A,Ae,ye,J,se.z,null)}}else if((A.isMesh||A.isLine||A.isPoints)&&(A.isSkinnedMesh&&A.skeleton.frame!==Pe.render.frame&&(A.skeleton.update(),A.skeleton.frame=Pe.render.frame),!A.frustumCulled||Y.intersectsObject(A))){X&&se.setFromMatrixPosition(A.matrixWorld).applyMatrix4(oe);const Ae=Le.update(A),ye=A.material;if(Array.isArray(ye)){const Me=Ae.groups;for(let De=0,ze=Me.length;De<ze;De++){const Oe=Me[De],et=ye[Oe.materialIndex];et&&et.visible&&l.push(A,Ae,et,J,se.z,Oe)}}else ye.visible&&l.push(A,Ae,ye,J,se.z,null)}}const Ne=A.children;for(let Ae=0,ye=Ne.length;Ae<ye;Ae++)$t(Ne[Ae],W,J,X)}function Lr(A,W,J,X){const ne=A.opaque,Ne=A.transmissive,Ae=A.transparent;f.setupLightsView(J),Ne.length>0&&Ws(ne,W,J),X&&pe.viewport(S.copy(X)),ne.length>0&&Kn(ne,W,J),Ne.length>0&&Kn(Ne,W,J),Ae.length>0&&Kn(Ae,W,J)}function Ws(A,W,J){if(q===null){const Ae=a===!0&&fe.isWebGL2===!0?ha:Vt;q=new Ae(1024,1024,{generateMipmaps:!0,type:te.convert(ni)!==null?ni:_n,minFilter:Ir,magFilter:ut,wrapS:Ft,wrapT:Ft,useRenderToTexture:xe.has("WEBGL_multisampled_render_to_texture")})}const X=m.getRenderTarget();m.setRenderTarget(q),m.clear();const ne=m.toneMapping;m.toneMapping=Gn,Kn(A,W,J),m.toneMapping=ne,K.updateMultisampleRenderTarget(q),K.updateRenderTargetMipmap(q),m.setRenderTarget(X)}function Kn(A,W,J){const X=W.isScene===!0?W.overrideMaterial:null;for(let ne=0,Ne=A.length;ne<Ne;ne++){const Ae=A[ne],ye=Ae.object,Me=Ae.geometry,De=X===null?Ae.material:X,ze=Ae.group;ye.layers.test(J.layers)&&qs(ye,W,J,Me,De,ze)}}function qs(A,W,J,X,ne,Ne){A.onBeforeRender(m,W,J,X,ne,Ne),A.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse,A.matrixWorld),A.normalMatrix.getNormalMatrix(A.modelViewMatrix),ne.onBeforeRender(m,W,J,X,A,Ne),ne.transparent===!0&&ne.side===ei?(ne.side=ot,ne.needsUpdate=!0,m.renderBufferDirect(J,W,X,ne,A,Ne),ne.side=Ji,ne.needsUpdate=!0,m.renderBufferDirect(J,W,X,ne,A,Ne),ne.side=ei):m.renderBufferDirect(J,W,X,ne,A,Ne),A.onAfterRender(m,W,J,X,ne,Ne)}function qi(A,W,J){W.isScene!==!0&&(W=de);const X=Z.get(A),ne=f.state.lights,Ne=f.state.shadowsArray,Ae=ne.state.version,ye=R.getParameters(A,ne.state,Ne,W,J),Me=R.getProgramCacheKey(ye);let De=X.programs;X.environment=A.isMeshStandardMaterial?W.environment:null,X.fog=W.fog,X.envMap=(A.isMeshStandardMaterial?me:ae).get(A.envMap||X.environment),De===void 0&&(A.addEventListener("dispose",je),De=new Map,X.programs=De);let ze=De.get(Me);if(ze!==void 0){if(X.currentProgram===ze&&X.lightsStateVersion===Ae)return Rr(A,ye),ze}else ye.uniforms=R.getUniforms(A),A.onBuild(J,ye,m),A.onBeforeCompile(ye,m),ze=R.acquireProgram(ye,Me),De.set(Me,ze),X.uniforms=ye.uniforms;const Oe=X.uniforms;(!A.isShaderMaterial&&!A.isRawShaderMaterial||A.clipping===!0)&&(Oe.clippingPlanes=V.uniform),Rr(A,ye),X.needsLights=Ys(A),X.lightsStateVersion=Ae,X.needsLights&&(Oe.ambientLightColor.value=ne.state.ambient,Oe.lightProbe.value=ne.state.probe,Oe.directionalLights.value=ne.state.directional,Oe.directionalLightShadows.value=ne.state.directionalShadow,Oe.spotLights.value=ne.state.spot,Oe.spotLightShadows.value=ne.state.spotShadow,Oe.rectAreaLights.value=ne.state.rectArea,Oe.ltc_1.value=ne.state.rectAreaLTC1,Oe.ltc_2.value=ne.state.rectAreaLTC2,Oe.pointLights.value=ne.state.point,Oe.pointLightShadows.value=ne.state.pointShadow,Oe.hemisphereLights.value=ne.state.hemi,Oe.directionalShadowMap.value=ne.state.directionalShadowMap,Oe.directionalShadowMatrix.value=ne.state.directionalShadowMatrix,Oe.spotShadowMap.value=ne.state.spotShadowMap,Oe.spotShadowMatrix.value=ne.state.spotShadowMatrix,Oe.pointShadowMap.value=ne.state.pointShadowMap,Oe.pointShadowMatrix.value=ne.state.pointShadowMatrix);const et=ze.getUniforms(),On=Cn.seqWithValue(et.seq,Oe);return X.currentProgram=ze,X.uniformsList=On,ze}function Rr(A,W){const J=Z.get(A);J.outputEncoding=W.outputEncoding,J.instancing=W.instancing,J.skinning=W.skinning,J.morphTargets=W.morphTargets,J.morphNormals=W.morphNormals,J.morphTargetsCount=W.morphTargetsCount,J.numClippingPlanes=W.numClippingPlanes,J.numIntersection=W.numClipIntersection,J.vertexAlphas=W.vertexAlphas,J.vertexTangents=W.vertexTangents}function Xs(A,W,J,X,ne){W.isScene!==!0&&(W=de),K.resetTextureUnits();const Ne=W.fog,Ae=X.isMeshStandardMaterial?W.environment:null,ye=y===null?m.outputEncoding:y.texture.encoding,Me=(X.isMeshStandardMaterial?me:ae).get(X.envMap||Ae),De=X.vertexColors===!0&&!!J.attributes.color&&J.attributes.color.itemSize===4,ze=!!X.normalMap&&!!J.attributes.tangent,Oe=!!J.morphAttributes.position,et=!!J.morphAttributes.normal,On=J.morphAttributes.position?J.morphAttributes.position.length:0,Ve=Z.get(X),Xi=f.state.lights;if(ee===!0&&(k===!0||A!==M)){const kt=A===M&&X.id===x;V.setState(X,A,kt)}let Ze=!1;X.version===Ve.__version?(Ve.needsLights&&Ve.lightsStateVersion!==Xi.state.version||Ve.outputEncoding!==ye||ne.isInstancedMesh&&Ve.instancing===!1||!ne.isInstancedMesh&&Ve.instancing===!0||ne.isSkinnedMesh&&Ve.skinning===!1||!ne.isSkinnedMesh&&Ve.skinning===!0||Ve.envMap!==Me||X.fog&&Ve.fog!==Ne||Ve.numClippingPlanes!==void 0&&(Ve.numClippingPlanes!==V.numPlanes||Ve.numIntersection!==V.numIntersection)||Ve.vertexAlphas!==De||Ve.vertexTangents!==ze||Ve.morphTargets!==Oe||Ve.morphNormals!==et||fe.isWebGL2===!0&&Ve.morphTargetsCount!==On)&&(Ze=!0):(Ze=!0,Ve.__version=X.version);let Un=Ve.currentProgram;Ze===!0&&(Un=qi(X,W,ne));let Vn=!1,Hn=!1,gn=!1;const tt=Un.getUniforms(),Zi=Ve.uniforms;if(pe.useProgram(Un.program)&&(Vn=!0,Hn=!0,gn=!0),X.id!==x&&(x=X.id,Hn=!0),Vn||M!==A){if(tt.setValue(Q,"projectionMatrix",A.projectionMatrix),fe.logarithmicDepthBuffer&&tt.setValue(Q,"logDepthBufFC",2/(Math.log(A.far+1)/Math.LN2)),M!==A&&(M=A,Hn=!0,gn=!0),X.isShaderMaterial||X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshStandardMaterial||X.envMap){const kt=tt.map.cameraPosition;kt!==void 0&&kt.setValue(Q,se.setFromMatrixPosition(A.matrixWorld))}(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial)&&tt.setValue(Q,"isOrthographic",A.isOrthographicCamera===!0),(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial||X.isShadowMaterial||ne.isSkinnedMesh)&&tt.setValue(Q,"viewMatrix",A.matrixWorldInverse)}if(ne.isSkinnedMesh){tt.setOptional(Q,ne,"bindMatrix"),tt.setOptional(Q,ne,"bindMatrixInverse");const kt=ne.skeleton;kt&&(fe.floatVertexTextures?(kt.boneTexture===null&&kt.computeBoneTexture(),tt.setValue(Q,"boneTexture",kt.boneTexture,K),tt.setValue(Q,"boneTextureSize",kt.boneTextureSize)):tt.setOptional(Q,kt,"boneMatrices"))}return!!J&&(J.morphAttributes.position!==void 0||J.morphAttributes.normal!==void 0)&&j.update(ne,J,X,Un),(Hn||Ve.receiveShadow!==ne.receiveShadow)&&(Ve.receiveShadow=ne.receiveShadow,tt.setValue(Q,"receiveShadow",ne.receiveShadow)),Hn&&(tt.setValue(Q,"toneMappingExposure",m.toneMappingExposure),Ve.needsLights&&Zs(Zi,gn),Ne&&X.fog&&H.refreshFogUniforms(Zi,Ne),H.refreshMaterialUniforms(Zi,X,T,D,q),Cn.upload(Q,Ve.uniformsList,Zi,K)),X.isShaderMaterial&&X.uniformsNeedUpdate===!0&&(Cn.upload(Q,Ve.uniformsList,Zi,K),X.uniformsNeedUpdate=!1),X.isSpriteMaterial&&tt.setValue(Q,"center",ne.center),tt.setValue(Q,"modelViewMatrix",ne.modelViewMatrix),tt.setValue(Q,"normalMatrix",ne.normalMatrix),tt.setValue(Q,"modelMatrix",ne.matrixWorld),Un}function Zs(A,W){A.ambientLightColor.needsUpdate=W,A.lightProbe.needsUpdate=W,A.directionalLights.needsUpdate=W,A.directionalLightShadows.needsUpdate=W,A.pointLights.needsUpdate=W,A.pointLightShadows.needsUpdate=W,A.spotLights.needsUpdate=W,A.spotLightShadows.needsUpdate=W,A.rectAreaLights.needsUpdate=W,A.hemisphereLights.needsUpdate=W}function Ys(A){return A.isMeshLambertMaterial||A.isMeshToonMaterial||A.isMeshPhongMaterial||A.isMeshStandardMaterial||A.isShadowMaterial||A.isShaderMaterial&&A.lights===!0}this.getActiveCubeFace=function(){return p},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(A,W,J){Z.get(A.texture).__webglTexture=W,Z.get(A.depthTexture).__webglTexture=J;const X=Z.get(A);X.__hasExternalTextures=!0,X.__hasExternalTextures&&(X.__autoAllocateDepthBuffer=J===void 0,X.__autoAllocateDepthBuffer||A.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),A.useRenderToTexture=!1,A.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(A,W){const J=Z.get(A);J.__webglFramebuffer=W,J.__useDefaultFramebuffer=W===void 0},this.setRenderTarget=function(A,W=0,J=0){y=A,p=W,g=J;let X=!0;if(A){const Me=Z.get(A);Me.__useDefaultFramebuffer!==void 0?(pe.bindFramebuffer(36160,null),X=!1):Me.__webglFramebuffer===void 0?K.setupRenderTarget(A):Me.__hasExternalTextures&&K.rebindTextures(A,Z.get(A.texture).__webglTexture,Z.get(A.depthTexture).__webglTexture)}let ne=null,Ne=!1,Ae=!1;if(A){const Me=A.texture;(Me.isDataTexture3D||Me.isDataTexture2DArray)&&(Ae=!0);const De=Z.get(A).__webglFramebuffer;A.isWebGLCubeRenderTarget?(ne=De[W],Ne=!0):A.useRenderbuffer?ne=Z.get(A).__webglMultisampledFramebuffer:ne=De,S.copy(A.viewport),w.copy(A.scissor),C=A.scissorTest}else S.copy(F).multiplyScalar(T).floor(),w.copy(z).multiplyScalar(T).floor(),C=N;if(pe.bindFramebuffer(36160,ne)&&fe.drawBuffers&&X){let Me=!1;if(A)if(A.isWebGLMultipleRenderTargets){const De=A.texture;if(U.length!==De.length||U[0]!==36064){for(let ze=0,Oe=De.length;ze<Oe;ze++)U[ze]=36064+ze;U.length=De.length,Me=!0}}else(U.length!==1||U[0]!==36064)&&(U[0]=36064,U.length=1,Me=!0);else(U.length!==1||U[0]!==1029)&&(U[0]=1029,U.length=1,Me=!0);Me&&(fe.isWebGL2?Q.drawBuffers(U):xe.get("WEBGL_draw_buffers").drawBuffersWEBGL(U))}if(pe.viewport(S),pe.scissor(w),pe.setScissorTest(C),Ne){const Me=Z.get(A.texture);Q.framebufferTexture2D(36160,36064,34069+W,Me.__webglTexture,J)}else if(Ae){const Me=Z.get(A.texture),De=W||0;Q.framebufferTextureLayer(36160,36064,Me.__webglTexture,J||0,De)}x=-1},this.readRenderTargetPixels=function(A,W,J,X,ne,Ne,Ae){if(!(A&&A.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ye=Z.get(A).__webglFramebuffer;if(A.isWebGLCubeRenderTarget&&Ae!==void 0&&(ye=ye[Ae]),ye){pe.bindFramebuffer(36160,ye);try{const Me=A.texture,De=Me.format,ze=Me.type;if(De!==bt&&te.convert(De)!==Q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Oe=ze===ni&&(xe.has("EXT_color_buffer_half_float")||fe.isWebGL2&&xe.has("EXT_color_buffer_float"));if(ze!==_n&&te.convert(ze)!==Q.getParameter(35738)&&!(ze===yn&&(fe.isWebGL2||xe.has("OES_texture_float")||xe.has("WEBGL_color_buffer_float")))&&!Oe){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Q.checkFramebufferStatus(36160)===36053?W>=0&&W<=A.width-X&&J>=0&&J<=A.height-ne&&Q.readPixels(W,J,X,ne,te.convert(De),te.convert(ze),Ne):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Me=y!==null?Z.get(y).__webglFramebuffer:null;pe.bindFramebuffer(36160,Me)}}},this.copyFramebufferToTexture=function(A,W,J=0){const X=Math.pow(2,-J),ne=Math.floor(W.image.width*X),Ne=Math.floor(W.image.height*X);let Ae=te.convert(W.format);fe.isWebGL2&&(Ae===6407&&(Ae=32849),Ae===6408&&(Ae=32856)),K.setTexture2D(W,0),Q.copyTexImage2D(3553,J,Ae,A.x,A.y,ne,Ne,0),pe.unbindTexture()},this.copyTextureToTexture=function(A,W,J,X=0){const ne=W.image.width,Ne=W.image.height,Ae=te.convert(J.format),ye=te.convert(J.type);K.setTexture2D(J,0),Q.pixelStorei(37440,J.flipY),Q.pixelStorei(37441,J.premultiplyAlpha),Q.pixelStorei(3317,J.unpackAlignment),W.isDataTexture?Q.texSubImage2D(3553,X,A.x,A.y,ne,Ne,Ae,ye,W.image.data):W.isCompressedTexture?Q.compressedTexSubImage2D(3553,X,A.x,A.y,W.mipmaps[0].width,W.mipmaps[0].height,Ae,W.mipmaps[0].data):Q.texSubImage2D(3553,X,A.x,A.y,Ae,ye,W.image),X===0&&J.generateMipmaps&&Q.generateMipmap(3553),pe.unbindTexture()},this.copyTextureToTexture3D=function(A,W,J,X,ne=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ne=A.max.x-A.min.x+1,Ae=A.max.y-A.min.y+1,ye=A.max.z-A.min.z+1,Me=te.convert(X.format),De=te.convert(X.type);let ze;if(X.isDataTexture3D)K.setTexture3D(X,0),ze=32879;else if(X.isDataTexture2DArray)K.setTexture2DArray(X,0),ze=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Q.pixelStorei(37440,X.flipY),Q.pixelStorei(37441,X.premultiplyAlpha),Q.pixelStorei(3317,X.unpackAlignment);const Oe=Q.getParameter(3314),et=Q.getParameter(32878),On=Q.getParameter(3316),Ve=Q.getParameter(3315),Xi=Q.getParameter(32877),Ze=J.isCompressedTexture?J.mipmaps[0]:J.image;Q.pixelStorei(3314,Ze.width),Q.pixelStorei(32878,Ze.height),Q.pixelStorei(3316,A.min.x),Q.pixelStorei(3315,A.min.y),Q.pixelStorei(32877,A.min.z),J.isDataTexture||J.isDataTexture3D?Q.texSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,ye,Me,De,Ze.data):J.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Q.compressedTexSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,ye,Me,Ze.data)):Q.texSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,ye,Me,De,Ze),Q.pixelStorei(3314,Oe),Q.pixelStorei(32878,et),Q.pixelStorei(3316,On),Q.pixelStorei(3315,Ve),Q.pixelStorei(32877,Xi),ne===0&&X.generateMipmaps&&Q.generateMipmap(ze),pe.unbindTexture()},this.initTexture=function(A){K.setTexture2D(A,0),pe.unbindTexture()},this.resetState=function(){p=0,g=0,y=null,pe.reset(),ue.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}ke.prototype.isWebGLRenderer=!0;class Sv extends ke{}Sv.prototype.isWebGL1Renderer=!0;class mc extends He{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}mc.prototype.isScene=!0;class cr{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=er,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Qt()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let r=0,s=this.stride;r<s;r++)this.array[e+r]=t.array[n+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qt()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Qt()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}cr.prototype.isInterleavedBuffer=!0;const rt=new P;class ur{constructor(e,t,n,r=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.applyMatrix4(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.applyNormalMatrix(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.transformDirection(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this}setXYZW(e,t,n,r,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return new lt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new ur(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ur.prototype.isInterleavedBufferAttribute=!0;class gc extends yt{constructor(e){super();this.type="SpriteMaterial",this.color=new Ee(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}gc.prototype.isSpriteMaterial=!0;let Ri;const hr=new P,Pi=new P,Ni=new P,Ii=new le,fr=new le,vc=new Re,us=new P,dr=new P,hs=new P,_c=new le,Ya=new le,yc=new le;class Ev extends He{constructor(e){super();if(this.type="Sprite",Ri===void 0){Ri=new Ye;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new cr(t,5);Ri.setIndex([0,1,2,0,2,3]),Ri.setAttribute("position",new ur(n,3,0,!1)),Ri.setAttribute("uv",new ur(n,2,3,!1))}this.geometry=Ri,this.material=e!==void 0?e:new gc,this.center=new le(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Pi.setFromMatrixScale(this.matrixWorld),vc.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ni.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Pi.multiplyScalar(-Ni.z);const n=this.material.rotation;let r,s;n!==0&&(s=Math.cos(n),r=Math.sin(n));const a=this.center;fs(us.set(-.5,-.5,0),Ni,a,Pi,r,s),fs(dr.set(.5,-.5,0),Ni,a,Pi,r,s),fs(hs.set(.5,.5,0),Ni,a,Pi,r,s),_c.set(0,0),Ya.set(1,0),yc.set(1,1);let o=e.ray.intersectTriangle(us,dr,hs,!1,hr);if(o===null&&(fs(dr.set(-.5,.5,0),Ni,a,Pi,r,s),Ya.set(0,1),o=e.ray.intersectTriangle(us,hs,dr,!1,hr),o===null))return;const u=e.ray.origin.distanceTo(hr);u<e.near||u>e.far||t.push({distance:u,point:hr.clone(),uv:st.getUV(hr,us,dr,hs,_c,Ya,yc,new le),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}Ev.prototype.isSprite=!0;function fs(i,e,t,n,r,s){Ii.subVectors(i,t).addScalar(.5).multiply(n),r!==void 0?(fr.x=s*Ii.x-r*Ii.y,fr.y=r*Ii.x+s*Ii.y):fr.copy(Ii),i.copy(e),i.x+=fr.x,i.y+=fr.y,i.applyMatrix4(vc)}const xc=new P,wc=new We,Mc=new We,Tv=new P,bc=new Re;class Sc extends Ct{constructor(e,t){super(e,t);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Re,this.bindMatrixInverse=new Re}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new We,t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,r=this.geometry;wc.fromBufferAttribute(r.attributes.skinIndex,e),Mc.fromBufferAttribute(r.attributes.skinWeight,e),xc.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const a=Mc.getComponent(s);if(a!==0){const o=wc.getComponent(s);bc.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(Tv.copy(xc).applyMatrix4(bc),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}Sc.prototype.isSkinnedMesh=!0;class Av extends He{constructor(){super();this.type="Bone"}}Av.prototype.isBone=!0;class Cv extends mt{constructor(e=null,t=1,n=1,r,s,a,o,u,h=ut,c=ut,l,f){super(null,a,o,u,h,c,r,s,l,f);this.image={data:e,width:t,height:n},this.magFilter=h,this.minFilter=c,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Cv.prototype.isDataTexture=!0;class Ja extends lt{constructor(e,t,n,r=1){typeof n=="number"&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(e,t,n);this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}Ja.prototype.isInstancedBufferAttribute=!0;const Ec=new Re,Tc=new Re,ds=[],pr=new Ct;class Lv extends Ct{constructor(e,t,n){super(e,t);this.instanceMatrix=new Ja(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,r=this.count;if(pr.geometry=this.geometry,pr.material=this.material,pr.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,Ec),Tc.multiplyMatrices(n,Ec),pr.matrixWorld=Tc,pr.raycast(e,ds);for(let a=0,o=ds.length;a<o;a++){const u=ds[a];u.instanceId=s,u.object=this,t.push(u)}ds.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Ja(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Lv.prototype.isInstancedMesh=!0;class mr extends yt{constructor(e){super();this.type="LineBasicMaterial",this.color=new Ee(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}mr.prototype.isLineBasicMaterial=!0;const Ac=new P,Cc=new P,Lc=new Re,ja=new pi,ps=new di;class $a extends He{constructor(e=new Ye,t=new mr){super();this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let r=1,s=t.count;r<s;r++)Ac.fromBufferAttribute(t,r-1),Cc.fromBufferAttribute(t,r),n[r]=n[r-1],n[r]+=Ac.distanceTo(Cc);e.setAttribute("lineDistance",new it(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,s=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),ps.copy(n.boundingSphere),ps.applyMatrix4(r),ps.radius+=s,e.ray.intersectsSphere(ps)===!1)return;Lc.copy(r).invert(),ja.copy(e.ray).applyMatrix4(Lc);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=o*o,h=new P,c=new P,l=new P,f=new P,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const v=n.index,_=n.attributes.position;if(v!==null){const p=Math.max(0,a.start),g=Math.min(v.count,a.start+a.count);for(let y=p,x=g-1;y<x;y+=d){const M=v.getX(y),S=v.getX(y+1);if(h.fromBufferAttribute(_,M),c.fromBufferAttribute(_,S),ja.distanceSqToSegment(h,c,f,l)>u)continue;f.applyMatrix4(this.matrixWorld);const C=e.ray.origin.distanceTo(f);C<e.near||C>e.far||t.push({distance:C,point:l.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else{const p=Math.max(0,a.start),g=Math.min(_.count,a.start+a.count);for(let y=p,x=g-1;y<x;y+=d){if(h.fromBufferAttribute(_,y),c.fromBufferAttribute(_,y+1),ja.distanceSqToSegment(h,c,f,l)>u)continue;f.applyMatrix4(this.matrixWorld);const S=e.ray.origin.distanceTo(f);S<e.near||S>e.far||t.push({distance:S,point:l.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}$a.prototype.isLine=!0;const Rc=new P,Pc=new P;class Qa extends $a{constructor(e,t){super(e,t);this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let r=0,s=t.count;r<s;r+=2)Rc.fromBufferAttribute(t,r),Pc.fromBufferAttribute(t,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+Rc.distanceTo(Pc);e.setAttribute("lineDistance",new it(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Qa.prototype.isLineSegments=!0;class Rv extends $a{constructor(e,t){super(e,t);this.type="LineLoop"}}Rv.prototype.isLineLoop=!0;class Nc extends yt{constructor(e){super();this.type="PointsMaterial",this.color=new Ee(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}Nc.prototype.isPointsMaterial=!0;const Ic=new Re,Ka=new pi,ms=new di,gs=new P;class Pv extends He{constructor(e=new Ye,t=new Nc){super();this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,s=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),ms.copy(n.boundingSphere),ms.applyMatrix4(r),ms.radius+=s,e.ray.intersectsSphere(ms)===!1)return;Ic.copy(r).invert(),Ka.copy(e.ray).applyMatrix4(Ic);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=o*o;if(n.isBufferGeometry){const h=n.index,l=n.attributes.position;if(h!==null){const f=Math.max(0,a.start),d=Math.min(h.count,a.start+a.count);for(let v=f,m=d;v<m;v++){const _=h.getX(v);gs.fromBufferAttribute(l,_),Dc(gs,_,u,r,e,t,this)}}else{const f=Math.max(0,a.start),d=Math.min(l.count,a.start+a.count);for(let v=f,m=d;v<m;v++)gs.fromBufferAttribute(l,v),Dc(gs,v,u,r,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Pv.prototype.isPoints=!0;function Dc(i,e,t,n,r,s,a){const o=Ka.distanceSqToPoint(i);if(o<t){const u=new P;Ka.closestPointToPoint(i,u),u.applyMatrix4(n);const h=r.ray.origin.distanceTo(u);if(h<r.near||h>r.far)return;s.push({distance:h,distanceToRay:Math.sqrt(o),point:u,index:e,face:null,object:a})}}class Nv extends mt{constructor(e,t,n,r,s,a,o,u,h){super(e,t,n,r,s,a,o,u,h);this.format=o!==void 0?o:kn,this.minFilter=a!==void 0?a:Ut,this.magFilter=s!==void 0?s:Ut,this.generateMipmaps=!1;const c=this;function l(){c.needsUpdate=!0,e.requestVideoFrameCallback(l)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(l)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Nv.prototype.isVideoTexture=!0;class Iv extends mt{constructor(e,t,n,r,s,a,o,u,h,c,l,f){super(null,a,o,u,h,c,r,s,l,f);this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}Iv.prototype.isCompressedTexture=!0;class Dv extends mt{constructor(e,t,n,r,s,a,o,u,h){super(e,t,n,r,s,a,o,u,h);this.needsUpdate=!0}}Dv.prototype.isCanvasTexture=!0;new P;new P;new P;new st;class Gt{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,r=this.getPoint(0),s=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),s+=n.distanceTo(r),t.push(s),r=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let r=0;const s=n.length;let a;t?a=t:a=e*n[s-1];let o=0,u=s-1,h;for(;o<=u;)if(r=Math.floor(o+(u-o)/2),h=n[r]-a,h<0)o=r+1;else if(h>0)u=r-1;else{u=r;break}if(r=u,n[r]===a)return r/(s-1);const c=n[r],f=n[r+1]-c,d=(a-c)/f;return(r+d)/(s-1)}getTangent(e,t){const n=1e-4;let r=e-n,s=e+n;r<0&&(r=0),s>1&&(s=1);const a=this.getPoint(r),o=this.getPoint(s),u=t||(a.isVector2?new le:new P);return u.copy(o).sub(a).normalize(),u}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new P,r=[],s=[],a=[],o=new P,u=new Re;for(let d=0;d<=e;d++){const v=d/e;r[d]=this.getTangentAt(v,new P)}s[0]=new P,a[0]=new P;let h=Number.MAX_VALUE;const c=Math.abs(r[0].x),l=Math.abs(r[0].y),f=Math.abs(r[0].z);c<=h&&(h=c,n.set(1,0,0)),l<=h&&(h=l,n.set(0,1,0)),f<=h&&n.set(0,0,1),o.crossVectors(r[0],n).normalize(),s[0].crossVectors(r[0],o),a[0].crossVectors(r[0],s[0]);for(let d=1;d<=e;d++){if(s[d]=s[d-1].clone(),a[d]=a[d-1].clone(),o.crossVectors(r[d-1],r[d]),o.length()>Number.EPSILON){o.normalize();const v=Math.acos(zt(r[d-1].dot(r[d]),-1,1));s[d].applyMatrix4(u.makeRotationAxis(o,v))}a[d].crossVectors(r[d],s[d])}if(t===!0){let d=Math.acos(zt(s[0].dot(s[e]),-1,1));d/=e,r[0].dot(o.crossVectors(s[0],s[e]))>0&&(d=-d);for(let v=1;v<=e;v++)s[v].applyMatrix4(u.makeRotationAxis(r[v],d*v)),a[v].crossVectors(r[v],s[v])}return{tangents:r,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class vs extends Gt{constructor(e=0,t=0,n=1,r=1,s=0,a=Math.PI*2,o=!1,u=0){super();this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=u}getPoint(e,t){const n=t||new le,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(a?s=0:s=r),this.aClockwise===!0&&!a&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+e*s;let u=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),l=Math.sin(this.aRotation),f=u-this.aX,d=h-this.aY;u=f*c-d*l+this.aX,h=f*l+d*c+this.aY}return n.set(u,h)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}vs.prototype.isEllipseCurve=!0;class Fc extends vs{constructor(e,t,n,r,s,a){super(e,t,n,n,r,s,a);this.type="ArcCurve"}}Fc.prototype.isArcCurve=!0;function eo(){let i=0,e=0,t=0,n=0;function r(s,a,o,u){i=s,e=o,t=-3*s+3*a-2*o-u,n=2*s-2*a+o+u}return{initCatmullRom:function(s,a,o,u,h){r(a,o,h*(o-s),h*(u-a))},initNonuniformCatmullRom:function(s,a,o,u,h,c,l){let f=(a-s)/h-(o-s)/(h+c)+(o-a)/c,d=(o-a)/c-(u-a)/(c+l)+(u-o)/l;f*=c,d*=c,r(a,o,f,d)},calc:function(s){const a=s*s,o=a*s;return i+e*s+t*a+n*o}}}const _s=new P,to=new eo,no=new eo,io=new eo;class zc extends Gt{constructor(e=[],t=!1,n="centripetal",r=.5){super();this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=r}getPoint(e,t=new P){const n=t,r=this.points,s=r.length,a=(s-(this.closed?0:1))*e;let o=Math.floor(a),u=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:u===0&&o===s-1&&(o=s-2,u=1);let h,c;this.closed||o>0?h=r[(o-1)%s]:(_s.subVectors(r[0],r[1]).add(r[0]),h=_s);const l=r[o%s],f=r[(o+1)%s];if(this.closed||o+2<s?c=r[(o+2)%s]:(_s.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=_s),this.curveType==="centripetal"||this.curveType==="chordal"){const d=this.curveType==="chordal"?.5:.25;let v=Math.pow(h.distanceToSquared(l),d),m=Math.pow(l.distanceToSquared(f),d),_=Math.pow(f.distanceToSquared(c),d);m<1e-4&&(m=1),v<1e-4&&(v=m),_<1e-4&&(_=m),to.initNonuniformCatmullRom(h.x,l.x,f.x,c.x,v,m,_),no.initNonuniformCatmullRom(h.y,l.y,f.y,c.y,v,m,_),io.initNonuniformCatmullRom(h.z,l.z,f.z,c.z,v,m,_)}else this.curveType==="catmullrom"&&(to.initCatmullRom(h.x,l.x,f.x,c.x,this.tension),no.initCatmullRom(h.y,l.y,f.y,c.y,this.tension),io.initCatmullRom(h.z,l.z,f.z,c.z,this.tension));return n.set(to.calc(u),no.calc(u),io.calc(u)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new P().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}zc.prototype.isCatmullRomCurve3=!0;function Bc(i,e,t,n,r){const s=(n-e)*.5,a=(r-t)*.5,o=i*i,u=i*o;return(2*t-2*n+s+a)*u+(-3*t+3*n-2*s-a)*o+s*i+t}function Fv(i,e){const t=1-i;return t*t*e}function zv(i,e){return 2*(1-i)*i*e}function Bv(i,e){return i*i*e}function gr(i,e,t,n){return Fv(i,e)+zv(i,t)+Bv(i,n)}function Ov(i,e){const t=1-i;return t*t*t*e}function Uv(i,e){const t=1-i;return 3*t*t*i*e}function Vv(i,e){return 3*(1-i)*i*i*e}function Hv(i,e){return i*i*i*e}function vr(i,e,t,n,r){return Ov(i,e)+Uv(i,t)+Vv(i,n)+Hv(i,r)}class ro extends Gt{constructor(e=new le,t=new le,n=new le,r=new le){super();this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new le){const n=t,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(vr(e,r.x,s.x,a.x,o.x),vr(e,r.y,s.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}ro.prototype.isCubicBezierCurve=!0;class Oc extends Gt{constructor(e=new P,t=new P,n=new P,r=new P){super();this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new P){const n=t,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(vr(e,r.x,s.x,a.x,o.x),vr(e,r.y,s.y,a.y,o.y),vr(e,r.z,s.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Oc.prototype.isCubicBezierCurve3=!0;class ys extends Gt{constructor(e=new le,t=new le){super();this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new le){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new le;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ys.prototype.isLineCurve=!0;class Gv extends Gt{constructor(e=new P,t=new P){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new P){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class so extends Gt{constructor(e=new le,t=new le,n=new le){super();this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new le){const n=t,r=this.v0,s=this.v1,a=this.v2;return n.set(gr(e,r.x,s.x,a.x),gr(e,r.y,s.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}so.prototype.isQuadraticBezierCurve=!0;class Uc extends Gt{constructor(e=new P,t=new P,n=new P){super();this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new P){const n=t,r=this.v0,s=this.v1,a=this.v2;return n.set(gr(e,r.x,s.x,a.x),gr(e,r.y,s.y,a.y),gr(e,r.z,s.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Uc.prototype.isQuadraticBezierCurve3=!0;class ao extends Gt{constructor(e=[]){super();this.type="SplineCurve",this.points=e}getPoint(e,t=new le){const n=t,r=this.points,s=(r.length-1)*e,a=Math.floor(s),o=s-a,u=r[a===0?a:a-1],h=r[a],c=r[a>r.length-2?r.length-1:a+1],l=r[a>r.length-3?r.length-1:a+2];return n.set(Bc(o,u.x,h.x,c.x,l.x),Bc(o,u.y,h.y,c.y,l.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new le().fromArray(r))}return this}}ao.prototype.isSplineCurve=!0;var Vc=Object.freeze({__proto__:null,ArcCurve:Fc,CatmullRomCurve3:zc,CubicBezierCurve:ro,CubicBezierCurve3:Oc,EllipseCurve:vs,LineCurve:ys,LineCurve3:Gv,QuadraticBezierCurve:so,QuadraticBezierCurve3:Uc,SplineCurve:ao});class kv extends Gt{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new ys(t,e))}getPoint(e,t){const n=e*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=n){const a=r[s]-n,o=this.curves[s],u=o.getLength(),h=u===0?0:1-a/u;return o.getPointAt(h,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const a=s[r],o=a&&a.isEllipseCurve?e*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,u=a.getPoints(o);for(let h=0;h<u.length;h++){const c=u[h];n&&n.equals(c)||(t.push(c),n=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(new Vc[r.type]().fromJSON(r))}return this}}class oo extends kv{constructor(e){super();this.type="Path",this.currentPoint=new le,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new ys(this.currentPoint.clone(),new le(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,r){const s=new so(this.currentPoint.clone(),new le(e,t),new le(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(e,t,n,r,s,a){const o=new ro(this.currentPoint.clone(),new le(e,t),new le(n,r),new le(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new ao(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,r,s,a){const o=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(e+o,t+u,n,r,s,a),this}absarc(e,t,n,r,s,a){return this.absellipse(e,t,n,n,r,s,a),this}ellipse(e,t,n,r,s,a,o,u){const h=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+h,t+c,n,r,s,a,o,u),this}absellipse(e,t,n,r,s,a,o,u){const h=new vs(e,t,n,r,s,a,o,u);if(this.curves.length>0){const l=h.getPoint(0);l.equals(this.currentPoint)||this.lineTo(l.x,l.y)}this.curves.push(h);const c=h.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class _r extends oo{constructor(e){super(e);this.uuid=Qt(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(new oo().fromJSON(r))}return this}}const Wv={triangulate:function(i,e,t=2){const n=e&&e.length,r=n?e[0]*t:i.length;let s=Hc(i,0,r,t,!0);const a=[];if(!s||s.next===s.prev)return a;let o,u,h,c,l,f,d;if(n&&(s=Jv(i,e,s,t)),i.length>80*t){o=h=i[0],u=c=i[1];for(let v=t;v<r;v+=t)l=i[v],f=i[v+1],l<o&&(o=l),f<u&&(u=f),l>h&&(h=l),f>c&&(c=f);d=Math.max(h-o,c-u),d=d!==0?1/d:0}return yr(s,a,t,o,u,d),a}};function Hc(i,e,t,n,r){let s,a;if(r===a0(i,e,t,n)>0)for(s=e;s<t;s+=n)a=Wc(s,i[s],i[s+1],a);else for(s=t-n;s>=e;s-=n)a=Wc(s,i[s],i[s+1],a);return a&&xs(a,a.next)&&(wr(a),a=a.next),a}function Ln(i,e){if(!i)return i;e||(e=i);let t=i,n;do if(n=!1,!t.steiner&&(xs(t,t.next)||$e(t.prev,t,t.next)===0)){if(wr(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function yr(i,e,t,n,r,s,a){if(!i)return;!a&&s&&e0(i,n,r,s);let o=i,u,h;for(;i.prev!==i.next;){if(u=i.prev,h=i.next,s?Xv(i,n,r,s):qv(i)){e.push(u.i/t),e.push(i.i/t),e.push(h.i/t),wr(i),i=h.next,o=h.next;continue}if(i=h,i===o){a?a===1?(i=Zv(Ln(i),e,t),yr(i,e,t,n,r,s,2)):a===2&&Yv(i,e,t,n,r,s):yr(Ln(i),e,t,n,r,s,1);break}}}function qv(i){const e=i.prev,t=i,n=i.next;if($e(e,t,n)>=0)return!1;let r=i.next.next;for(;r!==i.prev;){if(Di(e.x,e.y,t.x,t.y,n.x,n.y,r.x,r.y)&&$e(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Xv(i,e,t,n){const r=i.prev,s=i,a=i.next;if($e(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,u=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,h=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,c=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,l=lo(o,u,e,t,n),f=lo(h,c,e,t,n);let d=i.prevZ,v=i.nextZ;for(;d&&d.z>=l&&v&&v.z<=f;){if(d!==i.prev&&d!==i.next&&Di(r.x,r.y,s.x,s.y,a.x,a.y,d.x,d.y)&&$e(d.prev,d,d.next)>=0||(d=d.prevZ,v!==i.prev&&v!==i.next&&Di(r.x,r.y,s.x,s.y,a.x,a.y,v.x,v.y)&&$e(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;d&&d.z>=l;){if(d!==i.prev&&d!==i.next&&Di(r.x,r.y,s.x,s.y,a.x,a.y,d.x,d.y)&&$e(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;v&&v.z<=f;){if(v!==i.prev&&v!==i.next&&Di(r.x,r.y,s.x,s.y,a.x,a.y,v.x,v.y)&&$e(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Zv(i,e,t){let n=i;do{const r=n.prev,s=n.next.next;!xs(r,s)&&Gc(r,n,n.next,s)&&xr(r,s)&&xr(s,r)&&(e.push(r.i/t),e.push(n.i/t),e.push(s.i/t),wr(n),wr(n.next),n=i=s),n=n.next}while(n!==i);return Ln(n)}function Yv(i,e,t,n,r,s){let a=i;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&i0(a,o)){let u=kc(a,o);a=Ln(a,a.next),u=Ln(u,u.next),yr(a,e,t,n,r,s),yr(u,e,t,n,r,s);return}o=o.next}a=a.next}while(a!==i)}function Jv(i,e,t,n){const r=[];let s,a,o,u,h;for(s=0,a=e.length;s<a;s++)o=e[s]*n,u=s<a-1?e[s+1]*n:i.length,h=Hc(i,o,u,n,!1),h===h.next&&(h.steiner=!0),r.push(n0(h));for(r.sort(jv),s=0;s<r.length;s++)$v(r[s],t),t=Ln(t,t.next);return t}function jv(i,e){return i.x-e.x}function $v(i,e){if(e=Qv(i,e),e){const t=kc(e,i);Ln(e,e.next),Ln(t,t.next)}}function Qv(i,e){let t=e;const n=i.x,r=i.y;let s=-1/0,a;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const f=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=n&&f>s){if(s=f,f===n){if(r===t.y)return t;if(r===t.next.y)return t.next}a=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!a)return null;if(n===s)return a;const o=a,u=a.x,h=a.y;let c=1/0,l;t=a;do n>=t.x&&t.x>=u&&n!==t.x&&Di(r<h?n:s,r,u,h,r<h?s:n,r,t.x,t.y)&&(l=Math.abs(r-t.y)/(n-t.x),xr(t,i)&&(l<c||l===c&&(t.x>a.x||t.x===a.x&&Kv(a,t)))&&(a=t,c=l)),t=t.next;while(t!==o);return a}function Kv(i,e){return $e(i.prev,i,e.prev)<0&&$e(e.next,i,i.next)<0}function e0(i,e,t,n){let r=i;do r.z===null&&(r.z=lo(r.x,r.y,e,t,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==i);r.prevZ.nextZ=null,r.prevZ=null,t0(r)}function t0(i){let e,t,n,r,s,a,o,u,h=1;do{for(t=i,i=null,s=null,a=0;t;){for(a++,n=t,o=0,e=0;e<h&&(o++,n=n.nextZ,!!n);e++);for(u=h;o>0||u>0&&n;)o!==0&&(u===0||!n||t.z<=n.z)?(r=t,t=t.nextZ,o--):(r=n,n=n.nextZ,u--),s?s.nextZ=r:i=r,r.prevZ=s,s=r;t=n}s.nextZ=null,h*=2}while(a>1);return i}function lo(i,e,t,n,r){return i=32767*(i-t)*r,e=32767*(e-n)*r,i=(i|i<<8)&16711935,i=(i|i<<4)&252645135,i=(i|i<<2)&858993459,i=(i|i<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,i|e<<1}function n0(i){let e=i,t=i;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==i);return t}function Di(i,e,t,n,r,s,a,o){return(r-a)*(e-o)-(i-a)*(s-o)>=0&&(i-a)*(n-o)-(t-a)*(e-o)>=0&&(t-a)*(s-o)-(r-a)*(n-o)>=0}function i0(i,e){return i.next.i!==e.i&&i.prev.i!==e.i&&!r0(i,e)&&(xr(i,e)&&xr(e,i)&&s0(i,e)&&($e(i.prev,i,e.prev)||$e(i,e.prev,e))||xs(i,e)&&$e(i.prev,i,i.next)>0&&$e(e.prev,e,e.next)>0)}function $e(i,e,t){return(e.y-i.y)*(t.x-e.x)-(e.x-i.x)*(t.y-e.y)}function xs(i,e){return i.x===e.x&&i.y===e.y}function Gc(i,e,t,n){const r=Ms($e(i,e,t)),s=Ms($e(i,e,n)),a=Ms($e(t,n,i)),o=Ms($e(t,n,e));return!!(r!==s&&a!==o||r===0&&ws(i,t,e)||s===0&&ws(i,n,e)||a===0&&ws(t,i,n)||o===0&&ws(t,e,n))}function ws(i,e,t){return e.x<=Math.max(i.x,t.x)&&e.x>=Math.min(i.x,t.x)&&e.y<=Math.max(i.y,t.y)&&e.y>=Math.min(i.y,t.y)}function Ms(i){return i>0?1:i<0?-1:0}function r0(i,e){let t=i;do{if(t.i!==i.i&&t.next.i!==i.i&&t.i!==e.i&&t.next.i!==e.i&&Gc(t,t.next,i,e))return!0;t=t.next}while(t!==i);return!1}function xr(i,e){return $e(i.prev,i,i.next)<0?$e(i,e,i.next)>=0&&$e(i,i.prev,e)>=0:$e(i,e,i.prev)<0||$e(i,i.next,e)<0}function s0(i,e){let t=i,n=!1;const r=(i.x+e.x)/2,s=(i.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==i);return n}function kc(i,e){const t=new co(i.i,i.x,i.y),n=new co(e.i,e.x,e.y),r=i.next,s=e.prev;return i.next=e,e.prev=i,t.next=r,r.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function Wc(i,e,t,n){const r=new co(i,e,t);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function wr(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function co(i,e,t){this.i=i,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function a0(i,e,t,n){let r=0;for(let s=e,a=t-n;s<t;s+=n)r+=(i[a]-i[s])*(i[s+1]+i[a+1]),a=s;return r}class Rn{static area(e){const t=e.length;let n=0;for(let r=t-1,s=0;s<t;r=s++)n+=e[r].x*e[s].y-e[s].x*e[r].y;return n*.5}static isClockWise(e){return Rn.area(e)<0}static triangulateShape(e,t){const n=[],r=[],s=[];qc(e),Xc(n,e);let a=e.length;t.forEach(qc);for(let u=0;u<t.length;u++)r.push(a),a+=t[u].length,Xc(n,t[u]);const o=Wv.triangulate(n,r);for(let u=0;u<o.length;u+=3)s.push(o.slice(u,u+3));return s}}function qc(i){const e=i.length;e>2&&i[e-1].equals(i[0])&&i.pop()}function Xc(i,e){for(let t=0;t<e.length;t++)i.push(e[t].x),i.push(e[t].y)}class Fi extends Ye{constructor(e=new _r([new le(.5,.5),new le(-.5,.5),new le(-.5,-.5),new le(.5,-.5)]),t={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,r=[],s=[];for(let o=0,u=e.length;o<u;o++){const h=e[o];a(h)}this.setAttribute("position",new it(r,3)),this.setAttribute("uv",new it(s,2)),this.computeVertexNormals();function a(o){const u=[],h=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1;let l=t.depth!==void 0?t.depth:1,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:.2,v=t.bevelSize!==void 0?t.bevelSize:d-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,_=t.bevelSegments!==void 0?t.bevelSegments:3;const p=t.extrudePath,g=t.UVGenerator!==void 0?t.UVGenerator:o0;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=t.amount);let y,x=!1,M,S,w,C;p&&(y=p.getSpacedPoints(c),x=!0,f=!1,M=p.computeFrenetFrames(c,!1),S=new P,w=new P,C=new P),f||(_=0,d=0,v=0,m=0);const I=o.extractPoints(h);let D=I.shape;const T=I.holes;if(!Rn.isClockWise(D)){D=D.reverse();for(let Z=0,K=T.length;Z<K;Z++){const ae=T[Z];Rn.isClockWise(ae)&&(T[Z]=ae.reverse())}}const B=Rn.triangulateShape(D,T),F=D;for(let Z=0,K=T.length;Z<K;Z++){const ae=T[Z];D=D.concat(ae)}function z(Z,K,ae){return K||console.error("THREE.ExtrudeGeometry: vec does not exist"),K.clone().multiplyScalar(ae).add(Z)}const N=D.length,U=B.length;function Y(Z,K,ae){let me,he,Te;const Le=Z.x-K.x,R=Z.y-K.y,H=ae.x-Z.x,E=ae.y-Z.y,b=Le*Le+R*R,V=Le*E-R*H;if(Math.abs(V)>Number.EPSILON){const G=Math.sqrt(b),ie=Math.sqrt(H*H+E*E),j=K.x-R/G,L=K.y+Le/G,$=ae.x-E/ie,te=ae.y+H/ie,ue=(($-j)*E-(te-L)*H)/(Le*E-R*H);me=j+Le*ue-Z.x,he=L+R*ue-Z.y;const ce=me*me+he*he;if(ce<=2)return new le(me,he);Te=Math.sqrt(ce/2)}else{let G=!1;Le>Number.EPSILON?H>Number.EPSILON&&(G=!0):Le<-Number.EPSILON?H<-Number.EPSILON&&(G=!0):Math.sign(R)===Math.sign(E)&&(G=!0),G?(me=-R,he=Le,Te=Math.sqrt(b)):(me=Le,he=R,Te=Math.sqrt(b/2))}return new le(me/Te,he/Te)}const ee=[];for(let Z=0,K=F.length,ae=K-1,me=Z+1;Z<K;Z++,ae++,me++)ae===K&&(ae=0),me===K&&(me=0),ee[Z]=Y(F[Z],F[ae],F[me]);const k=[];let q,oe=ee.concat();for(let Z=0,K=T.length;Z<K;Z++){const ae=T[Z];q=[];for(let me=0,he=ae.length,Te=he-1,Le=me+1;me<he;me++,Te++,Le++)Te===he&&(Te=0),Le===he&&(Le=0),q[me]=Y(ae[me],ae[Te],ae[Le]);k.push(q),oe=oe.concat(q)}for(let Z=0;Z<_;Z++){const K=Z/_,ae=d*Math.cos(K*Math.PI/2),me=v*Math.sin(K*Math.PI/2)+m;for(let he=0,Te=F.length;he<Te;he++){const Le=z(F[he],ee[he],me);ve(Le.x,Le.y,-ae)}for(let he=0,Te=T.length;he<Te;he++){const Le=T[he];q=k[he];for(let R=0,H=Le.length;R<H;R++){const E=z(Le[R],q[R],me);ve(E.x,E.y,-ae)}}}const se=v+m;for(let Z=0;Z<N;Z++){const K=f?z(D[Z],oe[Z],se):D[Z];x?(w.copy(M.normals[0]).multiplyScalar(K.x),S.copy(M.binormals[0]).multiplyScalar(K.y),C.copy(y[0]).add(w).add(S),ve(C.x,C.y,C.z)):ve(K.x,K.y,0)}for(let Z=1;Z<=c;Z++)for(let K=0;K<N;K++){const ae=f?z(D[K],oe[K],se):D[K];x?(w.copy(M.normals[Z]).multiplyScalar(ae.x),S.copy(M.binormals[Z]).multiplyScalar(ae.y),C.copy(y[Z]).add(w).add(S),ve(C.x,C.y,C.z)):ve(ae.x,ae.y,l/c*Z)}for(let Z=_-1;Z>=0;Z--){const K=Z/_,ae=d*Math.cos(K*Math.PI/2),me=v*Math.sin(K*Math.PI/2)+m;for(let he=0,Te=F.length;he<Te;he++){const Le=z(F[he],ee[he],me);ve(Le.x,Le.y,l+ae)}for(let he=0,Te=T.length;he<Te;he++){const Le=T[he];q=k[he];for(let R=0,H=Le.length;R<H;R++){const E=z(Le[R],q[R],me);x?ve(E.x,E.y+y[c-1].y,y[c-1].x+ae):ve(E.x,E.y,l+ae)}}}de(),Se();function de(){const Z=r.length/3;if(f){let K=0,ae=N*K;for(let me=0;me<U;me++){const he=B[me];xe(he[2]+ae,he[1]+ae,he[0]+ae)}K=c+_*2,ae=N*K;for(let me=0;me<U;me++){const he=B[me];xe(he[0]+ae,he[1]+ae,he[2]+ae)}}else{for(let K=0;K<U;K++){const ae=B[K];xe(ae[2],ae[1],ae[0])}for(let K=0;K<U;K++){const ae=B[K];xe(ae[0]+N*c,ae[1]+N*c,ae[2]+N*c)}}n.addGroup(Z,r.length/3-Z,0)}function Se(){const Z=r.length/3;let K=0;Q(F,K),K+=F.length;for(let ae=0,me=T.length;ae<me;ae++){const he=T[ae];Q(he,K),K+=he.length}n.addGroup(Z,r.length/3-Z,1)}function Q(Z,K){let ae=Z.length;for(;--ae>=0;){const me=ae;let he=ae-1;he<0&&(he=Z.length-1);for(let Te=0,Le=c+_*2;Te<Le;Te++){const R=N*Te,H=N*(Te+1),E=K+me+R,b=K+he+R,V=K+he+H,G=K+me+H;fe(E,b,V,G)}}}function ve(Z,K,ae){u.push(Z),u.push(K),u.push(ae)}function xe(Z,K,ae){pe(Z),pe(K),pe(ae);const me=r.length/3,he=g.generateTopUV(n,r,me-3,me-2,me-1);Pe(he[0]),Pe(he[1]),Pe(he[2])}function fe(Z,K,ae,me){pe(Z),pe(K),pe(me),pe(K),pe(ae),pe(me);const he=r.length/3,Te=g.generateSideWallUV(n,r,he-6,he-3,he-2,he-1);Pe(Te[0]),Pe(Te[1]),Pe(Te[3]),Pe(Te[1]),Pe(Te[2]),Pe(Te[3])}function pe(Z){r.push(u[Z*3+0]),r.push(u[Z*3+1]),r.push(u[Z*3+2])}function Pe(Z){s.push(Z.x),s.push(Z.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return l0(t,n,e)}static fromJSON(e,t){const n=[];for(let s=0,a=e.shapes.length;s<a;s++){const o=t[e.shapes[s]];n.push(o)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new Vc[r.type]().fromJSON(r)),new Fi(n,e.options)}}const o0={generateTopUV:function(i,e,t,n,r){const s=e[t*3],a=e[t*3+1],o=e[n*3],u=e[n*3+1],h=e[r*3],c=e[r*3+1];return[new le(s,a),new le(o,u),new le(h,c)]},generateSideWallUV:function(i,e,t,n,r,s){const a=e[t*3],o=e[t*3+1],u=e[t*3+2],h=e[n*3],c=e[n*3+1],l=e[n*3+2],f=e[r*3],d=e[r*3+1],v=e[r*3+2],m=e[s*3],_=e[s*3+1],p=e[s*3+2];return Math.abs(o-c)<Math.abs(a-h)?[new le(a,1-u),new le(h,1-l),new le(f,1-v),new le(m,1-p)]:[new le(o,1-u),new le(c,1-l),new le(d,1-v),new le(_,1-p)]}};function l0(i,e,t){if(t.shapes=[],Array.isArray(i))for(let n=0,r=i.length;n<r;n++){const s=i[n];t.shapes.push(s.uuid)}else t.shapes.push(i.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class uo extends Ye{constructor(e=new _r([new le(0,.5),new le(-.5,-.5),new le(.5,-.5)]),t=12){super();this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],r=[],s=[],a=[];let o=0,u=0;if(Array.isArray(e)===!1)h(e);else for(let c=0;c<e.length;c++)h(e[c]),this.addGroup(o,u,c),o+=u,u=0;this.setIndex(n),this.setAttribute("position",new it(r,3)),this.setAttribute("normal",new it(s,3)),this.setAttribute("uv",new it(a,2));function h(c){const l=r.length/3,f=c.extractPoints(t);let d=f.shape;const v=f.holes;Rn.isClockWise(d)===!1&&(d=d.reverse());for(let _=0,p=v.length;_<p;_++){const g=v[_];Rn.isClockWise(g)===!0&&(v[_]=g.reverse())}const m=Rn.triangulateShape(d,v);for(let _=0,p=v.length;_<p;_++){const g=v[_];d=d.concat(g)}for(let _=0,p=d.length;_<p;_++){const g=d[_];r.push(g.x,g.y,0),s.push(0,0,1),a.push(g.x,g.y)}for(let _=0,p=m.length;_<p;_++){const g=m[_],y=g[0]+l,x=g[1]+l,M=g[2]+l;n.push(y,x,M),u+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return c0(t,e)}static fromJSON(e,t){const n=[];for(let r=0,s=e.shapes.length;r<s;r++){const a=t[e.shapes[r]];n.push(a)}return new uo(n,e.curveSegments)}}function c0(i,e){if(e.shapes=[],Array.isArray(i))for(let t=0,n=i.length;t<n;t++){const r=i[t];e.shapes.push(r.uuid)}else e.shapes.push(i.uuid);return e}class Zc extends Ye{constructor(e=1,t=32,n=16,r=0,s=Math.PI*2,a=0,o=Math.PI){super();this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:s,thetaStart:a,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const u=Math.min(a+o,Math.PI);let h=0;const c=[],l=new P,f=new P,d=[],v=[],m=[],_=[];for(let p=0;p<=n;p++){const g=[],y=p/n;let x=0;p==0&&a==0?x=.5/t:p==n&&u==Math.PI&&(x=-.5/t);for(let M=0;M<=t;M++){const S=M/t;l.x=-e*Math.cos(r+S*s)*Math.sin(a+y*o),l.y=e*Math.cos(a+y*o),l.z=e*Math.sin(r+S*s)*Math.sin(a+y*o),v.push(l.x,l.y,l.z),f.copy(l).normalize(),m.push(f.x,f.y,f.z),_.push(S+x,1-y),g.push(h++)}c.push(g)}for(let p=0;p<n;p++)for(let g=0;g<t;g++){const y=c[p][g+1],x=c[p][g],M=c[p+1][g],S=c[p+1][g+1];(p!==0||a>0)&&d.push(y,x,S),(p!==n-1||u<Math.PI)&&d.push(x,M,S)}this.setIndex(d),this.setAttribute("position",new it(v,3)),this.setAttribute("normal",new it(m,3)),this.setAttribute("uv",new it(_,2))}static fromJSON(e){return new Zc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class u0 extends yt{constructor(e){super();this.type="ShadowMaterial",this.color=new Ee(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}u0.prototype.isShadowMaterial=!0;class Yc extends yt{constructor(e){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ee(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=oi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}Yc.prototype.isMeshStandardMaterial=!0;class h0 extends Yc{constructor(e){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new le(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return zt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Ee(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Ee(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ee(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}h0.prototype.isMeshPhysicalMaterial=!0;class f0 extends yt{constructor(e){super();this.type="MeshPhongMaterial",this.color=new Ee(16777215),this.specular=new Ee(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=oi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}f0.prototype.isMeshPhongMaterial=!0;class d0 extends yt{constructor(e){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ee(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=oi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}d0.prototype.isMeshToonMaterial=!0;class p0 extends yt{constructor(e){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=oi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}p0.prototype.isMeshNormalMaterial=!0;class m0 extends yt{constructor(e){super();this.type="MeshLambertMaterial",this.color=new Ee(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}m0.prototype.isMeshLambertMaterial=!0;class g0 extends yt{constructor(e){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ee(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=oi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}g0.prototype.isMeshMatcapMaterial=!0;class v0 extends mr{constructor(e){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}v0.prototype.isLineDashedMaterial=!0;const Je={arraySlice:function(i,e,t){return Je.isTypedArray(i)?new i.constructor(i.subarray(e,t!==void 0?t:i.length)):i.slice(e,t)},convertArray:function(i,e,t){return!i||!t&&i.constructor===e?i:typeof e.BYTES_PER_ELEMENT=="number"?new e(i):Array.prototype.slice.call(i)},isTypedArray:function(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)},getKeyframeOrder:function(i){function e(r,s){return i[r]-i[s]}const t=i.length,n=new Array(t);for(let r=0;r!==t;++r)n[r]=r;return n.sort(e),n},sortedArray:function(i,e,t){const n=i.length,r=new i.constructor(n);for(let s=0,a=0;a!==n;++s){const o=t[s]*e;for(let u=0;u!==e;++u)r[a++]=i[o+u]}return r},flattenJSON:function(i,e,t,n){let r=1,s=i[0];for(;s!==void 0&&s[n]===void 0;)s=i[r++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(e.push(s.time),t.push.apply(t,a)),s=i[r++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(e.push(s.time),a.toArray(t,t.length)),s=i[r++];while(s!==void 0);else do a=s[n],a!==void 0&&(e.push(s.time),t.push(a)),s=i[r++];while(s!==void 0)},subclip:function(i,e,t,n,r=30){const s=i.clone();s.name=e;const a=[];for(let u=0;u<s.tracks.length;++u){const h=s.tracks[u],c=h.getValueSize(),l=[],f=[];for(let d=0;d<h.times.length;++d){const v=h.times[d]*r;if(!(v<t||v>=n)){l.push(h.times[d]);for(let m=0;m<c;++m)f.push(h.values[d*c+m])}}l.length!==0&&(h.times=Je.convertArray(l,h.times.constructor),h.values=Je.convertArray(f,h.values.constructor),a.push(h))}s.tracks=a;let o=1/0;for(let u=0;u<s.tracks.length;++u)o>s.tracks[u].times[0]&&(o=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(i,e=0,t=i,n=30){n<=0&&(n=30);const r=t.tracks.length,s=e/n;for(let a=0;a<r;++a){const o=t.tracks[a],u=o.ValueTypeName;if(u==="bool"||u==="string")continue;const h=i.tracks.find(function(p){return p.name===o.name&&p.ValueTypeName===u});if(h===void 0)continue;let c=0;const l=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=l/3);let f=0;const d=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const v=o.times.length-1;let m;if(s<=o.times[0]){const p=c,g=l-c;m=Je.arraySlice(o.values,p,g)}else if(s>=o.times[v]){const p=v*l+c,g=p+l-c;m=Je.arraySlice(o.values,p,g)}else{const p=o.createInterpolant(),g=c,y=l-c;p.evaluate(s),m=Je.arraySlice(p.resultBuffer,g,y)}u==="quaternion"&&new At().fromArray(m).normalize().conjugate().toArray(m);const _=h.times.length;for(let p=0;p<_;++p){const g=p*d+f;if(u==="quaternion")At.multiplyQuaternionsFlat(h.values,g,m,0,h.values,g);else{const y=d-f*2;for(let x=0;x<y;++x)h.values[g+x]-=m[x]}}}return i.blendMode=ll,i}};class Pn{constructor(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],s=t[n-1];e:{t:{let a;n:{i:if(!(e<r)){for(let o=n+2;;){if(r===void 0){if(e<s)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,s)}if(n===o)break;if(s=r,r=t[++n],e<r)break t}a=t.length;break n}if(!(e>=s)){const o=t[1];e<o&&(n=2,s=o);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(n===u)break;if(r=s,s=t[--n-1],e>=s)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(r=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(r===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,s,e)}this._cachedIndex=n,this.intervalChanged_(n,s,r)}return this.interpolate_(n,s,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,s=e*r;for(let a=0;a!==r;++a)t[a]=n[s+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Pn.prototype.beforeStart_=Pn.prototype.copySampleValue_;Pn.prototype.afterEnd_=Pn.prototype.copySampleValue_;class _0 extends Pn{constructor(e,t,n,r){super(e,t,n,r);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:si,endingEnd:si}}intervalChanged_(e,t,n){const r=this.parameterPositions;let s=e-2,a=e+1,o=r[s],u=r[a];if(o===void 0)switch(this.getSettings_().endingStart){case ai:s=e,o=2*t-n;break;case Br:s=r.length-2,o=t+r[s]-r[s+1];break;default:s=e,o=n}if(u===void 0)switch(this.getSettings_().endingEnd){case ai:a=e,u=2*n-t;break;case Br:a=1,u=n+r[1]-r[0];break;default:a=e-1,u=t}const h=(n-t)*.5,c=this.valueSize;this._weightPrev=h/(t-o),this._weightNext=h/(u-n),this._offsetPrev=s*c,this._offsetNext=a*c}interpolate_(e,t,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=e*o,h=u-o,c=this._offsetPrev,l=this._offsetNext,f=this._weightPrev,d=this._weightNext,v=(n-t)/(r-t),m=v*v,_=m*v,p=-f*_+2*f*m-f*v,g=(1+f)*_+(-1.5-2*f)*m+(-.5+f)*v+1,y=(-1-d)*_+(1.5+d)*m+.5*v,x=d*_-d*m;for(let M=0;M!==o;++M)s[M]=p*a[c+M]+g*a[h+M]+y*a[u+M]+x*a[l+M];return s}}class Jc extends Pn{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=e*o,h=u-o,c=(n-t)/(r-t),l=1-c;for(let f=0;f!==o;++f)s[f]=a[h+f]*l+a[u+f]*c;return s}}class y0 extends Pn{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class tn{constructor(e,t,n,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Je.convertArray(t,this.TimeBufferType),this.values=Je.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Je.convertArray(e.times,Array),values:Je.convertArray(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(n.interpolation=r)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new y0(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Jc(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new _0(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Fr:t=this.InterpolantFactoryMethodDiscrete;break;case zr:t=this.InterpolantFactoryMethodLinear;break;case na:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Fr;case this.InterpolantFactoryMethodLinear:return zr;case this.InterpolantFactoryMethodSmooth:return na}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let s=0,a=r-1;for(;s!==r&&n[s]<e;)++s;for(;a!==-1&&n[a]>t;)--a;if(++a,s!==0||a!==r){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=Je.arraySlice(n,s,a),this.values=Je.arraySlice(this.values,s*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==s;o++){const u=n[o];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,u),e=!1;break}if(a!==null&&a>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,u,a),e=!1;break}a=u}if(r!==void 0&&Je.isTypedArray(r))for(let o=0,u=r.length;o!==u;++o){const h=r[o];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,h),e=!1;break}}return e}optimize(){const e=Je.arraySlice(this.times),t=Je.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===na,s=e.length-1;let a=1;for(let o=1;o<s;++o){let u=!1;const h=e[o],c=e[o+1];if(h!==c&&(o!==1||h!==e[0]))if(r)u=!0;else{const l=o*n,f=l-n,d=l+n;for(let v=0;v!==n;++v){const m=t[l+v];if(m!==t[f+v]||m!==t[d+v]){u=!0;break}}}if(u){if(o!==a){e[a]=e[o];const l=o*n,f=a*n;for(let d=0;d!==n;++d)t[f+d]=t[l+d]}++a}}if(s>0){e[a]=e[s];for(let o=s*n,u=a*n,h=0;h!==n;++h)t[u+h]=t[o+h];++a}return a!==e.length?(this.times=Je.arraySlice(e,0,a),this.values=Je.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=Je.arraySlice(this.times,0),t=Je.arraySlice(this.values,0),n=this.constructor,r=new n(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}tn.prototype.TimeBufferType=Float32Array;tn.prototype.ValueBufferType=Float32Array;tn.prototype.DefaultInterpolation=zr;class zi extends tn{}zi.prototype.ValueTypeName="bool";zi.prototype.ValueBufferType=Array;zi.prototype.DefaultInterpolation=Fr;zi.prototype.InterpolantFactoryMethodLinear=void 0;zi.prototype.InterpolantFactoryMethodSmooth=void 0;class jc extends tn{}jc.prototype.ValueTypeName="color";class bs extends tn{}bs.prototype.ValueTypeName="number";class x0 extends Pn{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,u=(n-t)/(r-t);let h=e*o;for(let c=h+o;h!==c;h+=4)At.slerpFlat(s,0,a,h-o,a,h,u);return s}}class Mr extends tn{InterpolantFactoryMethodLinear(e){return new x0(this.times,this.values,this.getValueSize(),e)}}Mr.prototype.ValueTypeName="quaternion";Mr.prototype.DefaultInterpolation=zr;Mr.prototype.InterpolantFactoryMethodSmooth=void 0;class Bi extends tn{}Bi.prototype.ValueTypeName="string";Bi.prototype.ValueBufferType=Array;Bi.prototype.DefaultInterpolation=Fr;Bi.prototype.InterpolantFactoryMethodLinear=void 0;Bi.prototype.InterpolantFactoryMethodSmooth=void 0;class Ss extends tn{}Ss.prototype.ValueTypeName="vector";class $c{constructor(e,t=-1,n,r=ia){this.name=e,this.tracks=n,this.duration=t,this.blendMode=r,this.uuid=Qt(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(M0(n[a]).scale(r));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,a=n.length;s!==a;++s)t.push(tn.toJSON(n[s]));return r}static CreateFromMorphTargetSequence(e,t,n,r){const s=t.length,a=[];for(let o=0;o<s;o++){let u=[],h=[];u.push((o+s-1)%s,o,(o+1)%s),h.push(0,1,0);const c=Je.getKeyframeOrder(u);u=Je.sortedArray(u,1,c),h=Je.sortedArray(h,1,c),!r&&u[0]===0&&(u.push(s),h.push(h[0])),a.push(new bs(".morphTargetInfluences["+t[o].name+"]",u,h).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const r=e;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===t)return n[r];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,u=e.length;o<u;o++){const h=e[o],c=h.name.match(s);if(c&&c.length>1){const l=c[1];let f=r[l];f||(r[l]=f=[]),f.push(h)}}const a=[];for(const o in r)a.push(this.CreateFromMorphTargetSequence(o,r[o],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(l,f,d,v,m){if(d.length!==0){const _=[],p=[];Je.flattenJSON(d,_,p,v),_.length!==0&&m.push(new l(f,_,p))}},r=[],s=e.name||"default",a=e.fps||30,o=e.blendMode;let u=e.length||-1;const h=e.hierarchy||[];for(let l=0;l<h.length;l++){const f=h[l].keys;if(!(!f||f.length===0))if(f[0].morphTargets){const d={};let v;for(v=0;v<f.length;v++)if(f[v].morphTargets)for(let m=0;m<f[v].morphTargets.length;m++)d[f[v].morphTargets[m]]=-1;for(const m in d){const _=[],p=[];for(let g=0;g!==f[v].morphTargets.length;++g){const y=f[v];_.push(y.time),p.push(y.morphTarget===m?1:0)}r.push(new bs(".morphTargetInfluence["+m+"]",_,p))}u=d.length*(a||1)}else{const d=".bones["+t[l].name+"]";n(Ss,d+".position",f,"pos",r),n(Mr,d+".quaternion",f,"rot",r),n(Ss,d+".scale",f,"scl",r)}}return r.length===0?null:new this(s,u,r,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,r=e.length;n!==r;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function w0(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return bs;case"vector":case"vector2":case"vector3":case"vector4":return Ss;case"color":return jc;case"quaternion":return Mr;case"bool":case"boolean":return zi;case"string":return Bi}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function M0(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=w0(i.type);if(i.times===void 0){const t=[],n=[];Je.flattenJSON(i.keys,t,n,"value"),i.times=t,i.values=n}return e.parse!==void 0?e.parse(i):new e(i.name,i.times,i.values,i.interpolation)}const Oi={enabled:!1,files:{},add:function(i,e){this.enabled!==!1&&(this.files[i]=e)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class b0{constructor(e,t,n){const r=this;let s=!1,a=0,o=0,u;const h=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){o++,s===!1&&r.onStart!==void 0&&r.onStart(c,a,o),s=!0},this.itemEnd=function(c){a++,r.onProgress!==void 0&&r.onProgress(c,a,o),a===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return u?u(c):c},this.setURLModifier=function(c){return u=c,this},this.addHandler=function(c,l){return h.push(c,l),this},this.removeHandler=function(c){const l=h.indexOf(c);return l!==-1&&h.splice(l,2),this},this.getHandler=function(c){for(let l=0,f=h.length;l<f;l+=2){const d=h[l],v=h[l+1];if(d.global&&(d.lastIndex=0),d.test(c))return v}return null}}}const S0=new b0;class Nn{constructor(e){this.manager=e!==void 0?e:S0,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(r,s){n.load(e,r,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const fn={};class E0 extends Nn{constructor(e){super(e)}load(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Oi.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(fn[e]!==void 0){fn[e].push({onLoad:t,onProgress:n,onError:r});return}fn[e]=[],fn[e].push({onLoad:t,onProgress:n,onError:r});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(a).then(o=>{if(o.status===200||o.status===0){o.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const u=fn[e],h=o.body.getReader(),c=o.headers.get("Content-Length"),l=c?parseInt(c):0,f=l!==0;let d=0;return new ReadableStream({start(v){m();function m(){h.read().then(({done:_,value:p})=>{if(_)v.close();else{d+=p.byteLength;const g=new ProgressEvent("progress",{lengthComputable:f,loaded:d,total:l});for(let y=0,x=u.length;y<x;y++){const M=u[y];M.onProgress&&M.onProgress(g)}v.enqueue(p),m()}})}}})}else throw Error(`fetch for "${o.url}" responded with ${o.status}: ${o.statusText}`)}).then(o=>{const u=new Response(o);switch(this.responseType){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(h=>new DOMParser().parseFromString(h,this.mimeType));case"json":return u.json();default:return u.text()}}).then(o=>{Oi.add(e,o);const u=fn[e];delete fn[e];for(let h=0,c=u.length;h<c;h++){const l=u[h];l.onLoad&&l.onLoad(o)}this.manager.itemEnd(e)}).catch(o=>{const u=fn[e];delete fn[e];for(let h=0,c=u.length;h<c;h++){const l=u[h];l.onError&&l.onError(o)}this.manager.itemError(e),this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Qc extends Nn{constructor(e){super(e)}load(e,t,n,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Oi.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o=Vr("img");function u(){c(),Oi.add(e,this),t&&t(this),s.manager.itemEnd(e)}function h(l){c(),r&&r(l),s.manager.itemError(e),s.manager.itemEnd(e)}function c(){o.removeEventListener("load",u,!1),o.removeEventListener("error",h,!1)}return o.addEventListener("load",u,!1),o.addEventListener("error",h,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(e),o.src=e,o}}class T0 extends Nn{constructor(e){super(e)}load(e,t,n,r){const s=new is,a=new Qc(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function u(h){a.load(e[h],function(c){s.images[h]=c,o++,o===6&&(s.needsUpdate=!0,t&&t(s))},void 0,r)}for(let h=0;h<e.length;++h)u(h);return s}}class A0 extends Nn{constructor(e){super(e)}load(e,t,n,r){const s=new mt,a=new Qc(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){s.image=o,s.needsUpdate=!0,t!==void 0&&t(s)},n,r),s}}class nn extends He{constructor(e,t=1){super();this.type="Light",this.color=new Ee(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}nn.prototype.isLight=!0;class C0 extends nn{constructor(e,t,n){super(e,n);this.type="HemisphereLight",this.position.copy(He.DefaultUp),this.updateMatrix(),this.groundColor=new Ee(t)}copy(e){return nn.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}C0.prototype.isHemisphereLight=!0;const Kc=new Re,eu=new P,tu=new P;class ho{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new le(512,512),this.map=null,this.mapPass=null,this.matrix=new Re,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ss,this._frameExtents=new le(1,1),this._viewportCount=1,this._viewports=[new We(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;eu.setFromMatrixPosition(e.matrixWorld),t.position.copy(eu),tu.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(tu),t.updateMatrixWorld(),Kc.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Kc),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class nu extends ho{constructor(){super(new Lt(50,1,.5,500));this.focus=1}updateMatrices(e){const t=this.camera,n=la*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||r!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=r,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}nu.prototype.isSpotLightShadow=!0;class L0 extends nn{constructor(e,t,n=0,r=Math.PI/3,s=0,a=1){super(e,t);this.type="SpotLight",this.position.copy(He.DefaultUp),this.updateMatrix(),this.target=new He,this.distance=n,this.angle=r,this.penumbra=s,this.decay=a,this.shadow=new nu}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}L0.prototype.isSpotLight=!0;const iu=new Re,br=new P,fo=new P;class ru extends ho{constructor(){super(new Lt(90,1,.5,500));this._frameExtents=new le(4,2),this._viewportCount=6,this._viewports=[new We(2,1,1,1),new We(0,1,1,1),new We(3,1,1,1),new We(1,1,1,1),new We(3,0,1,1),new We(1,0,1,1)],this._cubeDirections=[new P(1,0,0),new P(-1,0,0),new P(0,0,1),new P(0,0,-1),new P(0,1,0),new P(0,-1,0)],this._cubeUps=[new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,0,1),new P(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,r=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),br.setFromMatrixPosition(e.matrixWorld),n.position.copy(br),fo.copy(n.position),fo.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(fo),n.updateMatrixWorld(),r.makeTranslation(-br.x,-br.y,-br.z),iu.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(iu)}}ru.prototype.isPointLightShadow=!0;class R0 extends nn{constructor(e,t,n=0,r=1){super(e,t);this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new ru}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}R0.prototype.isPointLight=!0;class su extends ho{constructor(){super(new Oa(-5,5,5,-5,.5,500))}}su.prototype.isDirectionalLightShadow=!0;class P0 extends nn{constructor(e,t){super(e,t);this.type="DirectionalLight",this.position.copy(He.DefaultUp),this.updateMatrix(),this.target=new He,this.shadow=new su}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}P0.prototype.isDirectionalLight=!0;class N0 extends nn{constructor(e,t){super(e,t);this.type="AmbientLight"}}N0.prototype.isAmbientLight=!0;class I0 extends nn{constructor(e,t,n=10,r=10){super(e,t);this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}I0.prototype.isRectAreaLight=!0;class au{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new P)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*r),t.addScaledVector(a[2],.488603*s),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*r)),t.addScaledVector(a[5],1.092548*(r*s)),t.addScaledVector(a[6],.315392*(3*s*s-1)),t.addScaledVector(a[7],1.092548*(n*s)),t.addScaledVector(a[8],.546274*(n*n-r*r)),t}getIrradianceAt(e,t){const n=e.x,r=e.y,s=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*r),t.addScaledVector(a[2],2*.511664*s),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*r),t.addScaledVector(a[5],2*.429043*r*s),t.addScaledVector(a[6],.743125*s*s-.247708),t.addScaledVector(a[7],2*.429043*n*s),t.addScaledVector(a[8],.429043*(n*n-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const n=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-r*r)}}au.prototype.isSphericalHarmonics3=!0;class po extends nn{constructor(e=new au,t=1){super(void 0,t);this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}po.prototype.isLightProbe=!0;class D0{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class F0 extends Ye{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}F0.prototype.isInstancedBufferGeometry=!0;class z0 extends Nn{constructor(e){super(e);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Oi.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){Oi.add(e,u),t&&t(u),s.manager.itemEnd(e)}).catch(function(u){r&&r(u),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}z0.prototype.isImageBitmapLoader=!0;let Es;const B0={getContext:function(){return Es===void 0&&(Es=new(window.AudioContext||window.webkitAudioContext)),Es},setContext:function(i){Es=i}};class O0 extends Nn{constructor(e){super(e)}load(e,t,n,r){const s=this,a=new E0(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{const u=o.slice(0);B0.getContext().decodeAudioData(u,function(c){t(c)})}catch(u){r?r(u):console.error(u),s.manager.itemError(e)}},n,r)}}class U0 extends po{constructor(e,t,n=1){super(void 0,n);const r=new Ee().set(e),s=new Ee().set(t),a=new P(r.r,r.g,r.b),o=new P(s.r,s.g,s.b),u=Math.sqrt(Math.PI),h=u*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(u),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(h)}}U0.prototype.isHemisphereLightProbe=!0;class V0 extends po{constructor(e,t=1){super(void 0,t);const n=new Ee().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}V0.prototype.isAmbientLightProbe=!0;class H0 extends He{constructor(e){super();this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class G0{constructor(e,t,n){this.binding=e,this.valueSize=n;let r,s,a;switch(t){case"quaternion":r=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:r=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,r=this.valueSize,s=e*r+r;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==r;++o)n[s+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,s,0,o,r)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,r=e*t+t,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=t*this._origIndex;this._mixBufferRegion(n,r,u,1-s,t)}a>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let u=t,h=t+t;u!==h;++u)if(n[u]!==n[u+t]){o.setValue(n,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let s=n,a=r;s!==a;++s)t[s]=t[r+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,r,s){if(r>=.5)for(let a=0;a!==s;++a)e[t+a]=e[n+a]}_slerp(e,t,n,r){At.slerpFlat(e,t,e,t,e,n,r)}_slerpAdditive(e,t,n,r,s){const a=this._workIndex*s;At.multiplyQuaternionsFlat(e,a,e,t,e,n),At.slerpFlat(e,t,e,t,e,a,r)}_lerp(e,t,n,r,s){const a=1-r;for(let o=0;o!==s;++o){const u=t+o;e[u]=e[u]*a+e[n+o]*r}}_lerpAdditive(e,t,n,r,s){for(let a=0;a!==s;++a){const o=t+a;e[o]=e[o]+e[n+a]*r}}}const mo="\\[\\]\\.:\\/",k0=new RegExp("["+mo+"]","g"),go="[^"+mo+"]",W0="[^"+mo.replace("\\.","")+"]",q0=/((?:WC+[\/:])*)/.source.replace("WC",go),X0=/(WCOD+)?/.source.replace("WCOD",W0),Z0=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",go),Y0=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",go),J0=new RegExp("^"+q0+X0+Z0+Y0+"$"),j0=["material","materials","bones"];class $0{constructor(e,t,n){const r=n||Ge.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];r!==void 0&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=n.length;r!==s;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class Ge{constructor(e,t,n){this.path=t,this.parsedPath=n||Ge.parseTrackName(t),this.node=Ge.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new Ge.Composite(e,t,n):new Ge(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(k0,"")}static parseTrackName(e){const t=J0.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=n.nodeName.substring(r+1);j0.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===t||o.uuid===t)return o;const u=n(o.children);if(u)return u}return null},r=n(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let s=t.propertyIndex;if(e||(e=Ge.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let h=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===h){h=c;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(h!==void 0){if(e[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[h]}}const a=e[r];if(a===void 0){const h=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+r+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(u=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=r;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ge.Composite=$0;Ge.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ge.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ge.prototype.GetterByBindingType=[Ge.prototype._getValue_direct,Ge.prototype._getValue_array,Ge.prototype._getValue_arrayElement,Ge.prototype._getValue_toArray];Ge.prototype.SetterByBindingTypeAndVersioning=[[Ge.prototype._setValue_direct,Ge.prototype._setValue_direct_setNeedsUpdate,Ge.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ge.prototype._setValue_array,Ge.prototype._setValue_array_setNeedsUpdate,Ge.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ge.prototype._setValue_arrayElement,Ge.prototype._setValue_arrayElement_setNeedsUpdate,Ge.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ge.prototype._setValue_fromArray,Ge.prototype._setValue_fromArray_setNeedsUpdate,Ge.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Q0{constructor(e,t,n=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=r;const s=t.tracks,a=s.length,o=new Array(a),u={endingStart:si,endingEnd:si};for(let h=0;h!==a;++h){const c=s[h].createInterpolant(null);o[h]=c,c.settings=u}this._interpolantSettings=u,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Df,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const r=this._clip.duration,s=e._clip.duration,a=s/r,o=r/s;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,s=r.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=r._lendControlInterpolant(),this._timeScaleInterpolant=o);const u=o.parameterPositions,h=o.sampleValues;return u[0]=s,u[1]=s+n,h[0]=e/a,h[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const u=(e-s)*n;if(u<0||n===0)return;this._startTime=null,t=n*u}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const u=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case ll:for(let c=0,l=u.length;c!==l;++c)u[c].evaluate(a),h[c].accumulateAdditive(o);break;case ia:default:for(let c=0,l=u.length;c!==l;++c)u[c].evaluate(a),h[c].accumulate(r,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(e)[0];t*=r,e>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let r=this.time+e,s=this._loopCount;const a=n===Ff;if(e===0)return s===-1?r:a&&(s&1)==1?t-r:r;if(n===If){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),r>=t||r<0){const o=Math.floor(r/t);r-=t*o,s+=Math.abs(o);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(u===1){const h=e<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=r;if(a&&(s&1)==1)return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;n?(r.endingStart=ai,r.endingEnd=ai):(e?r.endingStart=this.zeroSlopeAtStart?ai:si:r.endingStart=Br,t?r.endingEnd=this.zeroSlopeAtEnd?ai:si:r.endingEnd=Br)}_scheduleFading(e,t,n){const r=this._mixer,s=r.time;let a=this._weightInterpolant;a===null&&(a=r._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,u=a.sampleValues;return o[0]=s,u[0]=t,o[1]=s+e,u[1]=n,this}}class K0 extends qn{constructor(e){super();this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,s=r.length,a=e._propertyBindings,o=e._interpolants,u=n.uuid,h=this._bindingsByRootAndName;let c=h[u];c===void 0&&(c={},h[u]=c);for(let l=0;l!==s;++l){const f=r[l],d=f.name;let v=c[d];if(v!==void 0)a[l]=v;else{if(v=a[l],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,u,d));continue}const m=t&&t._propertyBindings[l].binding.parsedPath;v=new G0(Ge.create(n,d,m),f.ValueTypeName,f.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,u,d),a[l]=v}o[l].resultBuffer=v.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,r=e._clip.uuid,s=this._actionsByClip[r];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,r,n)}const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];s.useCount++==0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];--s.useCount==0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const r=this._actions,s=this._actionsByClip;let a=s[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=r.length,r.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r,t[r]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,a=this._actionsByClip,o=a[s],u=o.knownActions,h=u[u.length-1],c=e._byClipCacheIndex;h._byClipCacheIndex=c,u[c]=h,u.pop(),e._byClipCacheIndex=null;const l=o.actionByRoot,f=(e._localRoot||this._root).uuid;delete l[f],u.length===0&&delete a[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];--s.referenceCount==0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const r=this._bindingsByRootAndName,s=this._bindings;let a=r[t];a===void 0&&(a={},r[t]=a),a[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,o=a[r],u=t[t.length-1],h=e._cacheIndex;u._cacheIndex=h,t[h]=u,t.pop(),delete o[s],Object.keys(o).length===0&&delete a[r]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new Jc(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,s=t[r];e.__cacheIndex=r,t[r]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const r=t||this._root,s=r.uuid;let a=typeof e=="string"?$c.findByName(r,e):e;const o=a!==null?a.uuid:e,u=this._actionsByClip[o];let h=null;if(n===void 0&&(a!==null?n=a.blendMode:n=ia),u!==void 0){const l=u.actionByRoot[s];if(l!==void 0&&l.blendMode===n)return l;h=u.knownActions[0],a===null&&(a=h._clip)}if(a===null)return null;const c=new Q0(this,a,t,n);return this._bindAction(c,h),this._addInactiveAction(c,o,s),c}existingAction(e,t){const n=t||this._root,r=n.uuid,s=typeof e=="string"?$c.findByName(n,e):e,a=s?s.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,s=Math.sign(e),a=this._accuIndex^=1;for(let h=0;h!==n;++h)t[h]._update(r,e,s,a);const o=this._bindings,u=this._nActiveBindings;for(let h=0;h!==u;++h)o[h].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,s=r[n];if(s!==void 0){const a=s.knownActions;for(let o=0,u=a.length;o!==u;++o){const h=a[o];this._deactivateAction(h);const c=h._cacheIndex,l=t[t.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,l._cacheIndex=c,t[c]=l,t.pop(),this._removeInactiveBindingsForAction(h)}delete r[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,u=o[t];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const r=this._bindingsByRootAndName,s=r[t];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}K0.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class e_ extends cr{constructor(e,t,n=1){super(e,t);this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}e_.prototype.isInstancedInterleavedBuffer=!0;const In=new P,Ts=new Re,vo=new Re;class t_ extends Qa{constructor(e){const t=ou(e),n=new Ye,r=[],s=[],a=new Ee(0,0,1),o=new Ee(0,1,0);for(let h=0;h<t.length;h++){const c=t[h];c.parent&&c.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}n.setAttribute("position",new it(r,3)),n.setAttribute("color",new it(s,3));const u=new mr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,r=n.getAttribute("position");vo.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<t.length;s++){const o=t[s];o.parent&&o.parent.isBone&&(Ts.multiplyMatrices(vo,o.matrixWorld),In.setFromMatrixPosition(Ts),r.setXYZ(a,In.x,In.y,In.z),Ts.multiplyMatrices(vo,o.parent.matrixWorld),In.setFromMatrixPosition(Ts),r.setXYZ(a+1,In.x,In.y,In.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function ou(i){const e=[];i&&i.isBone&&e.push(i);for(let t=0;t<i.children.length;t++)e.push.apply(e,ou(i.children[t]));return e}class n_ extends Qa{constructor(e=10,t=10,n=4473924,r=8947848){n=new Ee(n),r=new Ee(r);const s=t/2,a=e/t,o=e/2,u=[],h=[];for(let f=0,d=0,v=-o;f<=t;f++,v+=a){u.push(-o,0,v,o,0,v),u.push(v,0,-o,v,0,o);const m=f===s?n:r;m.toArray(h,d),d+=3,m.toArray(h,d),d+=3,m.toArray(h,d),d+=3,m.toArray(h,d),d+=3}const c=new Ye;c.setAttribute("position",new it(u,3)),c.setAttribute("color",new it(h,3));const l=new mr({vertexColors:!0,toneMapped:!1});super(c,l);this.type="GridHelper"}}const i_=new Float32Array(1);new Int32Array(i_.buffer);Gt.create=function(i,e){return console.log("THREE.Curve.create() has been deprecated"),i.prototype=Object.create(Gt.prototype),i.prototype.constructor=i,i.prototype.getPoint=e,i};oo.prototype.fromPoints=function(i){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(i)};n_.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};t_.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Nn.prototype.extractUrlBase=function(i){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),D0.extractUrlBase(i)};Nn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Wt.prototype.center=function(i){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(i)};Wt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Wt.prototype.isIntersectionBox=function(i){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};Wt.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};Wt.prototype.size=function(i){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(i)};di.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};ss.prototype.setFromMatrix=function(i){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(i)};pt.prototype.flattenToArrayOffset=function(i,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,e)};pt.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};pt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};pt.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};pt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};pt.prototype.getInverse=function(i){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};Re.prototype.extractPosition=function(i){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(i)};Re.prototype.flattenToArrayOffset=function(i,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,e)};Re.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new P().setFromMatrixColumn(this,3)};Re.prototype.setRotationFromQuaternion=function(i){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(i)};Re.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Re.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.multiplyVector4=function(i){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Re.prototype.rotateAxis=function(i){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),i.transformDirection(this)};Re.prototype.crossVector=function(i){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Re.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Re.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Re.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Re.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Re.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Re.prototype.makeFrustum=function(i,e,t,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(i,e,n,t,r,s)};Re.prototype.getInverse=function(i){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};hn.prototype.isIntersectionLine=function(i){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(i)};At.prototype.multiplyVector3=function(i){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),i.applyQuaternion(this)};At.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};pi.prototype.isIntersectionBox=function(i){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};pi.prototype.isIntersectionPlane=function(i){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(i)};pi.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};st.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};st.prototype.barycoordFromPoint=function(i,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(i,e)};st.prototype.midpoint=function(i){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(i)};st.prototypenormal=function(i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(i)};st.prototype.plane=function(i){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(i)};st.barycoordFromPoint=function(i,e,t,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),st.getBarycoord(i,e,t,n,r)};st.normal=function(i,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),st.getNormal(i,e,t,n)};_r.prototype.extractAllPoints=function(i){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(i)};_r.prototype.extrude=function(i){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Fi(this,i)};_r.prototype.makeGeometry=function(i){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new uo(this,i)};le.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};le.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};le.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};P.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};P.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};P.prototype.getPositionFromMatrix=function(i){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(i)};P.prototype.getScaleFromMatrix=function(i){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(i)};P.prototype.getColumnFromMatrix=function(i,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,i)};P.prototype.applyProjection=function(i){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(i)};P.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};P.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};P.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};We.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};We.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};He.prototype.getChildByName=function(i){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(i)};He.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};He.prototype.translate=function(i,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,i)};He.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};He.prototype.applyMatrix=function(i){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(He.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(i){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=i}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Ct.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Ct.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),zf},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Sc.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Lt.prototype.setLens=function(i,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(i)};Object.defineProperties(nn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(i){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=i}},shadowCameraLeft:{set:function(i){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=i}},shadowCameraRight:{set:function(i){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=i}},shadowCameraTop:{set:function(i){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=i}},shadowCameraBottom:{set:function(i){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=i}},shadowCameraNear:{set:function(i){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=i}},shadowCameraFar:{set:function(i){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=i}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(i){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=i}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(i){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=i}},shadowMapHeight:{set:function(i){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=i}}});Object.defineProperties(lt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Ur},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Ur)}}});lt.prototype.setDynamic=function(i){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Ur:er),this};lt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},lt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Ye.prototype.addIndex=function(i){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(i)};Ye.prototype.addAttribute=function(i,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(i,new lt(arguments[1],arguments[2]))):i==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(i,e)};Ye.prototype.addDrawCall=function(i,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(i,e)};Ye.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Ye.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Ye.prototype.removeAttribute=function(i){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(i)};Ye.prototype.applyMatrix=function(i){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(Ye.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});cr.prototype.setDynamic=function(i){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Ur:er),this};cr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Fi.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Fi.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Fi.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};mc.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(yt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ee}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(i){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===Ho}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(i){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=i}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Yn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(i){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=i}}});ke.prototype.clearTarget=function(i,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(i),this.clear(e,t,n)};ke.prototype.animate=function(i){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(i)};ke.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};ke.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};ke.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};ke.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};ke.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};ke.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};ke.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};ke.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};ke.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};ke.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};ke.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};ke.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};ke.prototype.enableScissorTest=function(i){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(i)};ke.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};ke.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};ke.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};ke.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};ke.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};ke.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};ke.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};ke.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};ke.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};ke.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(ke.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=i}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=i}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(i){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=i===!0?Or:Tt}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(dc.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Vt.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=i}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=i}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=i}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=i}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(i){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=i}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(i){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=i}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(i){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=i}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(i){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=i}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(i){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=i}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(i){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=i}}});H0.prototype.load=function(i){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new O0().load(i,function(n){e.setBuffer(n)}),this};Fa.prototype.updateCubeMap=function(i,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(i,e)};Fa.prototype.clear=function(i,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(i,e,t,n)};ci.crossOrigin=void 0;ci.loadTexture=function(i,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new A0;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,t,void 0,n);return e&&(s.mapping=e),s};ci.loadTextureCube=function(i,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new T0;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,t,void 0,n);return e&&(s.mapping=e),s};ci.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};ci.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Js}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Js);function _o(){return _o=Object.assign||function(i){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(i[n]=t[n])}return i},_o.apply(this,arguments)}var lu={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null};function nt(i){return typeof i=="number"}function Yt(i){return!i||typeof i!="object"||typeof i.constructor!="function"?!1:i.isBigNumber===!0&&typeof i.constructor.prototype=="object"&&i.constructor.prototype.isBigNumber===!0||typeof i.constructor.isDecimal=="function"&&i.constructor.isDecimal(i)===!0}function yo(i){return i&&typeof i=="object"&&Object.getPrototypeOf(i).isComplex===!0||!1}function xo(i){return i&&typeof i=="object"&&Object.getPrototypeOf(i).isFraction===!0||!1}function wo(i){return i&&i.constructor.prototype.isUnit===!0||!1}function dn(i){return typeof i=="string"}var Qe=Array.isArray;function Et(i){return i&&i.constructor.prototype.isMatrix===!0||!1}function cu(i){return Array.isArray(i)||Et(i)}function r_(i){return i&&i.isDenseMatrix&&i.constructor.prototype.isMatrix===!0||!1}function s_(i){return i&&i.isSparseMatrix&&i.constructor.prototype.isMatrix===!0||!1}function uu(i){return i&&i.constructor.prototype.isRange===!0||!1}function As(i){return i&&i.constructor.prototype.isIndex===!0||!1}function a_(i){return typeof i=="boolean"}function hu(i){return i&&i.constructor.prototype.isResultSet===!0||!1}function fu(i){return i&&i.constructor.prototype.isHelp===!0||!1}function o_(i){return typeof i=="function"}function l_(i){return i instanceof Date}function c_(i){return i instanceof RegExp}function u_(i){return!!(i&&typeof i=="object"&&i.constructor===Object&&!yo(i)&&!xo(i))}function h_(i){return i===null}function f_(i){return i===void 0}function d_(i){return i&&i.isAccessorNode===!0&&i.constructor.prototype.isNode===!0||!1}function p_(i){return i&&i.isArrayNode===!0&&i.constructor.prototype.isNode===!0||!1}function m_(i){return i&&i.isAssignmentNode===!0&&i.constructor.prototype.isNode===!0||!1}function g_(i){return i&&i.isBlockNode===!0&&i.constructor.prototype.isNode===!0||!1}function v_(i){return i&&i.isConditionalNode===!0&&i.constructor.prototype.isNode===!0||!1}function __(i){return i&&i.isConstantNode===!0&&i.constructor.prototype.isNode===!0||!1}function y_(i){return i&&i.isFunctionAssignmentNode===!0&&i.constructor.prototype.isNode===!0||!1}function x_(i){return i&&i.isFunctionNode===!0&&i.constructor.prototype.isNode===!0||!1}function w_(i){return i&&i.isIndexNode===!0&&i.constructor.prototype.isNode===!0||!1}function du(i){return i&&i.isNode===!0&&i.constructor.prototype.isNode===!0||!1}function M_(i){return i&&i.isObjectNode===!0&&i.constructor.prototype.isNode===!0||!1}function b_(i){return i&&i.isOperatorNode===!0&&i.constructor.prototype.isNode===!0||!1}function S_(i){return i&&i.isParenthesisNode===!0&&i.constructor.prototype.isNode===!0||!1}function E_(i){return i&&i.isRangeNode===!0&&i.constructor.prototype.isNode===!0||!1}function T_(i){return i&&i.isSymbolNode===!0&&i.constructor.prototype.isNode===!0||!1}function pu(i){return i&&i.constructor.prototype.isChain===!0||!1}function Sr(i){var e=typeof i;return e==="object"?i===null?"null":Array.isArray(i)?"Array":i instanceof Date?"Date":i instanceof RegExp?"RegExp":Yt(i)?"BigNumber":yo(i)?"Complex":xo(i)?"Fraction":Et(i)?"Matrix":wo(i)?"Unit":As(i)?"Index":uu(i)?"Range":hu(i)?"ResultSet":du(i)?i.type:pu(i)?"Chain":fu(i)?"Help":"Object":e==="function"?"Function":e}function gt(i){var e=typeof i;if(e==="number"||e==="string"||e==="boolean"||i===null||i===void 0)return i;if(typeof i.clone=="function")return i.clone();if(Array.isArray(i))return i.map(function(t){return gt(t)});if(i instanceof Date)return new Date(i.valueOf());if(Yt(i))return i;if(i instanceof RegExp)throw new TypeError("Cannot clone "+i);return A_(i,gt)}function A_(i,e){var t={};for(var n in i)Er(i,n)&&(t[n]=e(i[n]));return t}function C_(i,e){for(var t in e)Er(e,t)&&(i[t]=e[t]);return i}function Cs(i,e){var t,n,r;if(Array.isArray(i)){if(!Array.isArray(e)||i.length!==e.length)return!1;for(n=0,r=i.length;n<r;n++)if(!Cs(i[n],e[n]))return!1;return!0}else{if(typeof i=="function")return i===e;if(i instanceof Object){if(Array.isArray(e)||!(e instanceof Object))return!1;for(t in i)if(!(t in e)||!Cs(i[t],e[t]))return!1;for(t in e)if(!(t in i))return!1;return!0}else return i===e}}function Er(i,e){return i&&Object.hasOwnProperty.call(i,e)}function L_(i,e){for(var t={},n=0;n<e.length;n++){var r=e[n],s=i[r];s!==void 0&&(t[r]=s)}return t}var R_=["Matrix","Array"],P_=["number","BigNumber","Fraction"],Ls=function(e){if(e)throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);return Object.freeze(lu)};_o(Ls,lu,{MATRIX_OPTIONS:R_,NUMBER_OPTIONS:P_});var N_=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function mu(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var gu={exports:{}};(function(i,e){(function(t,n){i.exports=n()})(N_,function(){function t(){return!0}function n(){return!1}function r(){}function s(){var a=[{name:"number",test:function(R){return typeof R=="number"}},{name:"string",test:function(R){return typeof R=="string"}},{name:"boolean",test:function(R){return typeof R=="boolean"}},{name:"Function",test:function(R){return typeof R=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(R){return R instanceof Date}},{name:"RegExp",test:function(R){return R instanceof RegExp}},{name:"Object",test:function(R){return typeof R=="object"&&R!==null&&R.constructor===Object}},{name:"null",test:function(R){return R===null}},{name:"undefined",test:function(R){return R===void 0}}],o={name:"any",test:t},u=[],h=[],c={types:a,conversions:h,ignore:u};function l(R){var H=ae(c.types,function(b){return b.name===R});if(H)return H;if(R==="any")return o;var E=ae(c.types,function(b){return b.name.toLowerCase()===R.toLowerCase()});throw new TypeError('Unknown type "'+R+'"'+(E?'. Did you mean "'+E.name+'"?':""))}function f(R){return R===o?999:c.types.indexOf(R)}function d(R){var H=ae(c.types,function(E){return E.test(R)});if(H)return H.name;throw new TypeError("Value has unknown type. Value: "+R)}function v(R,H){if(!R.signatures)throw new TypeError("Function is no typed-function");var E;if(typeof H=="string"){E=H.split(",");for(var b=0;b<E.length;b++)E[b]=E[b].trim()}else if(Array.isArray(H))E=H;else throw new TypeError("String array or a comma separated string expected");var V=E.join(","),G=R.signatures[V];if(G)return G;throw new TypeError("Signature not found (signature: "+(R.name||"unnamed")+"("+E.join(", ")+"))")}function m(R,H){var E=d(R);if(H===E)return R;for(var b=0;b<c.conversions.length;b++){var V=c.conversions[b];if(V.from===E&&V.to===H)return V.convert(R)}throw new Error("Cannot convert from "+E+" to "+H)}function _(R){return R.map(function(H){var E=H.types.map(I);return(H.restParam?"...":"")+E.join("|")}).join(",")}function p(R,H){var E=R.indexOf("...")===0,b=E?R.length>3?R.slice(3):"any":R,V=b.split("|").map(Se).filter(Q).filter(de),G=U(H,V),ie=V.map(function(L){var $=l(L);return{name:L,typeIndex:f($),test:$.test,conversion:null,conversionIndex:-1}}),j=G.map(function(L){var $=l(L.from);return{name:L.from,typeIndex:f($),test:$.test,conversion:L,conversionIndex:H.indexOf(L)}});return{types:ie.concat(j),restParam:E}}function g(R,H,E){var b=[];return R.trim()!==""&&(b=R.split(",").map(Se).map(function(V,G,ie){var j=p(V,E);if(j.restParam&&G!==ie.length-1)throw new SyntaxError('Unexpected rest parameter "'+V+'": only allowed for the last parameter');return j})),b.some(xe)?null:{params:b,fn:H}}function y(R){var H=pe(R);return H?H.restParam:!1}function x(R){return R.types.some(function(H){return H.conversion!=null})}function M(R){if(!R||R.types.length===0)return t;if(R.types.length===1)return l(R.types[0].name).test;if(R.types.length===2){var H=l(R.types[0].name).test,E=l(R.types[1].name).test;return function(G){return H(G)||E(G)}}else{var b=R.types.map(function(V){return l(V.name).test});return function(G){for(var ie=0;ie<b.length;ie++)if(b[ie](G))return!0;return!1}}}function S(R){var H,E,b;if(y(R)){H=fe(R).map(M);var V=H.length,G=M(pe(R)),ie=function(j){for(var L=V;L<j.length;L++)if(!G(j[L]))return!1;return!0};return function(L){for(var $=0;$<H.length;$++)if(!H[$](L[$]))return!1;return ie(L)&&L.length>=V+1}}else return R.length===0?function(L){return L.length===0}:R.length===1?(E=M(R[0]),function(L){return E(L[0])&&L.length===1}):R.length===2?(E=M(R[0]),b=M(R[1]),function(L){return E(L[0])&&b(L[1])&&L.length===2}):(H=R.map(M),function(L){for(var $=0;$<H.length;$++)if(!H[$](L[$]))return!1;return L.length===H.length})}function w(R,H){return H<R.params.length?R.params[H]:y(R.params)?pe(R.params):null}function C(R,H,E){var b=w(R,H),V=b?E?b.types.filter(D):b.types:[];return V.map(I)}function I(R){return R.name}function D(R){return R.conversion===null||R.conversion===void 0}function T(R,H){var E=me(he(R,function(b){return C(b,H,!1)}));return E.indexOf("any")!==-1?["any"]:E}function O(R,H,E){var b,V,G=R||"unnamed",ie=E,j;for(j=0;j<H.length;j++){var L=ie.filter(function(ce){var _e=M(w(ce,j));return(j<ce.params.length||y(ce.params))&&_e(H[j])});if(L.length===0){if(V=T(ie,j),V.length>0){var $=d(H[j]);return b=new TypeError("Unexpected type of argument in function "+G+" (expected: "+V.join(" or ")+", actual: "+$+", index: "+j+")"),b.data={category:"wrongType",fn:G,index:j,actual:$,expected:V},b}}else ie=L}var te=ie.map(function(ce){return y(ce.params)?1/0:ce.params.length});if(H.length<Math.min.apply(null,te))return V=T(ie,j),b=new TypeError("Too few arguments in function "+G+" (expected: "+V.join(" or ")+", index: "+H.length+")"),b.data={category:"tooFewArgs",fn:G,index:H.length,expected:V},b;var ue=Math.max.apply(null,te);return H.length>ue?(b=new TypeError("Too many arguments in function "+G+" (expected: "+ue+", actual: "+H.length+")"),b.data={category:"tooManyArgs",fn:G,index:H.length,expectedLength:ue},b):(b=new TypeError('Arguments of type "'+H.join(", ")+'" do not match any of the defined signatures of function '+G+"."),b.data={category:"mismatch",actual:H.map(d)},b)}function B(R){for(var H=999,E=0;E<R.types.length;E++)D(R.types[E])&&(H=Math.min(H,R.types[E].typeIndex));return H}function F(R){for(var H=999,E=0;E<R.types.length;E++)D(R.types[E])||(H=Math.min(H,R.types[E].conversionIndex));return H}function z(R,H){var E;return E=R.restParam-H.restParam,E!==0||(E=x(R)-x(H),E!==0)||(E=B(R)-B(H),E!==0)?E:F(R)-F(H)}function N(R,H){var E=Math.min(R.params.length,H.params.length),b,V;if(V=R.params.some(x)-H.params.some(x),V!==0)return V;for(b=0;b<E;b++)if(V=x(R.params[b])-x(H.params[b]),V!==0)return V;for(b=0;b<E;b++)if(V=z(R.params[b],H.params[b]),V!==0)return V;return R.params.length-H.params.length}function U(R,H){var E={};return R.forEach(function(b){H.indexOf(b.from)===-1&&H.indexOf(b.to)!==-1&&!E[b.from]&&(E[b.from]=b)}),Object.keys(E).map(function(b){return E[b]})}function Y(R,H){var E=H;if(R.some(x)){var b=y(R),V=R.map(ee);E=function(){for(var L=[],$=b?arguments.length-1:arguments.length,te=0;te<$;te++)L[te]=V[te](arguments[te]);return b&&(L[$]=arguments[$].map(V[$])),H.apply(this,L)}}var G=E;if(y(R)){var ie=R.length-1;G=function(){return E.apply(this,Pe(arguments,0,ie).concat([Pe(arguments,ie)]))}}return G}function ee(R){var H,E,b,V,G=[],ie=[];switch(R.types.forEach(function(j){j.conversion&&(G.push(l(j.conversion.from).test),ie.push(j.conversion.convert))}),ie.length){case 0:return function(L){return L};case 1:return H=G[0],b=ie[0],function(L){return H(L)?b(L):L};case 2:return H=G[0],E=G[1],b=ie[0],V=ie[1],function(L){return H(L)?b(L):E(L)?V(L):L};default:return function(L){for(var $=0;$<ie.length;$++)if(G[$](L))return ie[$](L);return L}}}function k(R){var H={};return R.forEach(function(E){E.params.some(x)||q(E.params,!0).forEach(function(b){H[_(b)]=E.fn})}),H}function q(R,H){function E(b,V,G){if(V<b.length){var ie=b[V],j=H?ie.types.filter(D):ie.types,L;if(ie.restParam){var $=j.filter(D);L=$.length<j.length?[$,j]:[j]}else L=j.map(function(ue){return[ue]});return he(L,function(ue){return E(b,V+1,G.concat([ue]))})}else{var te=G.map(function(ue,ce){return{types:ue,restParam:ce===b.length-1&&y(b)}});return[te]}}return E(R,0,[])}function oe(R,H){for(var E=Math.max(R.params.length,H.params.length),b=0;b<E;b++){var V=C(R,b,!0),G=C(H,b,!0);if(!K(V,G))return!1}var ie=R.params.length,j=H.params.length,L=y(R.params),$=y(H.params);return L?$?ie===j:j>=ie:$?ie>=j:ie===j}function se(R,H){if(Object.keys(H).length===0)throw new SyntaxError("No signatures provided");var E=[];Object.keys(H).map(function(ye){return g(ye,H[ye],c.conversions)}).filter(ve).forEach(function(ye){var Me=ae(E,function(De){return oe(De,ye)});if(Me)throw new TypeError('Conflicting signatures "'+_(Me.params)+'" and "'+_(ye.params)+'".');E.push(ye)});var b=he(E,function(ye){var Me=ye?q(ye.params,!1):[];return Me.map(function(De){return{params:De,fn:ye.fn}})}).filter(ve);b.sort(N);var V=b[0]&&b[0].params.length<=2&&!y(b[0].params),G=b[1]&&b[1].params.length<=2&&!y(b[1].params),ie=b[2]&&b[2].params.length<=2&&!y(b[2].params),j=b[3]&&b[3].params.length<=2&&!y(b[3].params),L=b[4]&&b[4].params.length<=2&&!y(b[4].params),$=b[5]&&b[5].params.length<=2&&!y(b[5].params),te=V&&G&&ie&&j&&L&&$,ue=b.map(function(ye){return S(ye.params)}),ce=V?M(b[0].params[0]):n,_e=G?M(b[1].params[0]):n,we=ie?M(b[2].params[0]):n,Fe=j?M(b[3].params[0]):n,je=L?M(b[4].params[0]):n,Ue=$?M(b[5].params[0]):n,It=V?M(b[0].params[1]):n,Dt=G?M(b[1].params[1]):n,ks=ie?M(b[2].params[1]):n,Ar=j?M(b[3].params[1]):n,Cr=L?M(b[4].params[1]):n,sn=$?M(b[5].params[1]):n,$t=b.map(function(ye){return Y(ye.params,ye.fn)}),Lr=V?$t[0]:r,Ws=G?$t[1]:r,Kn=ie?$t[2]:r,qs=j?$t[3]:r,qi=L?$t[4]:r,Rr=$?$t[5]:r,Xs=V?b[0].params.length:-1,Zs=G?b[1].params.length:-1,Ys=ie?b[2].params.length:-1,A=j?b[3].params.length:-1,W=L?b[4].params.length:-1,J=$?b[5].params.length:-1,X=te?6:0,ne=b.length,Ne=function(){for(var Me=X;Me<ne;Me++)if(ue[Me](arguments))return $t[Me].apply(this,arguments);throw O(R,arguments,b)},Ae=function ye(Me,De){return arguments.length===Xs&&ce(Me)&&It(De)?Lr.apply(ye,arguments):arguments.length===Zs&&_e(Me)&&Dt(De)?Ws.apply(ye,arguments):arguments.length===Ys&&we(Me)&&ks(De)?Kn.apply(ye,arguments):arguments.length===A&&Fe(Me)&&Ar(De)?qs.apply(ye,arguments):arguments.length===W&&je(Me)&&Cr(De)?qi.apply(ye,arguments):arguments.length===J&&Ue(Me)&&sn(De)?Rr.apply(ye,arguments):Ne.apply(ye,arguments)};try{Object.defineProperty(Ae,"name",{value:R})}catch{}return Ae.signatures=k(b),Ae}function de(R){return c.ignore.indexOf(R)===-1}function Se(R){return R.trim()}function Q(R){return!!R}function ve(R){return R!==null}function xe(R){return R.types.length===0}function fe(R){return R.slice(0,R.length-1)}function pe(R){return R[R.length-1]}function Pe(R,H,E){return Array.prototype.slice.call(R,H,E)}function Z(R,H){return R.indexOf(H)!==-1}function K(R,H){for(var E=0;E<R.length;E++)if(Z(H,R[E]))return!0;return!1}function ae(R,H){for(var E=0;E<R.length;E++)if(H(R[E]))return R[E]}function me(R){for(var H={},E=0;E<R.length;E++)H[R[E]]=!0;return Object.keys(H)}function he(R,H){return Array.prototype.concat.apply([],R.map(H))}function Te(R){for(var H="",E=0;E<R.length;E++){var b=R[E];if((typeof b.signatures=="object"||typeof b.signature=="string")&&b.name!==""){if(H==="")H=b.name;else if(H!==b.name){var V=new Error("Function names do not match (expected: "+H+", actual: "+b.name+")");throw V.data={actual:b.name,expected:H},V}}}return H}function Le(R){var H,E={};function b(j,L){if(E.hasOwnProperty(j)&&L!==E[j])throw H=new Error('Signature "'+j+'" is defined twice'),H.data={signature:j},H}for(var V=0;V<R.length;V++){var G=R[V];if(typeof G.signatures=="object")for(var ie in G.signatures)G.signatures.hasOwnProperty(ie)&&(b(ie,G.signatures[ie]),E[ie]=G.signatures[ie]);else if(typeof G.signature=="string")b(G.signature,G),E[G.signature]=G;else throw H=new TypeError("Function is no typed-function (index: "+V+")"),H.data={index:V},H}return E}return c=se("typed",{"string, Object":se,Object:function(R){var H=[];for(var E in R)R.hasOwnProperty(E)&&H.push(R[E]);var b=Te(H);return se(b,R)},"...Function":function(R){return se(Te(R),Le(R))},"string, ...Function":function(R,H){return se(R,Le(H))}}),c.create=s,c.types=a,c.conversions=h,c.ignore=u,c.convert=m,c.find=v,c.addType=function(R,H){if(!R||typeof R.name!="string"||typeof R.test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");if(H!==!1){for(var E=0;E<c.types.length;E++)if(c.types[E].name==="Object"){c.types.splice(E,0,R);return}}c.types.push(R)},c.addConversion=function(R){if(!R||typeof R.from!="string"||typeof R.to!="string"||typeof R.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");c.conversions.push(R)},c}return s()})})(gu);var vu=gu.exports;function vt(i){return typeof i=="boolean"?!0:isFinite(i)?i===Math.round(i):!1}function Mo(i,e,t){var n={2:"0b",8:"0o",16:"0x"},r=n[e],s="";if(t){if(t<1)throw new Error("size must be in greater than 0");if(!vt(t))throw new Error("size must be an integer");if(i>2**(t-1)-1||i<-(2**(t-1)))throw new Error("Value must be in range [-2^".concat(t-1,", 2^").concat(t-1,"-1]"));if(!vt(i))throw new Error("Value must be an integer");i<0&&(i=i+2**t),s="i".concat(t)}var a="";return i<0&&(i=-i,a="-"),"".concat(a).concat(r).concat(i.toString(e)).concat(s)}function bo(i,e){if(typeof e=="function")return e(i);if(i===1/0)return"Infinity";if(i===-1/0)return"-Infinity";if(isNaN(i))return"NaN";var t="auto",n,r;if(e&&(e.notation&&(t=e.notation),nt(e)?n=e:nt(e.precision)&&(n=e.precision),e.wordSize&&(r=e.wordSize,typeof r!="number")))throw new Error('Option "wordSize" must be a number');switch(t){case"fixed":return D_(i,n);case"exponential":return _u(i,n);case"engineering":return I_(i,n);case"bin":return Mo(i,2,r);case"oct":return Mo(i,8,r);case"hex":return Mo(i,16,r);case"auto":return F_(i,n,e&&e).replace(/((\.\d*?)(0+))($|e)/,function(){var s=arguments[2],a=arguments[4];return s!=="."?s+a:a});default:throw new Error('Unknown notation "'+t+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function Rs(i){var e=String(i).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!e)throw new SyntaxError("Invalid number "+i);var t=e[1],n=e[2],r=parseFloat(e[4]||"0"),s=n.indexOf(".");r+=s!==-1?s-1:n.length-1;var a=n.replace(".","").replace(/^0*/,function(o){return r-=o.length,""}).replace(/0*$/,"").split("").map(function(o){return parseInt(o)});return a.length===0&&(a.push(0),r++),{sign:t,coefficients:a,exponent:r}}function I_(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Rs(i),n=Ps(t,e),r=n.exponent,s=n.coefficients,a=r%3==0?r:r<0?r-3-r%3:r-r%3;if(nt(e))for(;e>s.length||r-a+1>s.length;)s.push(0);else for(var o=Math.abs(r-a)-(s.length-1),u=0;u<o;u++)s.push(0);for(var h=Math.abs(r-a),c=1;h>0;)c++,h--;var l=s.slice(c).join(""),f=nt(e)&&l.length||l.match(/[1-9]/)?"."+l:"",d=s.slice(0,c).join("")+f+"e"+(r>=0?"+":"")+a.toString();return n.sign+d}function D_(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Rs(i),n=typeof e=="number"?Ps(t,t.exponent+1+e):t,r=n.coefficients,s=n.exponent+1,a=s+(e||0);return r.length<a&&(r=r.concat(Ui(a-r.length))),s<0&&(r=Ui(-s+1).concat(r),s=1),s<r.length&&r.splice(s,0,s===0?"0.":"."),n.sign+r.join("")}function _u(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Rs(i),n=e?Ps(t,e):t,r=n.coefficients,s=n.exponent;r.length<e&&(r=r.concat(Ui(e-r.length)));var a=r.shift();return n.sign+a+(r.length>0?"."+r.join(""):"")+"e"+(s>=0?"+":"")+s}function F_(i,e,t){if(isNaN(i)||!isFinite(i))return String(i);var n=t&&t.lowerExp!==void 0?t.lowerExp:-3,r=t&&t.upperExp!==void 0?t.upperExp:5,s=Rs(i),a=e?Ps(s,e):s;if(a.exponent<n||a.exponent>=r)return _u(i,e);var o=a.coefficients,u=a.exponent;o.length<e&&(o=o.concat(Ui(e-o.length))),o=o.concat(Ui(u-o.length+1+(o.length<e?e-o.length:0))),o=Ui(-u).concat(o);var h=u>0?u:0;return h<o.length-1&&o.splice(h+1,0,"."),a.sign+o.join("")}function Ps(i,e){for(var t={sign:i.sign,coefficients:i.coefficients,exponent:i.exponent},n=t.coefficients;e<=0;)n.unshift(0),t.exponent++,e++;if(n.length>e){var r=n.splice(e,n.length-e);if(r[0]>=5){var s=e-1;for(n[s]++;n[s]===10;)n.pop(),s===0&&(n.unshift(0),t.exponent++,s++),s--,n[s]++}}return t}function Ui(i){for(var e=[],t=0;t<i;t++)e.push(0);return e}function z_(i){return i.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length}var B_=Number.EPSILON||2220446049250313e-31;function Ns(i,e,t){if(t==null)return i===e;if(i===e)return!0;if(isNaN(i)||isNaN(e))return!1;if(isFinite(i)&&isFinite(e)){var n=Math.abs(i-e);return n<B_?!0:n<=Math.max(Math.abs(i),Math.abs(e))*t}return!1}function So(i,e,t){var n=i.constructor,r=new n(2),s="";if(t){if(t<1)throw new Error("size must be in greater than 0");if(!vt(t))throw new Error("size must be an integer");if(i.greaterThan(r.pow(t-1).sub(1))||i.lessThan(r.pow(t-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(t-1,", 2^").concat(t-1,"-1]"));if(!i.isInteger())throw new Error("Value must be an integer");i.lessThan(0)&&(i=i.add(r.pow(t))),s="i".concat(t)}switch(e){case 2:return"".concat(i.toBinary()).concat(s);case 8:return"".concat(i.toOctal()).concat(s);case 16:return"".concat(i.toHexadecimal()).concat(s);default:throw new Error("Base ".concat(e," not supported "))}}function O_(i,e){if(typeof e=="function")return e(i);if(!i.isFinite())return i.isNaN()?"NaN":i.gt(0)?"Infinity":"-Infinity";var t="auto",n,r;if(e!==void 0&&(e.notation&&(t=e.notation),typeof e=="number"?n=e:e.precision&&(n=e.precision),e.wordSize&&(r=e.wordSize,typeof r!="number")))throw new Error('Option "wordSize" must be a number');switch(t){case"fixed":return V_(i,n);case"exponential":return yu(i,n);case"engineering":return U_(i,n);case"bin":return So(i,2,r);case"oct":return So(i,8,r);case"hex":return So(i,16,r);case"auto":{var s=e&&e.lowerExp!==void 0?e.lowerExp:-3,a=e&&e.upperExp!==void 0?e.upperExp:5;if(i.isZero())return"0";var o,u=i.toSignificantDigits(n),h=u.e;return h>=s&&h<a?o=u.toFixed():o=yu(i,n),o.replace(/((\.\d*?)(0+))($|e)/,function(){var c=arguments[2],l=arguments[4];return c!=="."?c+l:l})}default:throw new Error('Unknown notation "'+t+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function U_(i,e){var t=i.e,n=t%3==0?t:t<0?t-3-t%3:t-t%3,r=i.mul(Math.pow(10,-n)),s=r.toPrecision(e);return s.indexOf("e")!==-1&&(s=r.toString()),s+"e"+(t>=0?"+":"")+n.toString()}function yu(i,e){return e!==void 0?i.toExponential(e-1):i.toExponential()}function V_(i,e){return i.toFixed(e)}function Rt(i,e){if(typeof i=="number")return bo(i,e);if(Yt(i))return O_(i,e);if(H_(i))return!e||e.fraction!=="decimal"?i.s*i.n+"/"+i.d:i.toString();if(Array.isArray(i))return xu(i,e);if(dn(i))return'"'+i+'"';if(typeof i=="function")return i.syntax?String(i.syntax):"function";if(i&&typeof i=="object"){if(typeof i.format=="function")return i.format(e);if(i&&i.toString(e)!=={}.toString())return i.toString(e);var t=Object.keys(i).map(n=>'"'+n+'": '+Rt(i[n],e));return"{"+t.join(", ")+"}"}return String(i)}function xu(i,e){if(Array.isArray(i)){for(var t="[",n=i.length,r=0;r<n;r++)r!==0&&(t+=", "),t+=xu(i[r],e);return t+="]",t}else return Rt(i,e)}function H_(i){return i&&typeof i=="object"&&typeof i.s=="number"&&typeof i.n=="number"&&typeof i.d=="number"||!1}function Ke(i,e,t){if(!(this instanceof Ke))throw new SyntaxError("Constructor must be called with the new operator");this.actual=i,this.expected=e,this.relation=t,this.message="Dimension mismatch ("+(Array.isArray(i)?"["+i.join(", ")+"]":i)+" "+(this.relation||"!=")+" "+(Array.isArray(e)?"["+e.join(", ")+"]":e)+")",this.stack=new Error().stack}Ke.prototype=new RangeError;Ke.prototype.constructor=RangeError;Ke.prototype.name="DimensionError";Ke.prototype.isDimensionError=!0;function Vi(i,e,t){if(!(this instanceof Vi))throw new SyntaxError("Constructor must be called with the new operator");this.index=i,arguments.length<3?(this.min=0,this.max=e):(this.min=e,this.max=t),this.min!==void 0&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":this.max!==void 0&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=new Error().stack}Vi.prototype=new RangeError;Vi.prototype.constructor=RangeError;Vi.prototype.name="IndexError";Vi.prototype.isIndexError=!0;function Qn(i){for(var e=[];Array.isArray(i);)e.push(i.length),i=i[0];return e}function wu(i,e,t){var n,r=i.length;if(r!==e[t])throw new Ke(r,e[t]);if(t<e.length-1){var s=t+1;for(n=0;n<r;n++){var a=i[n];if(!Array.isArray(a))throw new Ke(e.length-1,e.length,"<");wu(i[n],e,s)}}else for(n=0;n<r;n++)if(Array.isArray(i[n]))throw new Ke(e.length+1,e.length,">")}function Mu(i,e){var t=e.length===0;if(t){if(Array.isArray(i))throw new Ke(i.length,0)}else wu(i,e,0)}function at(i,e){if(!nt(i)||!vt(i))throw new TypeError("Index must be an integer (value: "+i+")");if(i<0||typeof e=="number"&&i>=e)throw new Vi(i,e)}function bu(i,e,t){if(!Array.isArray(i)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new Error("Resizing to scalar is not supported");e.forEach(function(r){if(!nt(r)||!vt(r)||r<0)throw new TypeError("Invalid size, must contain positive integers (size: "+Rt(e)+")")});var n=t!==void 0?t:0;return Eo(i,e,0,n),i}function Eo(i,e,t,n){var r,s,a=i.length,o=e[t],u=Math.min(a,o);if(i.length=o,t<e.length-1){var h=t+1;for(r=0;r<u;r++)s=i[r],Array.isArray(s)||(s=[s],i[r]=s),Eo(s,e,h,n);for(r=u;r<o;r++)s=[],i[r]=s,Eo(s,e,h,n)}else{for(r=0;r<u;r++)for(;Array.isArray(i[r]);)i[r]=i[r][0];for(r=u;r<o;r++)i[r]=n}}function G_(i,e){var t=W_(i),n=t.length;if(!Array.isArray(i)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new Ke(0,n,"!=");e=To(e,n);var r=Su(e);if(n!==r)throw new Ke(r,n,"!=");try{return k_(t,e)}catch(s){throw s instanceof Ke?new Ke(r,n,"!="):s}}function To(i,e){var t=Su(i),n=i.slice(),r=-1,s=i.indexOf(r),a=i.indexOf(r,s+1)>=0;if(a)throw new Error("More than one wildcard in sizes");var o=s>=0,u=e%t==0;if(o)if(u)n[s]=-e/t;else throw new Error("Could not replace wildcard, since "+e+" is no multiple of "+-t);return n}function Su(i){return i.reduce((e,t)=>e*t,1)}function k_(i,e){for(var t=i,n,r=e.length-1;r>0;r--){var s=e[r];n=[];for(var a=t.length/s,o=0;o<a;o++)n.push(t.slice(o*s,(o+1)*s));t=n}return t}function Eu(i,e,t,n){var r=n||Qn(i);if(t)for(var s=0;s<t;s++)i=[i],r.unshift(1);for(i=Tu(i,e,0);r.length<e;)r.push(1);return i}function Tu(i,e,t){var n,r;if(Array.isArray(i)){var s=t+1;for(n=0,r=i.length;n<r;n++)i[n]=Tu(i[n],e,s)}else for(var a=t;a<e;a++)i=[i];return i}function W_(i){if(!Array.isArray(i))return i;var e=[];return i.forEach(function t(n){Array.isArray(n)?n.forEach(t):e.push(n)}),e}function Is(i,e){for(var t,n=0,r=0;r<i.length;r++){var s=i[r],a=Array.isArray(s);if(r===0&&a&&(n=s.length),a&&s.length!==n)return;var o=a?Is(s,e):e(s);if(t===void 0)t=o;else if(t!==o)return"mixed"}return t}function ft(i,e,t,n){function r(s){var a=L_(s,e.map(Z_));return q_(i,e,s),t(a)}return r.isFactory=!0,r.fn=i,r.dependencies=e.slice().sort(),n&&(r.meta=n),r}function q_(i,e,t){var n=e.filter(s=>!X_(s)).every(s=>t[s]!==void 0);if(!n){var r=e.filter(s=>t[s]===void 0);throw new Error('Cannot create function "'.concat(i,'", ')+"some dependencies are missing: ".concat(r.map(s=>'"'.concat(s,'"')).join(", "),"."))}}function X_(i){return i&&i[0]==="?"}function Z_(i){return i&&i[0]==="?"?i.slice(1):i}function Y_(i,e){if(Cu(i)&&Au(i,e))return i[e];throw typeof i[e]=="function"&&$_(i,e)?new Error('Cannot access method "'+e+'" as a property'):new Error('No access to property "'+e+'"')}function J_(i,e,t){if(Cu(i)&&Au(i,e))return i[e]=t,t;throw new Error('No access to property "'+e+'"')}function j_(i,e){return e in i}function Au(i,e){return!i||typeof i!="object"?!1:Er(Q_,e)?!0:!(e in Object.prototype||e in Function.prototype)}function $_(i,e){return i==null||typeof i[e]!="function"||Er(i,e)&&Object.getPrototypeOf&&e in Object.getPrototypeOf(i)?!1:Er(K_,e)?!0:!(e in Object.prototype||e in Function.prototype)}function Cu(i){return typeof i=="object"&&i&&i.constructor===Object}var Q_={length:!0,name:!0},K_={toString:!0,valueOf:!0,toLocaleString:!0};class ey{constructor(e){this.wrappedObject=e}keys(){return Object.keys(this.wrappedObject)}get(e){return Y_(this.wrappedObject,e)}set(e,t){return J_(this.wrappedObject,e,t),this}has(e){return j_(this.wrappedObject,e)}}function ty(i){return i?i instanceof Map||i instanceof ey||typeof i.set=="function"&&typeof i.get=="function"&&typeof i.keys=="function"&&typeof i.has=="function":!1}var Lu=function(){return Lu=vu.create,vu},ny=["?BigNumber","?Complex","?DenseMatrix","?Fraction"],iy=ft("typed",ny,function(e){var{BigNumber:t,Complex:n,DenseMatrix:r,Fraction:s}=e,a=Lu();return a.types=[{name:"number",test:nt},{name:"Complex",test:yo},{name:"BigNumber",test:Yt},{name:"Fraction",test:xo},{name:"Unit",test:wo},{name:"string",test:dn},{name:"Chain",test:pu},{name:"Array",test:Qe},{name:"Matrix",test:Et},{name:"DenseMatrix",test:r_},{name:"SparseMatrix",test:s_},{name:"Range",test:uu},{name:"Index",test:As},{name:"boolean",test:a_},{name:"ResultSet",test:hu},{name:"Help",test:fu},{name:"function",test:o_},{name:"Date",test:l_},{name:"RegExp",test:c_},{name:"null",test:h_},{name:"undefined",test:f_},{name:"AccessorNode",test:d_},{name:"ArrayNode",test:p_},{name:"AssignmentNode",test:m_},{name:"BlockNode",test:g_},{name:"ConditionalNode",test:v_},{name:"ConstantNode",test:__},{name:"FunctionNode",test:x_},{name:"FunctionAssignmentNode",test:y_},{name:"IndexNode",test:w_},{name:"Node",test:du},{name:"ObjectNode",test:M_},{name:"OperatorNode",test:b_},{name:"ParenthesisNode",test:S_},{name:"RangeNode",test:E_},{name:"SymbolNode",test:T_},{name:"Map",test:ty},{name:"Object",test:u_}],a.conversions=[{from:"number",to:"BigNumber",convert:function(u){if(t||Ao(u),z_(u)>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+u+"). Use function bignumber(x) to convert to BigNumber.");return new t(u)}},{from:"number",to:"Complex",convert:function(u){return n||Ds(u),new n(u,0)}},{from:"number",to:"string",convert:function(u){return u+""}},{from:"BigNumber",to:"Complex",convert:function(u){return n||Ds(u),new n(u.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(u){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(u){return n||Ds(u),new n(u.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(u){s||Co(u);var h=new s(u);if(h.valueOf()!==u)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+u+"). Use function fraction(x) to convert to Fraction.");return h}},{from:"string",to:"number",convert:function(u){var h=Number(u);if(isNaN(h))throw new Error('Cannot convert "'+u+'" to a number');return h}},{from:"string",to:"BigNumber",convert:function(u){t||Ao(u);try{return new t(u)}catch{throw new Error('Cannot convert "'+u+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(u){s||Co(u);try{return new s(u)}catch{throw new Error('Cannot convert "'+u+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(u){n||Ds(u);try{return new n(u)}catch{throw new Error('Cannot convert "'+u+'" to Complex')}}},{from:"boolean",to:"number",convert:function(u){return+u}},{from:"boolean",to:"BigNumber",convert:function(u){return t||Ao(u),new t(+u)}},{from:"boolean",to:"Fraction",convert:function(u){return s||Co(u),new s(+u)}},{from:"boolean",to:"string",convert:function(u){return String(u)}},{from:"Array",to:"Matrix",convert:function(u){return r||ry(),new r(u)}},{from:"Matrix",to:"Array",convert:function(u){return u.valueOf()}}],a});function Ao(i){throw new Error("Cannot convert value ".concat(i," into a BigNumber: no class 'BigNumber' provided"))}function Ds(i){throw new Error("Cannot convert value ".concat(i," into a Complex number: no class 'Complex' provided"))}function ry(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}function Co(i){throw new Error("Cannot convert value ".concat(i," into a Fraction, no class 'Fraction' provided."))}var Hi=9e15,Dn=1e9,Lo="0123456789abcdef",Fs="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",zs="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Ro={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Hi,maxE:Hi,crypto:!1},Ru,pn,Ie=!0,Bs="[DecimalError] ",Fn=Bs+"Invalid argument: ",Pu=Bs+"Precision limit exceeded",Nu=Bs+"crypto unavailable",Iu="[object Decimal]",Mt=Math.floor,ct=Math.pow,sy=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,ay=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,oy=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Du=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,Jt=1e7,Ce=7,ly=9007199254740991,cy=Fs.length-1,Po=zs.length-1,re={toStringTag:Iu};re.absoluteValue=re.abs=function(){var i=new this.constructor(this);return i.s<0&&(i.s=1),be(i)};re.ceil=function(){return be(new this.constructor(this),this.e+1,2)};re.clampedTo=re.clamp=function(i,e){var t,n=this,r=n.constructor;if(i=new r(i),e=new r(e),!i.s||!e.s)return new r(NaN);if(i.gt(e))throw Error(Fn+e);return t=n.cmp(i),t<0?i:n.cmp(e)>0?e:new r(n)};re.comparedTo=re.cmp=function(i){var e,t,n,r,s=this,a=s.d,o=(i=new s.constructor(i)).d,u=s.s,h=i.s;if(!a||!o)return!u||!h?NaN:u!==h?u:a===o?0:!a^u<0?1:-1;if(!a[0]||!o[0])return a[0]?u:o[0]?-h:0;if(u!==h)return u;if(s.e!==i.e)return s.e>i.e^u<0?1:-1;for(n=a.length,r=o.length,e=0,t=n<r?n:r;e<t;++e)if(a[e]!==o[e])return a[e]>o[e]^u<0?1:-1;return n===r?0:n>r^u<0?1:-1};re.cosine=re.cos=function(){var i,e,t=this,n=t.constructor;return t.d?t.d[0]?(i=n.precision,e=n.rounding,n.precision=i+Math.max(t.e,t.sd())+Ce,n.rounding=1,t=uy(n,Vu(n,t)),n.precision=i,n.rounding=e,be(pn==2||pn==3?t.neg():t,i,e,!0)):new n(1):new n(NaN)};re.cubeRoot=re.cbrt=function(){var i,e,t,n,r,s,a,o,u,h,c=this,l=c.constructor;if(!c.isFinite()||c.isZero())return new l(c);for(Ie=!1,s=c.s*ct(c.s*c,1/3),!s||Math.abs(s)==1/0?(t=_t(c.d),i=c.e,(s=(i-t.length+1)%3)&&(t+=s==1||s==-2?"0":"00"),s=ct(t,1/3),i=Mt((i+1)/3)-(i%3==(i<0?-1:2)),s==1/0?t="5e"+i:(t=s.toExponential(),t=t.slice(0,t.indexOf("e")+1)+i),n=new l(t),n.s=c.s):n=new l(s.toString()),a=(i=l.precision)+3;;)if(o=n,u=o.times(o).times(o),h=u.plus(c),n=qe(h.plus(c).times(o),h.plus(u),a+2,1),_t(o.d).slice(0,a)===(t=_t(n.d)).slice(0,a))if(t=t.slice(a-3,a+1),t=="9999"||!r&&t=="4999"){if(!r&&(be(o,i+1,0),o.times(o).times(o).eq(c))){n=o;break}a+=4,r=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(be(n,i+1,1),e=!n.times(n).times(n).eq(c));break}return Ie=!0,be(n,i,l.rounding,e)};re.decimalPlaces=re.dp=function(){var i,e=this.d,t=NaN;if(e){if(i=e.length-1,t=(i-Mt(this.e/Ce))*Ce,i=e[i],i)for(;i%10==0;i/=10)t--;t<0&&(t=0)}return t};re.dividedBy=re.div=function(i){return qe(this,new this.constructor(i))};re.dividedToIntegerBy=re.divToInt=function(i){var e=this,t=e.constructor;return be(qe(e,new t(i),0,1,1),t.precision,t.rounding)};re.equals=re.eq=function(i){return this.cmp(i)===0};re.floor=function(){return be(new this.constructor(this),this.e+1,3)};re.greaterThan=re.gt=function(i){return this.cmp(i)>0};re.greaterThanOrEqualTo=re.gte=function(i){var e=this.cmp(i);return e==1||e===0};re.hyperbolicCosine=re.cosh=function(){var i,e,t,n,r,s=this,a=s.constructor,o=new a(1);if(!s.isFinite())return new a(s.s?1/0:NaN);if(s.isZero())return o;t=a.precision,n=a.rounding,a.precision=t+Math.max(s.e,s.sd())+4,a.rounding=1,r=s.d.length,r<32?(i=Math.ceil(r/3),e=(1/Hs(4,i)).toString()):(i=16,e="2.3283064365386962890625e-10"),s=Gi(a,1,s.times(e),new a(1),!0);for(var u,h=i,c=new a(8);h--;)u=s.times(s),s=o.minus(u.times(c.minus(u.times(c))));return be(s,a.precision=t,a.rounding=n,!0)};re.hyperbolicSine=re.sinh=function(){var i,e,t,n,r=this,s=r.constructor;if(!r.isFinite()||r.isZero())return new s(r);if(e=s.precision,t=s.rounding,s.precision=e+Math.max(r.e,r.sd())+4,s.rounding=1,n=r.d.length,n<3)r=Gi(s,2,r,r,!0);else{i=1.4*Math.sqrt(n),i=i>16?16:i|0,r=r.times(1/Hs(5,i)),r=Gi(s,2,r,r,!0);for(var a,o=new s(5),u=new s(16),h=new s(20);i--;)a=r.times(r),r=r.times(o.plus(a.times(u.times(a).plus(h))))}return s.precision=e,s.rounding=t,be(r,e,t,!0)};re.hyperbolicTangent=re.tanh=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+7,n.rounding=1,qe(t.sinh(),t.cosh(),n.precision=i,n.rounding=e)):new n(t.s)};re.inverseCosine=re.acos=function(){var i,e=this,t=e.constructor,n=e.abs().cmp(1),r=t.precision,s=t.rounding;return n!==-1?n===0?e.isNeg()?jt(t,r,s):new t(0):new t(NaN):e.isZero()?jt(t,r+4,s).times(.5):(t.precision=r+6,t.rounding=1,e=e.asin(),i=jt(t,r+4,s).times(.5),t.precision=r,t.rounding=s,i.minus(e))};re.inverseHyperbolicCosine=re.acosh=function(){var i,e,t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(i=n.precision,e=n.rounding,n.precision=i+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,Ie=!1,t=t.times(t).minus(1).sqrt().plus(t),Ie=!0,n.precision=i,n.rounding=e,t.ln()):new n(t)};re.inverseHyperbolicSine=re.asinh=function(){var i,e,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,Ie=!1,t=t.times(t).plus(1).sqrt().plus(t),Ie=!0,n.precision=i,n.rounding=e,t.ln())};re.inverseHyperbolicTangent=re.atanh=function(){var i,e,t,n,r=this,s=r.constructor;return r.isFinite()?r.e>=0?new s(r.abs().eq(1)?r.s/0:r.isZero()?r:NaN):(i=s.precision,e=s.rounding,n=r.sd(),Math.max(n,i)<2*-r.e-1?be(new s(r),i,e,!0):(s.precision=t=n-r.e,r=qe(r.plus(1),new s(1).minus(r),t+i,1),s.precision=i+4,s.rounding=1,r=r.ln(),s.precision=i,s.rounding=e,r.times(.5))):new s(NaN)};re.inverseSine=re.asin=function(){var i,e,t,n,r=this,s=r.constructor;return r.isZero()?new s(r):(e=r.abs().cmp(1),t=s.precision,n=s.rounding,e!==-1?e===0?(i=jt(s,t+4,n).times(.5),i.s=r.s,i):new s(NaN):(s.precision=t+6,s.rounding=1,r=r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(),s.precision=t,s.rounding=n,r.times(2)))};re.inverseTangent=re.atan=function(){var i,e,t,n,r,s,a,o,u,h=this,c=h.constructor,l=c.precision,f=c.rounding;if(h.isFinite()){if(h.isZero())return new c(h);if(h.abs().eq(1)&&l+4<=Po)return a=jt(c,l+4,f).times(.25),a.s=h.s,a}else{if(!h.s)return new c(NaN);if(l+4<=Po)return a=jt(c,l+4,f).times(.5),a.s=h.s,a}for(c.precision=o=l+10,c.rounding=1,t=Math.min(28,o/Ce+2|0),i=t;i;--i)h=h.div(h.times(h).plus(1).sqrt().plus(1));for(Ie=!1,e=Math.ceil(o/Ce),n=1,u=h.times(h),a=new c(h),r=h;i!==-1;)if(r=r.times(u),s=a.minus(r.div(n+=2)),r=r.times(u),a=s.plus(r.div(n+=2)),a.d[e]!==void 0)for(i=e;a.d[i]===s.d[i]&&i--;);return t&&(a=a.times(2<<t-1)),Ie=!0,be(a,c.precision=l,c.rounding=f,!0)};re.isFinite=function(){return!!this.d};re.isInteger=re.isInt=function(){return!!this.d&&Mt(this.e/Ce)>this.d.length-2};re.isNaN=function(){return!this.s};re.isNegative=re.isNeg=function(){return this.s<0};re.isPositive=re.isPos=function(){return this.s>0};re.isZero=function(){return!!this.d&&this.d[0]===0};re.lessThan=re.lt=function(i){return this.cmp(i)<0};re.lessThanOrEqualTo=re.lte=function(i){return this.cmp(i)<1};re.logarithm=re.log=function(i){var e,t,n,r,s,a,o,u,h=this,c=h.constructor,l=c.precision,f=c.rounding,d=5;if(i==null)i=new c(10),e=!0;else{if(i=new c(i),t=i.d,i.s<0||!t||!t[0]||i.eq(1))return new c(NaN);e=i.eq(10)}if(t=h.d,h.s<0||!t||!t[0]||h.eq(1))return new c(t&&!t[0]?-1/0:h.s!=1?NaN:t?0:1/0);if(e)if(t.length>1)s=!0;else{for(r=t[0];r%10==0;)r/=10;s=r!==1}if(Ie=!1,o=l+d,a=Bn(h,o),n=e?Vs(c,o+10):Bn(i,o),u=qe(a,n,o,1),Tr(u.d,r=l,f))do if(o+=10,a=Bn(h,o),n=e?Vs(c,o+10):Bn(i,o),u=qe(a,n,o,1),!s){+_t(u.d).slice(r+1,r+15)+1==1e14&&(u=be(u,l+1,0));break}while(Tr(u.d,r+=10,f));return Ie=!0,be(u,l,f)};re.minus=re.sub=function(i){var e,t,n,r,s,a,o,u,h,c,l,f,d=this,v=d.constructor;if(i=new v(i),!d.d||!i.d)return!d.s||!i.s?i=new v(NaN):d.d?i.s=-i.s:i=new v(i.d||d.s!==i.s?d:NaN),i;if(d.s!=i.s)return i.s=-i.s,d.plus(i);if(h=d.d,f=i.d,o=v.precision,u=v.rounding,!h[0]||!f[0]){if(f[0])i.s=-i.s;else if(h[0])i=new v(d);else return new v(u===3?-0:0);return Ie?be(i,o,u):i}if(t=Mt(i.e/Ce),c=Mt(d.e/Ce),h=h.slice(),s=c-t,s){for(l=s<0,l?(e=h,s=-s,a=f.length):(e=f,t=c,a=h.length),n=Math.max(Math.ceil(o/Ce),a)+2,s>n&&(s=n,e.length=1),e.reverse(),n=s;n--;)e.push(0);e.reverse()}else{for(n=h.length,a=f.length,l=n<a,l&&(a=n),n=0;n<a;n++)if(h[n]!=f[n]){l=h[n]<f[n];break}s=0}for(l&&(e=h,h=f,f=e,i.s=-i.s),a=h.length,n=f.length-a;n>0;--n)h[a++]=0;for(n=f.length;n>s;){if(h[--n]<f[n]){for(r=n;r&&h[--r]===0;)h[r]=Jt-1;--h[r],h[n]+=Jt}h[n]-=f[n]}for(;h[--a]===0;)h.pop();for(;h[0]===0;h.shift())--t;return h[0]?(i.d=h,i.e=Us(h,t),Ie?be(i,o,u):i):new v(u===3?-0:0)};re.modulo=re.mod=function(i){var e,t=this,n=t.constructor;return i=new n(i),!t.d||!i.s||i.d&&!i.d[0]?new n(NaN):!i.d||t.d&&!t.d[0]?be(new n(t),n.precision,n.rounding):(Ie=!1,n.modulo==9?(e=qe(t,i.abs(),0,3,1),e.s*=i.s):e=qe(t,i,0,n.modulo,1),e=e.times(i),Ie=!0,t.minus(e))};re.naturalExponential=re.exp=function(){return No(this)};re.naturalLogarithm=re.ln=function(){return Bn(this)};re.negated=re.neg=function(){var i=new this.constructor(this);return i.s=-i.s,be(i)};re.plus=re.add=function(i){var e,t,n,r,s,a,o,u,h,c,l=this,f=l.constructor;if(i=new f(i),!l.d||!i.d)return!l.s||!i.s?i=new f(NaN):l.d||(i=new f(i.d||l.s===i.s?l:NaN)),i;if(l.s!=i.s)return i.s=-i.s,l.minus(i);if(h=l.d,c=i.d,o=f.precision,u=f.rounding,!h[0]||!c[0])return c[0]||(i=new f(l)),Ie?be(i,o,u):i;if(s=Mt(l.e/Ce),n=Mt(i.e/Ce),h=h.slice(),r=s-n,r){for(r<0?(t=h,r=-r,a=c.length):(t=c,n=s,a=h.length),s=Math.ceil(o/Ce),a=s>a?s+1:a+1,r>a&&(r=a,t.length=1),t.reverse();r--;)t.push(0);t.reverse()}for(a=h.length,r=c.length,a-r<0&&(r=a,t=c,c=h,h=t),e=0;r;)e=(h[--r]=h[r]+c[r]+e)/Jt|0,h[r]%=Jt;for(e&&(h.unshift(e),++n),a=h.length;h[--a]==0;)h.pop();return i.d=h,i.e=Us(h,n),Ie?be(i,o,u):i};re.precision=re.sd=function(i){var e,t=this;if(i!==void 0&&i!==!!i&&i!==1&&i!==0)throw Error(Fn+i);return t.d?(e=Fu(t.d),i&&t.e+1>e&&(e=t.e+1)):e=NaN,e};re.round=function(){var i=this,e=i.constructor;return be(new e(i),i.e+1,e.rounding)};re.sine=re.sin=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+Math.max(t.e,t.sd())+Ce,n.rounding=1,t=fy(n,Vu(n,t)),n.precision=i,n.rounding=e,be(pn>2?t.neg():t,i,e,!0)):new n(NaN)};re.squareRoot=re.sqrt=function(){var i,e,t,n,r,s,a=this,o=a.d,u=a.e,h=a.s,c=a.constructor;if(h!==1||!o||!o[0])return new c(!h||h<0&&(!o||o[0])?NaN:o?a:1/0);for(Ie=!1,h=Math.sqrt(+a),h==0||h==1/0?(e=_t(o),(e.length+u)%2==0&&(e+="0"),h=Math.sqrt(e),u=Mt((u+1)/2)-(u<0||u%2),h==1/0?e="5e"+u:(e=h.toExponential(),e=e.slice(0,e.indexOf("e")+1)+u),n=new c(e)):n=new c(h.toString()),t=(u=c.precision)+3;;)if(s=n,n=s.plus(qe(a,s,t+2,1)).times(.5),_t(s.d).slice(0,t)===(e=_t(n.d)).slice(0,t))if(e=e.slice(t-3,t+1),e=="9999"||!r&&e=="4999"){if(!r&&(be(s,u+1,0),s.times(s).eq(a))){n=s;break}t+=4,r=1}else{(!+e||!+e.slice(1)&&e.charAt(0)=="5")&&(be(n,u+1,1),i=!n.times(n).eq(a));break}return Ie=!0,be(n,u,c.rounding,i)};re.tangent=re.tan=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+10,n.rounding=1,t=t.sin(),t.s=1,t=qe(t,new n(1).minus(t.times(t)).sqrt(),i+10,0),n.precision=i,n.rounding=e,be(pn==2||pn==4?t.neg():t,i,e,!0)):new n(NaN)};re.times=re.mul=function(i){var e,t,n,r,s,a,o,u,h,c=this,l=c.constructor,f=c.d,d=(i=new l(i)).d;if(i.s*=c.s,!f||!f[0]||!d||!d[0])return new l(!i.s||f&&!f[0]&&!d||d&&!d[0]&&!f?NaN:!f||!d?i.s/0:i.s*0);for(t=Mt(c.e/Ce)+Mt(i.e/Ce),u=f.length,h=d.length,u<h&&(s=f,f=d,d=s,a=u,u=h,h=a),s=[],a=u+h,n=a;n--;)s.push(0);for(n=h;--n>=0;){for(e=0,r=u+n;r>n;)o=s[r]+d[n]*f[r-n-1]+e,s[r--]=o%Jt|0,e=o/Jt|0;s[r]=(s[r]+e)%Jt|0}for(;!s[--a];)s.pop();return e?++t:s.shift(),i.d=s,i.e=Us(s,t),Ie?be(i,l.precision,l.rounding):i};re.toBinary=function(i,e){return Do(this,2,i,e)};re.toDecimalPlaces=re.toDP=function(i,e){var t=this,n=t.constructor;return t=new n(t),i===void 0?t:(Pt(i,0,Dn),e===void 0?e=n.rounding:Pt(e,0,8),be(t,i+t.e+1,e))};re.toExponential=function(i,e){var t,n=this,r=n.constructor;return i===void 0?t=rn(n,!0):(Pt(i,0,Dn),e===void 0?e=r.rounding:Pt(e,0,8),n=be(new r(n),i+1,e),t=rn(n,!0,i+1)),n.isNeg()&&!n.isZero()?"-"+t:t};re.toFixed=function(i,e){var t,n,r=this,s=r.constructor;return i===void 0?t=rn(r):(Pt(i,0,Dn),e===void 0?e=s.rounding:Pt(e,0,8),n=be(new s(r),i+r.e+1,e),t=rn(n,!1,i+n.e+1)),r.isNeg()&&!r.isZero()?"-"+t:t};re.toFraction=function(i){var e,t,n,r,s,a,o,u,h,c,l,f,d=this,v=d.d,m=d.constructor;if(!v)return new m(d);if(h=t=new m(1),n=u=new m(0),e=new m(n),s=e.e=Fu(v)-d.e-1,a=s%Ce,e.d[0]=ct(10,a<0?Ce+a:a),i==null)i=s>0?e:h;else{if(o=new m(i),!o.isInt()||o.lt(h))throw Error(Fn+o);i=o.gt(e)?s>0?e:h:o}for(Ie=!1,o=new m(_t(v)),c=m.precision,m.precision=s=v.length*Ce*2;l=qe(o,e,0,1,1),r=t.plus(l.times(n)),r.cmp(i)!=1;)t=n,n=r,r=h,h=u.plus(l.times(r)),u=r,r=e,e=o.minus(l.times(r)),o=r;return r=qe(i.minus(t),n,0,1,1),u=u.plus(r.times(h)),t=t.plus(r.times(n)),u.s=h.s=d.s,f=qe(h,n,s,1).minus(d).abs().cmp(qe(u,t,s,1).minus(d).abs())<1?[h,n]:[u,t],m.precision=c,Ie=!0,f};re.toHexadecimal=re.toHex=function(i,e){return Do(this,16,i,e)};re.toNearest=function(i,e){var t=this,n=t.constructor;if(t=new n(t),i==null){if(!t.d)return t;i=new n(1),e=n.rounding}else{if(i=new n(i),e===void 0?e=n.rounding:Pt(e,0,8),!t.d)return i.s?t:i;if(!i.d)return i.s&&(i.s=t.s),i}return i.d[0]?(Ie=!1,t=qe(t,i,0,e,1).times(i),Ie=!0,be(t)):(i.s=t.s,t=i),t};re.toNumber=function(){return+this};re.toOctal=function(i,e){return Do(this,8,i,e)};re.toPower=re.pow=function(i){var e,t,n,r,s,a,o=this,u=o.constructor,h=+(i=new u(i));if(!o.d||!i.d||!o.d[0]||!i.d[0])return new u(ct(+o,h));if(o=new u(o),o.eq(1))return o;if(n=u.precision,s=u.rounding,i.eq(1))return be(o,n,s);if(e=Mt(i.e/Ce),e>=i.d.length-1&&(t=h<0?-h:h)<=ly)return r=zu(u,o,t,n),i.s<0?new u(1).div(r):be(r,n,s);if(a=o.s,a<0){if(e<i.d.length-1)return new u(NaN);if((i.d[e]&1)==0&&(a=1),o.e==0&&o.d[0]==1&&o.d.length==1)return o.s=a,o}return t=ct(+o,h),e=t==0||!isFinite(t)?Mt(h*(Math.log("0."+_t(o.d))/Math.LN10+o.e+1)):new u(t+"").e,e>u.maxE+1||e<u.minE-1?new u(e>0?a/0:0):(Ie=!1,u.rounding=o.s=1,t=Math.min(12,(e+"").length),r=No(i.times(Bn(o,n+t)),n),r.d&&(r=be(r,n+5,1),Tr(r.d,n,s)&&(e=n+10,r=be(No(i.times(Bn(o,e+t)),e),e+5,1),+_t(r.d).slice(n+1,n+15)+1==1e14&&(r=be(r,n+1,0)))),r.s=a,Ie=!0,u.rounding=s,be(r,n,s))};re.toPrecision=function(i,e){var t,n=this,r=n.constructor;return i===void 0?t=rn(n,n.e<=r.toExpNeg||n.e>=r.toExpPos):(Pt(i,1,Dn),e===void 0?e=r.rounding:Pt(e,0,8),n=be(new r(n),i,e),t=rn(n,i<=n.e||n.e<=r.toExpNeg,i)),n.isNeg()&&!n.isZero()?"-"+t:t};re.toSignificantDigits=re.toSD=function(i,e){var t=this,n=t.constructor;return i===void 0?(i=n.precision,e=n.rounding):(Pt(i,1,Dn),e===void 0?e=n.rounding:Pt(e,0,8)),be(new n(t),i,e)};re.toString=function(){var i=this,e=i.constructor,t=rn(i,i.e<=e.toExpNeg||i.e>=e.toExpPos);return i.isNeg()&&!i.isZero()?"-"+t:t};re.truncated=re.trunc=function(){return be(new this.constructor(this),this.e+1,1)};re.valueOf=re.toJSON=function(){var i=this,e=i.constructor,t=rn(i,i.e<=e.toExpNeg||i.e>=e.toExpPos);return i.isNeg()?"-"+t:t};function _t(i){var e,t,n,r=i.length-1,s="",a=i[0];if(r>0){for(s+=a,e=1;e<r;e++)n=i[e]+"",t=Ce-n.length,t&&(s+=zn(t)),s+=n;a=i[e],n=a+"",t=Ce-n.length,t&&(s+=zn(t))}else if(a===0)return"0";for(;a%10==0;)a/=10;return s+a}function Pt(i,e,t){if(i!==~~i||i<e||i>t)throw Error(Fn+i)}function Tr(i,e,t,n){var r,s,a,o;for(s=i[0];s>=10;s/=10)--e;return--e<0?(e+=Ce,r=0):(r=Math.ceil((e+1)/Ce),e%=Ce),s=ct(10,Ce-e),o=i[r]%s|0,n==null?e<3?(e==0?o=o/100|0:e==1&&(o=o/10|0),a=t<4&&o==99999||t>3&&o==49999||o==5e4||o==0):a=(t<4&&o+1==s||t>3&&o+1==s/2)&&(i[r+1]/s/100|0)==ct(10,e-2)-1||(o==s/2||o==0)&&(i[r+1]/s/100|0)==0:e<4?(e==0?o=o/1e3|0:e==1?o=o/100|0:e==2&&(o=o/10|0),a=(n||t<4)&&o==9999||!n&&t>3&&o==4999):a=((n||t<4)&&o+1==s||!n&&t>3&&o+1==s/2)&&(i[r+1]/s/1e3|0)==ct(10,e-3)-1,a}function Os(i,e,t){for(var n,r=[0],s,a=0,o=i.length;a<o;){for(s=r.length;s--;)r[s]*=e;for(r[0]+=Lo.indexOf(i.charAt(a++)),n=0;n<r.length;n++)r[n]>t-1&&(r[n+1]===void 0&&(r[n+1]=0),r[n+1]+=r[n]/t|0,r[n]%=t)}return r.reverse()}function uy(i,e){var t,n,r;if(e.isZero())return e;n=e.d.length,n<32?(t=Math.ceil(n/3),r=(1/Hs(4,t)).toString()):(t=16,r="2.3283064365386962890625e-10"),i.precision+=t,e=Gi(i,1,e.times(r),new i(1));for(var s=t;s--;){var a=e.times(e);e=a.times(a).minus(a).times(8).plus(1)}return i.precision-=t,e}var qe=function(){function i(n,r,s){var a,o=0,u=n.length;for(n=n.slice();u--;)a=n[u]*r+o,n[u]=a%s|0,o=a/s|0;return o&&n.unshift(o),n}function e(n,r,s,a){var o,u;if(s!=a)u=s>a?1:-1;else for(o=u=0;o<s;o++)if(n[o]!=r[o]){u=n[o]>r[o]?1:-1;break}return u}function t(n,r,s,a){for(var o=0;s--;)n[s]-=o,o=n[s]<r[s]?1:0,n[s]=o*a+n[s]-r[s];for(;!n[0]&&n.length>1;)n.shift()}return function(n,r,s,a,o,u){var h,c,l,f,d,v,m,_,p,g,y,x,M,S,w,C,I,D,T,O,B=n.constructor,F=n.s==r.s?1:-1,z=n.d,N=r.d;if(!z||!z[0]||!N||!N[0])return new B(!n.s||!r.s||(z?N&&z[0]==N[0]:!N)?NaN:z&&z[0]==0||!N?F*0:F/0);for(u?(d=1,c=n.e-r.e):(u=Jt,d=Ce,c=Mt(n.e/d)-Mt(r.e/d)),T=N.length,I=z.length,p=new B(F),g=p.d=[],l=0;N[l]==(z[l]||0);l++);if(N[l]>(z[l]||0)&&c--,s==null?(S=s=B.precision,a=B.rounding):o?S=s+(n.e-r.e)+1:S=s,S<0)g.push(1),v=!0;else{if(S=S/d+2|0,l=0,T==1){for(f=0,N=N[0],S++;(l<I||f)&&S--;l++)w=f*u+(z[l]||0),g[l]=w/N|0,f=w%N|0;v=f||l<I}else{for(f=u/(N[0]+1)|0,f>1&&(N=i(N,f,u),z=i(z,f,u),T=N.length,I=z.length),C=T,y=z.slice(0,T),x=y.length;x<T;)y[x++]=0;O=N.slice(),O.unshift(0),D=N[0],N[1]>=u/2&&++D;do f=0,h=e(N,y,T,x),h<0?(M=y[0],T!=x&&(M=M*u+(y[1]||0)),f=M/D|0,f>1?(f>=u&&(f=u-1),m=i(N,f,u),_=m.length,x=y.length,h=e(m,y,_,x),h==1&&(f--,t(m,T<_?O:N,_,u))):(f==0&&(h=f=1),m=N.slice()),_=m.length,_<x&&m.unshift(0),t(y,m,x,u),h==-1&&(x=y.length,h=e(N,y,T,x),h<1&&(f++,t(y,T<x?O:N,x,u))),x=y.length):h===0&&(f++,y=[0]),g[l++]=f,h&&y[0]?y[x++]=z[C]||0:(y=[z[C]],x=1);while((C++<I||y[0]!==void 0)&&S--);v=y[0]!==void 0}g[0]||g.shift()}if(d==1)p.e=c,Ru=v;else{for(l=1,f=g[0];f>=10;f/=10)l++;p.e=l+c*d-1,be(p,o?s+p.e+1:s,a,v)}return p}}();function be(i,e,t,n){var r,s,a,o,u,h,c,l,f,d=i.constructor;e:if(e!=null){if(l=i.d,!l)return i;for(r=1,o=l[0];o>=10;o/=10)r++;if(s=e-r,s<0)s+=Ce,a=e,c=l[f=0],u=c/ct(10,r-a-1)%10|0;else if(f=Math.ceil((s+1)/Ce),o=l.length,f>=o)if(n){for(;o++<=f;)l.push(0);c=u=0,r=1,s%=Ce,a=s-Ce+1}else break e;else{for(c=o=l[f],r=1;o>=10;o/=10)r++;s%=Ce,a=s-Ce+r,u=a<0?0:c/ct(10,r-a-1)%10|0}if(n=n||e<0||l[f+1]!==void 0||(a<0?c:c%ct(10,r-a-1)),h=t<4?(u||n)&&(t==0||t==(i.s<0?3:2)):u>5||u==5&&(t==4||n||t==6&&(s>0?a>0?c/ct(10,r-a):0:l[f-1])%10&1||t==(i.s<0?8:7)),e<1||!l[0])return l.length=0,h?(e-=i.e+1,l[0]=ct(10,(Ce-e%Ce)%Ce),i.e=-e||0):l[0]=i.e=0,i;if(s==0?(l.length=f,o=1,f--):(l.length=f+1,o=ct(10,Ce-s),l[f]=a>0?(c/ct(10,r-a)%ct(10,a)|0)*o:0),h)for(;;)if(f==0){for(s=1,a=l[0];a>=10;a/=10)s++;for(a=l[0]+=o,o=1;a>=10;a/=10)o++;s!=o&&(i.e++,l[0]==Jt&&(l[0]=1));break}else{if(l[f]+=o,l[f]!=Jt)break;l[f--]=0,o=1}for(s=l.length;l[--s]===0;)l.pop()}return Ie&&(i.e>d.maxE?(i.d=null,i.e=NaN):i.e<d.minE&&(i.e=0,i.d=[0])),i}function rn(i,e,t){if(!i.isFinite())return Uu(i);var n,r=i.e,s=_t(i.d),a=s.length;return e?(t&&(n=t-a)>0?s=s.charAt(0)+"."+s.slice(1)+zn(n):a>1&&(s=s.charAt(0)+"."+s.slice(1)),s=s+(i.e<0?"e":"e+")+i.e):r<0?(s="0."+zn(-r-1)+s,t&&(n=t-a)>0&&(s+=zn(n))):r>=a?(s+=zn(r+1-a),t&&(n=t-r-1)>0&&(s=s+"."+zn(n))):((n=r+1)<a&&(s=s.slice(0,n)+"."+s.slice(n)),t&&(n=t-a)>0&&(r+1===a&&(s+="."),s+=zn(n))),s}function Us(i,e){var t=i[0];for(e*=Ce;t>=10;t/=10)e++;return e}function Vs(i,e,t){if(e>cy)throw Ie=!0,t&&(i.precision=t),Error(Pu);return be(new i(Fs),e,1,!0)}function jt(i,e,t){if(e>Po)throw Error(Pu);return be(new i(zs),e,t,!0)}function Fu(i){var e=i.length-1,t=e*Ce+1;if(e=i[e],e){for(;e%10==0;e/=10)t--;for(e=i[0];e>=10;e/=10)t++}return t}function zn(i){for(var e="";i--;)e+="0";return e}function zu(i,e,t,n){var r,s=new i(1),a=Math.ceil(n/Ce+4);for(Ie=!1;;){if(t%2&&(s=s.times(e),Hu(s.d,a)&&(r=!0)),t=Mt(t/2),t===0){t=s.d.length-1,r&&s.d[t]===0&&++s.d[t];break}e=e.times(e),Hu(e.d,a)}return Ie=!0,s}function Bu(i){return i.d[i.d.length-1]&1}function Ou(i,e,t){for(var n,r=new i(e[0]),s=0;++s<e.length;)if(n=new i(e[s]),n.s)r[t](n)&&(r=n);else{r=n;break}return r}function No(i,e){var t,n,r,s,a,o,u,h=0,c=0,l=0,f=i.constructor,d=f.rounding,v=f.precision;if(!i.d||!i.d[0]||i.e>17)return new f(i.d?i.d[0]?i.s<0?0:1/0:1:i.s?i.s<0?0:i:0/0);for(e==null?(Ie=!1,u=v):u=e,o=new f(.03125);i.e>-2;)i=i.times(o),l+=5;for(n=Math.log(ct(2,l))/Math.LN10*2+5|0,u+=n,t=s=a=new f(1),f.precision=u;;){if(s=be(s.times(i),u,1),t=t.times(++c),o=a.plus(qe(s,t,u,1)),_t(o.d).slice(0,u)===_t(a.d).slice(0,u)){for(r=l;r--;)a=be(a.times(a),u,1);if(e==null)if(h<3&&Tr(a.d,u-n,d,h))f.precision=u+=10,t=s=o=new f(1),c=0,h++;else return be(a,f.precision=v,d,Ie=!0);else return f.precision=v,a}a=o}}function Bn(i,e){var t,n,r,s,a,o,u,h,c,l,f,d=1,v=10,m=i,_=m.d,p=m.constructor,g=p.rounding,y=p.precision;if(m.s<0||!_||!_[0]||!m.e&&_[0]==1&&_.length==1)return new p(_&&!_[0]?-1/0:m.s!=1?NaN:_?0:m);if(e==null?(Ie=!1,c=y):c=e,p.precision=c+=v,t=_t(_),n=t.charAt(0),Math.abs(s=m.e)<15e14){for(;n<7&&n!=1||n==1&&t.charAt(1)>3;)m=m.times(i),t=_t(m.d),n=t.charAt(0),d++;s=m.e,n>1?(m=new p("0."+t),s++):m=new p(n+"."+t.slice(1))}else return h=Vs(p,c+2,y).times(s+""),m=Bn(new p(n+"."+t.slice(1)),c-v).plus(h),p.precision=y,e==null?be(m,y,g,Ie=!0):m;for(l=m,u=a=m=qe(m.minus(1),m.plus(1),c,1),f=be(m.times(m),c,1),r=3;;){if(a=be(a.times(f),c,1),h=u.plus(qe(a,new p(r),c,1)),_t(h.d).slice(0,c)===_t(u.d).slice(0,c))if(u=u.times(2),s!==0&&(u=u.plus(Vs(p,c+2,y).times(s+""))),u=qe(u,new p(d),c,1),e==null)if(Tr(u.d,c-v,g,o))p.precision=c+=v,h=a=m=qe(l.minus(1),l.plus(1),c,1),f=be(m.times(m),c,1),r=o=1;else return be(u,p.precision=y,g,Ie=!0);else return p.precision=y,u;u=h,r+=2}}function Uu(i){return String(i.s*i.s/0)}function Io(i,e){var t,n,r;for((t=e.indexOf("."))>-1&&(e=e.replace(".","")),(n=e.search(/e/i))>0?(t<0&&(t=n),t+=+e.slice(n+1),e=e.substring(0,n)):t<0&&(t=e.length),n=0;e.charCodeAt(n)===48;n++);for(r=e.length;e.charCodeAt(r-1)===48;--r);if(e=e.slice(n,r),e){if(r-=n,i.e=t=t-n-1,i.d=[],n=(t+1)%Ce,t<0&&(n+=Ce),n<r){for(n&&i.d.push(+e.slice(0,n)),r-=Ce;n<r;)i.d.push(+e.slice(n,n+=Ce));e=e.slice(n),n=Ce-e.length}else n-=r;for(;n--;)e+="0";i.d.push(+e),Ie&&(i.e>i.constructor.maxE?(i.d=null,i.e=NaN):i.e<i.constructor.minE&&(i.e=0,i.d=[0]))}else i.e=0,i.d=[0];return i}function hy(i,e){var t,n,r,s,a,o,u,h,c;if(e.indexOf("_")>-1){if(e=e.replace(/(\d)_(?=\d)/g,"$1"),Du.test(e))return Io(i,e)}else if(e==="Infinity"||e==="NaN")return+e||(i.s=NaN),i.e=NaN,i.d=null,i;if(ay.test(e))t=16,e=e.toLowerCase();else if(sy.test(e))t=2;else if(oy.test(e))t=8;else throw Error(Fn+e);for(s=e.search(/p/i),s>0?(u=+e.slice(s+1),e=e.substring(2,s)):e=e.slice(2),s=e.indexOf("."),a=s>=0,n=i.constructor,a&&(e=e.replace(".",""),o=e.length,s=o-s,r=zu(n,new n(t),s,s*2)),h=Os(e,t,Jt),c=h.length-1,s=c;h[s]===0;--s)h.pop();return s<0?new n(i.s*0):(i.e=Us(h,c),i.d=h,Ie=!1,a&&(i=qe(i,r,o*4)),u&&(i=i.times(Math.abs(u)<54?ct(2,u):ki.pow(2,u))),Ie=!0,i)}function fy(i,e){var t,n=e.d.length;if(n<3)return e.isZero()?e:Gi(i,2,e,e);t=1.4*Math.sqrt(n),t=t>16?16:t|0,e=e.times(1/Hs(5,t)),e=Gi(i,2,e,e);for(var r,s=new i(5),a=new i(16),o=new i(20);t--;)r=e.times(e),e=e.times(s.plus(r.times(a.times(r).minus(o))));return e}function Gi(i,e,t,n,r){var s,a,o,u,h=i.precision,c=Math.ceil(h/Ce);for(Ie=!1,u=t.times(t),o=new i(n);;){if(a=qe(o.times(u),new i(e++*e++),h,1),o=r?n.plus(a):n.minus(a),n=qe(a.times(u),new i(e++*e++),h,1),a=o.plus(n),a.d[c]!==void 0){for(s=c;a.d[s]===o.d[s]&&s--;);if(s==-1)break}s=o,o=n,n=a,a=s}return Ie=!0,a.d.length=c+1,a}function Hs(i,e){for(var t=i;--e;)t*=i;return t}function Vu(i,e){var t,n=e.s<0,r=jt(i,i.precision,1),s=r.times(.5);if(e=e.abs(),e.lte(s))return pn=n?4:1,e;if(t=e.divToInt(r),t.isZero())pn=n?3:2;else{if(e=e.minus(t.times(r)),e.lte(s))return pn=Bu(t)?n?2:3:n?4:1,e;pn=Bu(t)?n?1:4:n?3:2}return e.minus(r).abs()}function Do(i,e,t,n){var r,s,a,o,u,h,c,l,f,d=i.constructor,v=t!==void 0;if(v?(Pt(t,1,Dn),n===void 0?n=d.rounding:Pt(n,0,8)):(t=d.precision,n=d.rounding),!i.isFinite())c=Uu(i);else{for(c=rn(i),a=c.indexOf("."),v?(r=2,e==16?t=t*4-3:e==8&&(t=t*3-2)):r=e,a>=0&&(c=c.replace(".",""),f=new d(1),f.e=c.length-a,f.d=Os(rn(f),10,r),f.e=f.d.length),l=Os(c,10,r),s=u=l.length;l[--u]==0;)l.pop();if(!l[0])c=v?"0p+0":"0";else{if(a<0?s--:(i=new d(i),i.d=l,i.e=s,i=qe(i,f,t,n,0,r),l=i.d,s=i.e,h=Ru),a=l[t],o=r/2,h=h||l[t+1]!==void 0,h=n<4?(a!==void 0||h)&&(n===0||n===(i.s<0?3:2)):a>o||a===o&&(n===4||h||n===6&&l[t-1]&1||n===(i.s<0?8:7)),l.length=t,h)for(;++l[--t]>r-1;)l[t]=0,t||(++s,l.unshift(1));for(u=l.length;!l[u-1];--u);for(a=0,c="";a<u;a++)c+=Lo.charAt(l[a]);if(v){if(u>1)if(e==16||e==8){for(a=e==16?4:3,--u;u%a;u++)c+="0";for(l=Os(c,r,e),u=l.length;!l[u-1];--u);for(a=1,c="1.";a<u;a++)c+=Lo.charAt(l[a])}else c=c.charAt(0)+"."+c.slice(1);c=c+(s<0?"p":"p+")+s}else if(s<0){for(;++s;)c="0"+c;c="0."+c}else if(++s>u)for(s-=u;s--;)c+="0";else s<u&&(c=c.slice(0,s)+"."+c.slice(s))}c=(e==16?"0x":e==2?"0b":e==8?"0o":"")+c}return i.s<0?"-"+c:c}function Hu(i,e){if(i.length>e)return i.length=e,!0}function dy(i){return new this(i).abs()}function py(i){return new this(i).acos()}function my(i){return new this(i).acosh()}function gy(i,e){return new this(i).plus(e)}function vy(i){return new this(i).asin()}function _y(i){return new this(i).asinh()}function yy(i){return new this(i).atan()}function xy(i){return new this(i).atanh()}function wy(i,e){i=new this(i),e=new this(e);var t,n=this.precision,r=this.rounding,s=n+4;return!i.s||!e.s?t=new this(NaN):!i.d&&!e.d?(t=jt(this,s,1).times(e.s>0?.25:.75),t.s=i.s):!e.d||i.isZero()?(t=e.s<0?jt(this,n,r):new this(0),t.s=i.s):!i.d||e.isZero()?(t=jt(this,s,1).times(.5),t.s=i.s):e.s<0?(this.precision=s,this.rounding=1,t=this.atan(qe(i,e,s,1)),e=jt(this,s,1),this.precision=n,this.rounding=r,t=i.s<0?t.minus(e):t.plus(e)):t=this.atan(qe(i,e,s,1)),t}function My(i){return new this(i).cbrt()}function by(i){return be(i=new this(i),i.e+1,2)}function Sy(i,e,t){return new this(i).clamp(e,t)}function Ey(i){if(!i||typeof i!="object")throw Error(Bs+"Object expected");var e,t,n,r=i.defaults===!0,s=["precision",1,Dn,"rounding",0,8,"toExpNeg",-Hi,0,"toExpPos",0,Hi,"maxE",0,Hi,"minE",-Hi,0,"modulo",0,9];for(e=0;e<s.length;e+=3)if(t=s[e],r&&(this[t]=Ro[t]),(n=i[t])!==void 0)if(Mt(n)===n&&n>=s[e+1]&&n<=s[e+2])this[t]=n;else throw Error(Fn+t+": "+n);if(t="crypto",r&&(this[t]=Ro[t]),(n=i[t])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto!="undefined"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Nu);else this[t]=!1;else throw Error(Fn+t+": "+n);return this}function Ty(i){return new this(i).cos()}function Ay(i){return new this(i).cosh()}function Gu(i){var e,t,n;function r(s){var a,o,u,h=this;if(!(h instanceof r))return new r(s);if(h.constructor=r,ku(s)){h.s=s.s,Ie?!s.d||s.e>r.maxE?(h.e=NaN,h.d=null):s.e<r.minE?(h.e=0,h.d=[0]):(h.e=s.e,h.d=s.d.slice()):(h.e=s.e,h.d=s.d?s.d.slice():s.d);return}if(u=typeof s,u==="number"){if(s===0){h.s=1/s<0?-1:1,h.e=0,h.d=[0];return}if(s<0?(s=-s,h.s=-1):h.s=1,s===~~s&&s<1e7){for(a=0,o=s;o>=10;o/=10)a++;Ie?a>r.maxE?(h.e=NaN,h.d=null):a<r.minE?(h.e=0,h.d=[0]):(h.e=a,h.d=[s]):(h.e=a,h.d=[s]);return}else if(s*0!=0){s||(h.s=NaN),h.e=NaN,h.d=null;return}return Io(h,s.toString())}else if(u!=="string")throw Error(Fn+s);return(o=s.charCodeAt(0))===45?(s=s.slice(1),h.s=-1):(o===43&&(s=s.slice(1)),h.s=1),Du.test(s)?Io(h,s):hy(h,s)}if(r.prototype=re,r.ROUND_UP=0,r.ROUND_DOWN=1,r.ROUND_CEIL=2,r.ROUND_FLOOR=3,r.ROUND_HALF_UP=4,r.ROUND_HALF_DOWN=5,r.ROUND_HALF_EVEN=6,r.ROUND_HALF_CEIL=7,r.ROUND_HALF_FLOOR=8,r.EUCLID=9,r.config=r.set=Ey,r.clone=Gu,r.isDecimal=ku,r.abs=dy,r.acos=py,r.acosh=my,r.add=gy,r.asin=vy,r.asinh=_y,r.atan=yy,r.atanh=xy,r.atan2=wy,r.cbrt=My,r.ceil=by,r.clamp=Sy,r.cos=Ty,r.cosh=Ay,r.div=Cy,r.exp=Ly,r.floor=Ry,r.hypot=Py,r.ln=Ny,r.log=Iy,r.log10=Fy,r.log2=Dy,r.max=zy,r.min=By,r.mod=Oy,r.mul=Uy,r.pow=Vy,r.random=Hy,r.round=Gy,r.sign=ky,r.sin=Wy,r.sinh=qy,r.sqrt=Xy,r.sub=Zy,r.sum=Yy,r.tan=Jy,r.tanh=jy,r.trunc=$y,i===void 0&&(i={}),i&&i.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],e=0;e<n.length;)i.hasOwnProperty(t=n[e++])||(i[t]=this[t]);return r.config(i),r}function Cy(i,e){return new this(i).div(e)}function Ly(i){return new this(i).exp()}function Ry(i){return be(i=new this(i),i.e+1,3)}function Py(){var i,e,t=new this(0);for(Ie=!1,i=0;i<arguments.length;)if(e=new this(arguments[i++]),e.d)t.d&&(t=t.plus(e.times(e)));else{if(e.s)return Ie=!0,new this(1/0);t=e}return Ie=!0,t.sqrt()}function ku(i){return i instanceof ki||i&&i.toStringTag===Iu||!1}function Ny(i){return new this(i).ln()}function Iy(i,e){return new this(i).log(e)}function Dy(i){return new this(i).log(2)}function Fy(i){return new this(i).log(10)}function zy(){return Ou(this,arguments,"lt")}function By(){return Ou(this,arguments,"gt")}function Oy(i,e){return new this(i).mod(e)}function Uy(i,e){return new this(i).mul(e)}function Vy(i,e){return new this(i).pow(e)}function Hy(i){var e,t,n,r,s=0,a=new this(1),o=[];if(i===void 0?i=this.precision:Pt(i,1,Dn),n=Math.ceil(i/Ce),this.crypto)if(crypto.getRandomValues)for(e=crypto.getRandomValues(new Uint32Array(n));s<n;)r=e[s],r>=429e7?e[s]=crypto.getRandomValues(new Uint32Array(1))[0]:o[s++]=r%1e7;else if(crypto.randomBytes){for(e=crypto.randomBytes(n*=4);s<n;)r=e[s]+(e[s+1]<<8)+(e[s+2]<<16)+((e[s+3]&127)<<24),r>=214e7?crypto.randomBytes(4).copy(e,s):(o.push(r%1e7),s+=4);s=n/4}else throw Error(Nu);else for(;s<n;)o[s++]=Math.random()*1e7|0;for(n=o[--s],i%=Ce,n&&i&&(r=ct(10,Ce-i),o[s]=(n/r|0)*r);o[s]===0;s--)o.pop();if(s<0)t=0,o=[0];else{for(t=-1;o[0]===0;t-=Ce)o.shift();for(n=1,r=o[0];r>=10;r/=10)n++;n<Ce&&(t-=Ce-n)}return a.e=t,a.d=o,a}function Gy(i){return be(i=new this(i),i.e+1,this.rounding)}function ky(i){return i=new this(i),i.d?i.d[0]?i.s:0*i.s:i.s||NaN}function Wy(i){return new this(i).sin()}function qy(i){return new this(i).sinh()}function Xy(i){return new this(i).sqrt()}function Zy(i,e){return new this(i).sub(e)}function Yy(){var i=0,e=arguments,t=new this(e[i]);for(Ie=!1;t.s&&++i<e.length;)t=t.plus(e[i]);return Ie=!0,be(t,this.precision,this.rounding)}function Jy(i){return new this(i).tan()}function jy(i){return new this(i).tanh()}function $y(i){return be(i=new this(i),i.e+1,1)}re[Symbol.for("nodejs.util.inspect.custom")]=re.toString;re[Symbol.toStringTag]="Decimal";var ki=re.constructor=Gu(Ro);Fs=new ki(Fs);zs=new ki(zs);var Qy="BigNumber",Ky=["?on","config"],ex=ft(Qy,Ky,i=>{var{on:e,config:t}=i,n=ki.clone({precision:t.precision,modulo:ki.EUCLID});return n.prototype=Object.create(n.prototype),n.prototype.type="BigNumber",n.prototype.isBigNumber=!0,n.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},n.fromJSON=function(r){return new n(r.value)},e&&e("config",function(r,s){r.precision!==s.precision&&n.config({precision:r.precision})}),n},{isClass:!0}),Wu={exports:{}};/**
 * @license Complex.js v2.0.15 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/(function(i,e){(function(t){var n=function(l){return(Math.exp(l)+Math.exp(-l))*.5},r=function(l){return(Math.exp(l)-Math.exp(-l))*.5},s=function(l){var f=Math.PI/4;if(-f>l||l>f)return Math.cos(l)-1;var d=l*l;return d*(d*(d*(d*(d*(d*(d*(d/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-1/2)},a=function(l,f){var d=Math.abs(l),v=Math.abs(f);return d<3e3&&v<3e3?Math.sqrt(d*d+v*v):(d<v?(d=v,v=l/f):v=f/l,d*Math.sqrt(1+v*v))},o=function(){throw SyntaxError("Invalid Param")};function u(l,f){var d=Math.abs(l),v=Math.abs(f);return l===0?Math.log(v):f===0?Math.log(d):d<3e3&&v<3e3?Math.log(l*l+f*f)*.5:Math.log(l/Math.cos(Math.atan2(f,l)))}var h=function(l,f){var d={re:0,im:0};if(l==null)d.re=d.im=0;else if(f!==void 0)d.re=l,d.im=f;else switch(typeof l){case"object":if("im"in l&&"re"in l)d.re=l.re,d.im=l.im;else if("abs"in l&&"arg"in l){if(!Number.isFinite(l.abs)&&Number.isFinite(l.arg))return c.INFINITY;d.re=l.abs*Math.cos(l.arg),d.im=l.abs*Math.sin(l.arg)}else if("r"in l&&"phi"in l){if(!Number.isFinite(l.r)&&Number.isFinite(l.phi))return c.INFINITY;d.re=l.r*Math.cos(l.phi),d.im=l.r*Math.sin(l.phi)}else l.length===2?(d.re=l[0],d.im=l[1]):o();break;case"string":d.im=d.re=0;var v=l.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),m=1,_=0;v===null&&o();for(var p=0;p<v.length;p++){var g=v[p];g===" "||g==="	"||g===`
`||(g==="+"?m++:g==="-"?_++:g==="i"||g==="I"?(m+_===0&&o(),v[p+1]!==" "&&!isNaN(v[p+1])?(d.im+=parseFloat((_%2?"-":"")+v[p+1]),p++):d.im+=parseFloat((_%2?"-":"")+"1"),m=_=0):((m+_===0||isNaN(g))&&o(),v[p+1]==="i"||v[p+1]==="I"?(d.im+=parseFloat((_%2?"-":"")+g),p++):d.re+=parseFloat((_%2?"-":"")+g),m=_=0))}m+_>0&&o();break;case"number":d.im=0,d.re=l;break;default:o()}return isNaN(d.re)||isNaN(d.im),d};function c(l,f){if(!(this instanceof c))return new c(l,f);var d=h(l,f);this.re=d.re,this.im=d.im}c.prototype={re:0,im:0,sign:function(){var l=this.abs();return new c(this.re/l,this.im/l)},add:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:new c(this.re+d.re,this.im+d.im)},sub:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:new c(this.re-d.re,this.im-d.im)},mul:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isZero()||this.isZero()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:d.im===0&&this.im===0?new c(this.re*d.re,0):new c(this.re*d.re-this.im*d.im,this.re*d.im+this.im*d.re)},div:function(l,f){var d=new c(l,f);if(this.isZero()&&d.isZero()||this.isInfinite()&&d.isInfinite())return c.NAN;if(this.isInfinite()||d.isZero())return c.INFINITY;if(this.isZero()||d.isInfinite())return c.ZERO;l=this.re,f=this.im;var v=d.re,m=d.im,_,p;return m===0?new c(l/v,f/v):Math.abs(v)<Math.abs(m)?(p=v/m,_=v*p+m,new c((l*p+f)/_,(f*p-l)/_)):(p=m/v,_=m*p+v,new c((l+f*p)/_,(f-l*p)/_))},pow:function(l,f){var d=new c(l,f);if(l=this.re,f=this.im,d.isZero())return c.ONE;if(d.im===0){if(f===0&&l>0)return new c(Math.pow(l,d.re),0);if(l===0)switch((d.re%4+4)%4){case 0:return new c(Math.pow(f,d.re),0);case 1:return new c(0,Math.pow(f,d.re));case 2:return new c(-Math.pow(f,d.re),0);case 3:return new c(0,-Math.pow(f,d.re))}}if(l===0&&f===0&&d.re>0&&d.im>=0)return c.ZERO;var v=Math.atan2(f,l),m=u(l,f);return l=Math.exp(d.re*m-d.im*v),f=d.im*m+d.re*v,new c(l*Math.cos(f),l*Math.sin(f))},sqrt:function(){var l=this.re,f=this.im,d=this.abs(),v,m;if(l>=0){if(f===0)return new c(Math.sqrt(l),0);v=.5*Math.sqrt(2*(d+l))}else v=Math.abs(f)/Math.sqrt(2*(d-l));return l<=0?m=.5*Math.sqrt(2*(d-l)):m=Math.abs(f)/Math.sqrt(2*(d+l)),new c(v,f<0?-m:m)},exp:function(){var l=Math.exp(this.re);return this.im===0,new c(l*Math.cos(this.im),l*Math.sin(this.im))},expm1:function(){var l=this.re,f=this.im;return new c(Math.expm1(l)*Math.cos(f)+s(f),Math.exp(l)*Math.sin(f))},log:function(){var l=this.re,f=this.im;return new c(u(l,f),Math.atan2(f,l))},abs:function(){return a(this.re,this.im)},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var l=this.re,f=this.im;return new c(Math.sin(l)*n(f),Math.cos(l)*r(f))},cos:function(){var l=this.re,f=this.im;return new c(Math.cos(l)*n(f),-Math.sin(l)*r(f))},tan:function(){var l=2*this.re,f=2*this.im,d=Math.cos(l)+n(f);return new c(Math.sin(l)/d,r(f)/d)},cot:function(){var l=2*this.re,f=2*this.im,d=Math.cos(l)-n(f);return new c(-Math.sin(l)/d,r(f)/d)},sec:function(){var l=this.re,f=this.im,d=.5*n(2*f)+.5*Math.cos(2*l);return new c(Math.cos(l)*n(f)/d,Math.sin(l)*r(f)/d)},csc:function(){var l=this.re,f=this.im,d=.5*n(2*f)-.5*Math.cos(2*l);return new c(Math.sin(l)*n(f)/d,-Math.cos(l)*r(f)/d)},asin:function(){var l=this.re,f=this.im,d=new c(f*f-l*l+1,-2*l*f).sqrt(),v=new c(d.re-f,d.im+l).log();return new c(v.im,-v.re)},acos:function(){var l=this.re,f=this.im,d=new c(f*f-l*l+1,-2*l*f).sqrt(),v=new c(d.re-f,d.im+l).log();return new c(Math.PI/2-v.im,v.re)},atan:function(){var l=this.re,f=this.im;if(l===0){if(f===1)return new c(0,1/0);if(f===-1)return new c(0,-1/0)}var d=l*l+(1-f)*(1-f),v=new c((1-f*f-l*l)/d,-2*l/d).log();return new c(-.5*v.im,.5*v.re)},acot:function(){var l=this.re,f=this.im;if(f===0)return new c(Math.atan2(1,l),0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).atan():new c(l!==0?l/0:0,f!==0?-f/0:0).atan()},asec:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(0,1/0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).acos():new c(l!==0?l/0:0,f!==0?-f/0:0).acos()},acsc:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(Math.PI/2,1/0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).asin():new c(l!==0?l/0:0,f!==0?-f/0:0).asin()},sinh:function(){var l=this.re,f=this.im;return new c(r(l)*Math.cos(f),n(l)*Math.sin(f))},cosh:function(){var l=this.re,f=this.im;return new c(n(l)*Math.cos(f),r(l)*Math.sin(f))},tanh:function(){var l=2*this.re,f=2*this.im,d=n(l)+Math.cos(f);return new c(r(l)/d,Math.sin(f)/d)},coth:function(){var l=2*this.re,f=2*this.im,d=n(l)-Math.cos(f);return new c(r(l)/d,-Math.sin(f)/d)},csch:function(){var l=this.re,f=this.im,d=Math.cos(2*f)-n(2*l);return new c(-2*r(l)*Math.cos(f)/d,2*n(l)*Math.sin(f)/d)},sech:function(){var l=this.re,f=this.im,d=Math.cos(2*f)+n(2*l);return new c(2*n(l)*Math.cos(f)/d,-2*r(l)*Math.sin(f)/d)},asinh:function(){var l=this.im;this.im=-this.re,this.re=l;var f=this.asin();return this.re=-this.im,this.im=l,l=f.re,f.re=-f.im,f.im=l,f},acosh:function(){var l=this.acos();if(l.im<=0){var f=l.re;l.re=-l.im,l.im=f}else{var f=l.im;l.im=-l.re,l.re=f}return l},atanh:function(){var l=this.re,f=this.im,d=l>1&&f===0,v=1-l,m=1+l,_=v*v+f*f,p=_!==0?new c((m*v-f*f)/_,(f*v+m*f)/_):new c(l!==-1?l/0:0,f!==0?f/0:0),g=p.re;return p.re=u(p.re,p.im)/2,p.im=Math.atan2(p.im,g)/2,d&&(p.im=-p.im),p},acoth:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(0,Math.PI/2);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).atanh():new c(l!==0?l/0:0,f!==0?-f/0:0).atanh()},acsch:function(){var l=this.re,f=this.im;if(f===0)return new c(l!==0?Math.log(l+Math.sqrt(l*l+1)):1/0,0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).asinh():new c(l!==0?l/0:0,f!==0?-f/0:0).asinh()},asech:function(){var l=this.re,f=this.im;if(this.isZero())return c.INFINITY;var d=l*l+f*f;return d!==0?new c(l/d,-f/d).acosh():new c(l!==0?l/0:0,f!==0?-f/0:0).acosh()},inverse:function(){if(this.isZero())return c.INFINITY;if(this.isInfinite())return c.ZERO;var l=this.re,f=this.im,d=l*l+f*f;return new c(l/d,-f/d)},conjugate:function(){return new c(this.re,-this.im)},neg:function(){return new c(-this.re,-this.im)},ceil:function(l){return l=Math.pow(10,l||0),new c(Math.ceil(this.re*l)/l,Math.ceil(this.im*l)/l)},floor:function(l){return l=Math.pow(10,l||0),new c(Math.floor(this.re*l)/l,Math.floor(this.im*l)/l)},round:function(l){return l=Math.pow(10,l||0),new c(Math.round(this.re*l)/l,Math.round(this.im*l)/l)},equals:function(l,f){var d=new c(l,f);return Math.abs(d.re-this.re)<=c.EPSILON&&Math.abs(d.im-this.im)<=c.EPSILON},clone:function(){return new c(this.re,this.im)},toString:function(){var l=this.re,f=this.im,d="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(l)<c.EPSILON&&(l=0),Math.abs(f)<c.EPSILON&&(f=0),f===0?d+l:(l!==0?(d+=l,d+=" ",f<0?(f=-f,d+="-"):d+="+",d+=" "):f<0&&(f=-f,d+="-"),f!==1&&(d+=f),d+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return this.im===0?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return this.im===0&&this.re===0},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},c.ZERO=new c(0,0),c.ONE=new c(1,0),c.I=new c(0,1),c.PI=new c(Math.PI,0),c.E=new c(Math.E,0),c.INFINITY=new c(1/0,1/0),c.NAN=new c(NaN,NaN),c.EPSILON=1e-15,Object.defineProperty(c,"__esModule",{value:!0}),c.default=c,c.Complex=c,i.exports=c})()})(Wu);var Nt=mu(Wu.exports),tx="Complex",nx=[],ix=ft(tx,nx,()=>(Nt.prototype.type="Complex",Nt.prototype.isComplex=!0,Nt.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},Nt.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},Nt.prototype.format=function(i){var e="",t=this.im,n=this.re,r=bo(this.re,i),s=bo(this.im,i),a=nt(i)?i:i?i.precision:null;if(a!==null){var o=Math.pow(10,-a);Math.abs(n/t)<o&&(n=0),Math.abs(t/n)<o&&(t=0)}return t===0?e=r:n===0?t===1?e="i":t===-1?e="-i":e=s+"i":t<0?t===-1?e=r+" - i":e=r+" - "+s.substring(1)+"i":t===1?e=r+" + i":e=r+" + "+s+"i",e},Nt.fromPolar=function(i){switch(arguments.length){case 1:{var e=arguments[0];if(typeof e=="object")return Nt(e);throw new TypeError("Input has to be an object with r and phi keys.")}case 2:{var t=arguments[0],n=arguments[1];if(nt(t)){if(wo(n)&&n.hasBase("ANGLE")&&(n=n.toNumber("rad")),nt(n))return new Nt({r:t,phi:n});throw new TypeError("Phi is not a number nor an angle unit.")}else throw new TypeError("Radius r is not a number.")}default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},Nt.prototype.valueOf=Nt.prototype.toString,Nt.fromJSON=function(i){return new Nt(i)},Nt.compare=function(i,e){return i.re>e.re?1:i.re<e.re?-1:i.im>e.im?1:i.im<e.im?-1:0},Nt),{isClass:!0}),qu={exports:{}};/**
 * @license Fraction.js v4.1.2 23/05/2021
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/(function(i,e){(function(t){var n=2e3,r={s:1,n:0,d:1};function s(p){function g(){var x=Error.apply(this,arguments);x.name=this.name=p,this.stack=x.stack,this.message=x.message}function y(){}return y.prototype=Error.prototype,g.prototype=new y,g}var a=_.DivisionByZero=s("DivisionByZero"),o=_.InvalidParameter=s("InvalidParameter");function u(p,g){return isNaN(p=parseInt(p,10))&&h(),p*g}function h(){throw new o}function c(p){for(var g={},y=p,x=2,M=4;M<=y;){for(;y%x==0;)y/=x,g[x]=(g[x]||0)+1;M+=1+2*x++}return y!==p?y>1&&(g[y]=(g[y]||0)+1):g[p]=(g[p]||0)+1,g}var l=function(p,g){var y=0,x=1,M=1,S=0,w=0,C=0,I=1,D=1,T=0,O=1,B=1,F=1,z=1e7,N;if(p!=null)if(g!==void 0)y=p,x=g,M=y*x;else switch(typeof p){case"object":{"d"in p&&"n"in p?(y=p.n,x=p.d,"s"in p&&(y*=p.s)):0 in p?(y=p[0],1 in p&&(x=p[1])):h(),M=y*x;break}case"number":{if(p<0&&(M=p,p=-p),p%1==0)y=p;else if(p>0){for(p>=1&&(D=Math.pow(10,Math.floor(1+Math.log(p)/Math.LN10)),p/=D);O<=z&&F<=z;)if(N=(T+B)/(O+F),p===N){O+F<=z?(y=T+B,x=O+F):F>O?(y=B,x=F):(y=T,x=O);break}else p>N?(T+=B,O+=F):(B+=T,F+=O),O>z?(y=B,x=F):(y=T,x=O);y*=D}else(isNaN(p)||isNaN(g))&&(x=y=NaN);break}case"string":if(O=p.match(/\d+|./g),O===null&&h(),O[T]==="-"?(M=-1,T++):O[T]==="+"&&T++,O.length===T+1?w=u(O[T++],M):O[T+1]==="."||O[T]==="."?(O[T]!=="."&&(S=u(O[T++],M)),T++,(T+1===O.length||O[T+1]==="("&&O[T+3]===")"||O[T+1]==="'"&&O[T+3]==="'")&&(w=u(O[T],M),I=Math.pow(10,O[T].length),T++),(O[T]==="("&&O[T+2]===")"||O[T]==="'"&&O[T+2]==="'")&&(C=u(O[T+1],M),D=Math.pow(10,O[T+1].length)-1,T+=3)):O[T+1]==="/"||O[T+1]===":"?(w=u(O[T],M),I=u(O[T+2],1),T+=3):O[T+3]==="/"&&O[T+1]===" "&&(S=u(O[T],M),w=u(O[T+2],M),I=u(O[T+4],1),T+=5),O.length<=T){x=I*D,M=y=C+x*S+D*w;break}default:h()}if(x===0)throw new a;r.s=M<0?-1:1,r.n=Math.abs(y),r.d=Math.abs(x)};function f(p,g,y){for(var x=1;g>0;p=p*p%y,g>>=1)g&1&&(x=x*p%y);return x}function d(p,g){for(;g%2==0;g/=2);for(;g%5==0;g/=5);if(g===1)return 0;for(var y=10%g,x=1;y!==1;x++)if(y=y*10%g,x>n)return 0;return x}function v(p,g,y){for(var x=1,M=f(10,y,g),S=0;S<300;S++){if(x===M)return S;x=x*10%g,M=M*10%g}return 0}function m(p,g){if(!p)return g;if(!g)return p;for(;;){if(p%=g,!p)return g;if(g%=p,!g)return p}}function _(p,g){if(!(this instanceof _))return new _(p,g);l(p,g),p=m(r.d,r.n),this.s=r.s,this.n=r.n/p,this.d=r.d/p}_.prototype={s:1,n:0,d:1,abs:function(){return new _(this.n,this.d)},neg:function(){return new _(-this.s*this.n,this.d)},add:function(p,g){return l(p,g),new _(this.s*this.n*r.d+r.s*this.d*r.n,this.d*r.d)},sub:function(p,g){return l(p,g),new _(this.s*this.n*r.d-r.s*this.d*r.n,this.d*r.d)},mul:function(p,g){return l(p,g),new _(this.s*r.s*this.n*r.n,this.d*r.d)},div:function(p,g){return l(p,g),new _(this.s*r.s*this.n*r.d,this.d*r.n)},clone:function(){return new _(this)},mod:function(p,g){return isNaN(this.n)||isNaN(this.d)?new _(NaN):p===void 0?new _(this.s*this.n%this.d,1):(l(p,g),r.n===0&&this.d===0&&_(0,0),new _(this.s*(r.d*this.n)%(r.n*this.d),r.d*this.d))},gcd:function(p,g){return l(p,g),new _(m(r.n,this.n)*m(r.d,this.d),r.d*this.d)},lcm:function(p,g){return l(p,g),r.n===0&&this.n===0?new _:new _(r.n*this.n,m(r.n,this.n)*m(r.d,this.d))},ceil:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new _(NaN):new _(Math.ceil(p*this.s*this.n/this.d),p)},floor:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new _(NaN):new _(Math.floor(p*this.s*this.n/this.d),p)},round:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new _(NaN):new _(Math.round(p*this.s*this.n/this.d),p)},inverse:function(){return new _(this.s*this.d,this.n)},pow:function(p,g){if(l(p,g),r.d===1)return r.s<0?new _(Math.pow(this.s*this.d,r.n),Math.pow(this.n,r.n)):new _(Math.pow(this.s*this.n,r.n),Math.pow(this.d,r.n));if(this.s<0)return null;var y=c(this.n),x=c(this.d),M=1,S=1;for(var w in y)if(w!=="1"){if(w==="0"){M=0;break}if(y[w]*=r.n,y[w]%r.d==0)y[w]/=r.d;else return null;M*=Math.pow(w,y[w])}for(var w in x)if(w!=="1"){if(x[w]*=r.n,x[w]%r.d==0)x[w]/=r.d;else return null;S*=Math.pow(w,x[w])}return r.s<0?new _(S,M):new _(M,S)},equals:function(p,g){return l(p,g),this.s*this.n*r.d==r.s*r.n*this.d},compare:function(p,g){l(p,g);var y=this.s*this.n*r.d-r.s*r.n*this.d;return(0<y)-(y<0)},simplify:function(p){if(isNaN(this.n)||isNaN(this.d))return this;var g=this.abs().toContinued();p=p||.001;function y(S){return S.length===1?new _(S[0]):y(S.slice(1)).inverse().add(S[0])}for(var x=0;x<g.length;x++){var M=y(g.slice(0,x+1));if(M.sub(this.abs()).abs().valueOf()<p)return M.mul(this.s)}return this},divisible:function(p,g){return l(p,g),!(!(r.n*this.d)||this.n*r.d%(r.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(p){var g,y="",x=this.n,M=this.d;return this.s<0&&(y+="-"),M===1?y+=x:(p&&(g=Math.floor(x/M))>0&&(y+=g,y+=" ",x%=M),y+=x,y+="/",y+=M),y},toLatex:function(p){var g,y="",x=this.n,M=this.d;return this.s<0&&(y+="-"),M===1?y+=x:(p&&(g=Math.floor(x/M))>0&&(y+=g,x%=M),y+="\\frac{",y+=x,y+="}{",y+=M,y+="}"),y},toContinued:function(){var p,g=this.n,y=this.d,x=[];if(isNaN(g)||isNaN(y))return x;do x.push(Math.floor(g/y)),p=g%y,g=y,y=p;while(g!==1);return x},toString:function(p){var g=this.n,y=this.d;if(isNaN(g)||isNaN(y))return"NaN";p=p||15;var x=d(g,y),M=v(g,y,x),S=this.s===-1?"-":"";if(S+=g/y|0,g%=y,g*=10,g&&(S+="."),x){for(var w=M;w--;)S+=g/y|0,g%=y,g*=10;S+="(";for(var w=x;w--;)S+=g/y|0,g%=y,g*=10;S+=")"}else for(var w=p;g&&w--;)S+=g/y|0,g%=y,g*=10;return S}},Object.defineProperty(_,"__esModule",{value:!0}),_.default=_,_.Fraction=_,i.exports=_})()})(qu);var Wi=mu(qu.exports),rx="Fraction",sx=[],ax=ft(rx,sx,()=>(Wi.prototype.type="Fraction",Wi.prototype.isFraction=!0,Wi.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},Wi.fromJSON=function(i){return new Wi(i)},Wi),{isClass:!0}),ox="Matrix",lx=[],cx=ft(ox,lx,()=>{function i(){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator")}return i.prototype.type="Matrix",i.prototype.isMatrix=!0,i.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},i.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},i.prototype.create=function(e,t){throw new Error("Cannot invoke create on a Matrix interface")},i.prototype.subset=function(e,t,n){throw new Error("Cannot invoke subset on a Matrix interface")},i.prototype.get=function(e){throw new Error("Cannot invoke get on a Matrix interface")},i.prototype.set=function(e,t,n){throw new Error("Cannot invoke set on a Matrix interface")},i.prototype.resize=function(e,t){throw new Error("Cannot invoke resize on a Matrix interface")},i.prototype.reshape=function(e,t){throw new Error("Cannot invoke reshape on a Matrix interface")},i.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},i.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},i.prototype.map=function(e,t){throw new Error("Cannot invoke map on a Matrix interface")},i.prototype.forEach=function(e){throw new Error("Cannot invoke forEach on a Matrix interface")},i.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},i.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},i.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},i.prototype.format=function(e){throw new Error("Cannot invoke format on a Matrix interface")},i.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},i},{isClass:!0}),ux="DenseMatrix",hx=["Matrix"],fx=ft(ux,hx,i=>{var{Matrix:e}=i;function t(c,l){if(!(this instanceof t))throw new SyntaxError("Constructor must be called with the new operator");if(l&&!dn(l))throw new Error("Invalid datatype: "+l);if(Et(c))c.type==="DenseMatrix"?(this._data=gt(c._data),this._size=gt(c._size),this._datatype=l||c._datatype):(this._data=c.toArray(),this._size=c.size(),this._datatype=l||c._datatype);else if(c&&Qe(c.data)&&Qe(c.size))this._data=c.data,this._size=c.size,Mu(this._data,this._size),this._datatype=l||c.datatype;else if(Qe(c))this._data=h(c),this._size=Qn(this._data),Mu(this._data,this._size),this._datatype=l;else{if(c)throw new TypeError("Unsupported type of data ("+Sr(c)+")");this._data=[],this._size=[0],this._datatype=l}}t.prototype=new e,t.prototype.createDenseMatrix=function(c,l){return new t(c,l)},t.prototype.type="DenseMatrix",t.prototype.isDenseMatrix=!0,t.prototype.getDataType=function(){return Is(this._data,Sr)},t.prototype.storage=function(){return"dense"},t.prototype.datatype=function(){return this._datatype},t.prototype.create=function(c,l){return new t(c,l)},t.prototype.subset=function(c,l,f){switch(arguments.length){case 1:return n(this,c);case 2:case 3:return s(this,c,l,f);default:throw new SyntaxError("Wrong number of arguments")}},t.prototype.get=function(c){if(!Qe(c))throw new TypeError("Array expected");if(c.length!==this._size.length)throw new Ke(c.length,this._size.length);for(var l=0;l<c.length;l++)at(c[l],this._size[l]);for(var f=this._data,d=0,v=c.length;d<v;d++){var m=c[d];at(m,f.length),f=f[m]}return f},t.prototype.set=function(c,l,f){if(!Qe(c))throw new TypeError("Array expected");if(c.length<this._size.length)throw new Ke(c.length,this._size.length,"<");var d,v,m,_=c.map(function(g){return g+1});u(this,_,f);var p=this._data;for(d=0,v=c.length-1;d<v;d++)m=c[d],at(m,p.length),p=p[m];return m=c[c.length-1],at(m,p.length),p[m]=l,this};function n(c,l){if(!As(l))throw new TypeError("Invalid index");var f=l.isScalar();if(f)return c.get(l.min());var d=l.size();if(d.length!==c._size.length)throw new Ke(d.length,c._size.length);for(var v=l.min(),m=l.max(),_=0,p=c._size.length;_<p;_++)at(v[_],c._size[_]),at(m[_],c._size[_]);return new t(r(c._data,l,d.length,0),c._datatype)}function r(c,l,f,d){var v=d===f-1,m=l.dimension(d);return v?m.map(function(_){return at(_,c.length),c[_]}).valueOf():m.map(function(_){at(_,c.length);var p=c[_];return r(p,l,f,d+1)}).valueOf()}function s(c,l,f,d){if(!l||l.isIndex!==!0)throw new TypeError("Invalid index");var v=l.size(),m=l.isScalar(),_;if(Et(f)?(_=f.size(),f=f.valueOf()):_=Qn(f),m){if(_.length!==0)throw new TypeError("Scalar expected");c.set(l.min(),f,d)}else{if(v.length<c._size.length)throw new Ke(v.length,c._size.length,"<");if(_.length<v.length){for(var p=0,g=0;v[p]===1&&_[p]===1;)p++;for(;v[p]===1;)g++,p++;f=Eu(f,v.length,g,_)}if(!Cs(v,_))throw new Ke(v,_,">");var y=l.max().map(function(S){return S+1});u(c,y,d);var x=v.length,M=0;a(c._data,l,f,x,M)}return c}function a(c,l,f,d,v){var m=v===d-1,_=l.dimension(v);m?_.forEach(function(p,g){at(p),c[p]=f[g[0]]}):_.forEach(function(p,g){at(p),a(c[p],l,f[g[0]],d,v+1)})}t.prototype.resize=function(c,l,f){if(!cu(c))throw new TypeError("Array or Matrix expected");var d=c.valueOf().map(m=>Array.isArray(m)&&m.length===1?m[0]:m),v=f?this.clone():this;return o(v,d,l)};function o(c,l,f){if(l.length===0){for(var d=c._data;Qe(d);)d=d[0];return d}return c._size=l.slice(0),c._data=bu(c._data,c._size,f),c}t.prototype.reshape=function(c,l){var f=l?this.clone():this;f._data=G_(f._data,c);var d=f._size.reduce((v,m)=>v*m);return f._size=To(c,d),f};function u(c,l,f){for(var d=c._size.slice(0),v=!1;d.length<l.length;)d.push(0),v=!0;for(var m=0,_=l.length;m<_;m++)l[m]>d[m]&&(d[m]=l[m],v=!0);v&&o(c,d,f)}t.prototype.clone=function(){var c=new t({data:gt(this._data),size:gt(this._size),datatype:this._datatype});return c},t.prototype.size=function(){return this._size.slice(0)},t.prototype.map=function(c){var l=this,f=function m(_,p){return Qe(_)?_.map(function(g,y){return m(g,p.concat(y))}):c(_,p,l)},d=f(this._data,[]),v=this._datatype!==void 0?Is(d,Sr):void 0;return new t(d,v)},t.prototype.forEach=function(c){var l=this,f=function d(v,m){Qe(v)?v.forEach(function(_,p){d(_,m.concat(p))}):c(v,m,l)};f(this._data,[])},t.prototype[Symbol.iterator]=function*(){var c=function*l(f,d){if(Qe(f))for(var v=0;v<f.length;v++)yield*l(f[v],d.concat(v));else yield{value:f,index:d}};yield*c(this._data,[])},t.prototype.rows=function(){var c=[],l=this.size();if(l.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");var f=this._data;for(var d of f)c.push(new t([d],this._datatype));return c},t.prototype.columns=function(){var c=this,l=[],f=this.size();if(f.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var d=this._data,v=function(p){var g=d.map(y=>[y[p]]);l.push(new t(g,c._datatype))},m=0;m<f[1];m++)v(m);return l},t.prototype.toArray=function(){return gt(this._data)},t.prototype.valueOf=function(){return this._data},t.prototype.format=function(c){return Rt(this._data,c)},t.prototype.toString=function(){return Rt(this._data)},t.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},t.prototype.diagonal=function(c){if(c){if(Yt(c)&&(c=c.toNumber()),!nt(c)||!vt(c))throw new TypeError("The parameter k must be an integer number")}else c=0;for(var l=c>0?c:0,f=c<0?-c:0,d=this._size[0],v=this._size[1],m=Math.min(d-f,v-l),_=[],p=0;p<m;p++)_[p]=this._data[p+f][p+l];return new t({data:_,size:[m],datatype:this._datatype})},t.diagonal=function(c,l,f,d){if(!Qe(c))throw new TypeError("Array expected, size parameter");if(c.length!==2)throw new Error("Only two dimensions matrix are supported");if(c=c.map(function(w){if(Yt(w)&&(w=w.toNumber()),!nt(w)||!vt(w)||w<1)throw new Error("Size values must be positive integers");return w}),f){if(Yt(f)&&(f=f.toNumber()),!nt(f)||!vt(f))throw new TypeError("The parameter k must be an integer number")}else f=0;var v=f>0?f:0,m=f<0?-f:0,_=c[0],p=c[1],g=Math.min(_-m,p-v),y;if(Qe(l)){if(l.length!==g)throw new Error("Invalid value array length");y=function(C){return l[C]}}else if(Et(l)){var x=l.size();if(x.length!==1||x[0]!==g)throw new Error("Invalid matrix length");y=function(C){return l.get([C])}}else y=function(){return l};d||(d=Yt(y(0))?y(0).mul(0):0);var M=[];if(c.length>0){M=bu(M,c,d);for(var S=0;S<g;S++)M[S+m][S+v]=y(S)}return new t({data:M,size:[_,p]})},t.fromJSON=function(c){return new t(c)},t.prototype.swapRows=function(c,l){if(!nt(c)||!vt(c)||!nt(l)||!vt(l))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return at(c,this._size[0]),at(l,this._size[0]),t._swapRows(c,l,this._data),this},t._swapRows=function(c,l,f){var d=f[c];f[c]=f[l],f[l]=d};function h(c){for(var l=0,f=c.length;l<f;l++){var d=c[l];Qe(d)?c[l]=h(d):d&&d.isMatrix===!0&&(c[l]=h(d.valueOf()))}return c}return t},{isClass:!0});function Xu(i,e,t){return i&&typeof i.map=="function"?i.map(function(n){return Xu(n,e)}):e(i)}var Zu="number, number";function Yu(i,e){return i+e}Yu.signature=Zu;function Ju(i,e){return i*e}Ju.signature=Zu;function dx(i,e,t){if(t==null)return i.eq(e);if(i.eq(e))return!0;if(i.isNaN()||e.isNaN())return!1;if(i.isFinite()&&e.isFinite()){var n=i.minus(e).abs();if(n.isZero())return!0;var r=i.constructor.max(i.abs(),e.abs());return n.lte(r.times(t))}return!1}function px(i,e,t){return Ns(i.re,e.re,t)&&Ns(i.im,e.im,t)}var Gs="equalScalar",mx=["typed","config"],gx=ft(Gs,mx,i=>{var{typed:e,config:t}=i;return e(Gs,{"boolean, boolean":function(r,s){return r===s},"number, number":function(r,s){return Ns(r,s,t.epsilon)},"BigNumber, BigNumber":function(r,s){return r.eq(s)||dx(r,s,t.epsilon)},"Fraction, Fraction":function(r,s){return r.equals(s)},"Complex, Complex":function(r,s){return px(r,s,t.epsilon)},"Unit, Unit":function(r,s){if(!r.equalBase(s))throw new Error("Cannot compare units with different base");return this(r.value,s.value)}})});ft(Gs,["typed","config"],i=>{var{typed:e,config:t}=i;return e(Gs,{"number, number":function(r,s){return Ns(r,s,t.epsilon)}})});var vx="SparseMatrix",_x=["typed","equalScalar","Matrix"],yx=ft(vx,_x,i=>{var{typed:e,equalScalar:t,Matrix:n}=i;function r(m,_){if(!(this instanceof r))throw new SyntaxError("Constructor must be called with the new operator");if(_&&!dn(_))throw new Error("Invalid datatype: "+_);if(Et(m))s(this,m,_);else if(m&&Qe(m.index)&&Qe(m.ptr)&&Qe(m.size))this._values=m.values,this._index=m.index,this._ptr=m.ptr,this._size=m.size,this._datatype=_||m.datatype;else if(Qe(m))a(this,m,_);else{if(m)throw new TypeError("Unsupported type of data ("+Sr(m)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=_}}function s(m,_,p){_.type==="SparseMatrix"?(m._values=_._values?gt(_._values):void 0,m._index=gt(_._index),m._ptr=gt(_._ptr),m._size=gt(_._size),m._datatype=p||_._datatype):a(m,_.valueOf(),p||_._datatype)}function a(m,_,p){m._values=[],m._index=[],m._ptr=[],m._datatype=p;var g=_.length,y=0,x=t,M=0;if(dn(p)&&(x=e.find(t,[p,p])||t,M=e.convert(0,p)),g>0){var S=0;do{m._ptr.push(m._index.length);for(var w=0;w<g;w++){var C=_[w];if(Qe(C)){if(S===0&&y<C.length&&(y=C.length),S<C.length){var I=C[S];x(I,M)||(m._values.push(I),m._index.push(w))}}else S===0&&y<1&&(y=1),x(C,M)||(m._values.push(C),m._index.push(w))}S++}while(S<y)}m._ptr.push(m._index.length),m._size=[g,y]}r.prototype=new n,r.prototype.createSparseMatrix=function(m,_){return new r(m,_)},r.prototype.type="SparseMatrix",r.prototype.isSparseMatrix=!0,r.prototype.getDataType=function(){return Is(this._values,Sr)},r.prototype.storage=function(){return"sparse"},r.prototype.datatype=function(){return this._datatype},r.prototype.create=function(m,_){return new r(m,_)},r.prototype.density=function(){var m=this._size[0],_=this._size[1];return m!==0&&_!==0?this._index.length/(m*_):0},r.prototype.subset=function(m,_,p){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return o(this,m);case 2:case 3:return u(this,m,_,p);default:throw new SyntaxError("Wrong number of arguments")}};function o(m,_){if(!As(_))throw new TypeError("Invalid index");var p=_.isScalar();if(p)return m.get(_.min());var g=_.size();if(g.length!==m._size.length)throw new Ke(g.length,m._size.length);var y,x,M,S,w=_.min(),C=_.max();for(y=0,x=m._size.length;y<x;y++)at(w[y],m._size[y]),at(C[y],m._size[y]);var I=m._values,D=m._index,T=m._ptr,O=_.dimension(0),B=_.dimension(1),F=[],z=[];O.forEach(function(ee,k){z[ee]=k[0],F[ee]=!0});var N=I?[]:void 0,U=[],Y=[];return B.forEach(function(ee){for(Y.push(U.length),M=T[ee],S=T[ee+1];M<S;M++)y=D[M],F[y]===!0&&(U.push(z[y]),N&&N.push(I[M]))}),Y.push(U.length),new r({values:N,index:U,ptr:Y,size:g,datatype:m._datatype})}function u(m,_,p,g){if(!_||_.isIndex!==!0)throw new TypeError("Invalid index");var y=_.size(),x=_.isScalar(),M;if(Et(p)?(M=p.size(),p=p.toArray()):M=Qn(p),x){if(M.length!==0)throw new TypeError("Scalar expected");m.set(_.min(),p,g)}else{if(y.length!==1&&y.length!==2)throw new Ke(y.length,m._size.length,"<");if(M.length<y.length){for(var S=0,w=0;y[S]===1&&M[S]===1;)S++;for(;y[S]===1;)w++,S++;p=Eu(p,y.length,w,M)}if(!Cs(y,M))throw new Ke(y,M,">");for(var C=_.min()[0],I=_.min()[1],D=M[0],T=M[1],O=0;O<D;O++)for(var B=0;B<T;B++){var F=p[O][B];m.set([O+C,B+I],F,g)}}return m}r.prototype.get=function(m){if(!Qe(m))throw new TypeError("Array expected");if(m.length!==this._size.length)throw new Ke(m.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var _=m[0],p=m[1];at(_,this._size[0]),at(p,this._size[1]);var g=h(_,this._ptr[p],this._ptr[p+1],this._index);return g<this._ptr[p+1]&&this._index[g]===_?this._values[g]:0},r.prototype.set=function(m,_,p){if(!Qe(m))throw new TypeError("Array expected");if(m.length!==this._size.length)throw new Ke(m.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var g=m[0],y=m[1],x=this._size[0],M=this._size[1],S=t,w=0;dn(this._datatype)&&(S=e.find(t,[this._datatype,this._datatype])||t,w=e.convert(0,this._datatype)),(g>x-1||y>M-1)&&(f(this,Math.max(g+1,x),Math.max(y+1,M),p),x=this._size[0],M=this._size[1]),at(g,x),at(y,M);var C=h(g,this._ptr[y],this._ptr[y+1],this._index);return C<this._ptr[y+1]&&this._index[C]===g?S(_,w)?c(C,y,this._values,this._index,this._ptr):this._values[C]=_:l(C,g,y,_,this._values,this._index,this._ptr),this};function h(m,_,p,g){if(p-_==0)return p;for(var y=_;y<p;y++)if(g[y]===m)return y;return _}function c(m,_,p,g,y){p.splice(m,1),g.splice(m,1);for(var x=_+1;x<y.length;x++)y[x]--}function l(m,_,p,g,y,x,M){y.splice(m,0,g),x.splice(m,0,_);for(var S=p+1;S<M.length;S++)M[S]++}r.prototype.resize=function(m,_,p){if(!cu(m))throw new TypeError("Array or Matrix expected");var g=m.valueOf().map(x=>Array.isArray(x)&&x.length===1?x[0]:x);if(g.length!==2)throw new Error("Only two dimensions matrix are supported");g.forEach(function(x){if(!nt(x)||!vt(x)||x<0)throw new TypeError("Invalid size, must contain positive integers (size: "+Rt(g)+")")});var y=p?this.clone():this;return f(y,g[0],g[1],_)};function f(m,_,p,g){var y=g||0,x=t,M=0;dn(m._datatype)&&(x=e.find(t,[m._datatype,m._datatype])||t,M=e.convert(0,m._datatype),y=e.convert(y,m._datatype));var S=!x(y,M),w=m._size[0],C=m._size[1],I,D,T;if(p>C){for(D=C;D<p;D++)if(m._ptr[D]=m._values.length,S)for(I=0;I<w;I++)m._values.push(y),m._index.push(I);m._ptr[p]=m._values.length}else p<C&&(m._ptr.splice(p+1,C-p),m._values.splice(m._ptr[p],m._values.length),m._index.splice(m._ptr[p],m._index.length));if(C=p,_>w){if(S){var O=0;for(D=0;D<C;D++){m._ptr[D]=m._ptr[D]+O,T=m._ptr[D+1]+O;var B=0;for(I=w;I<_;I++,B++)m._values.splice(T+B,0,y),m._index.splice(T+B,0,I),O++}m._ptr[C]=m._values.length}}else if(_<w){var F=0;for(D=0;D<C;D++){m._ptr[D]=m._ptr[D]-F;var z=m._ptr[D],N=m._ptr[D+1]-F;for(T=z;T<N;T++)I=m._index[T],I>_-1&&(m._values.splice(T,1),m._index.splice(T,1),F++)}m._ptr[D]=m._values.length}return m._size[0]=_,m._size[1]=p,m}r.prototype.reshape=function(m,_){if(!Qe(m))throw new TypeError("Array expected");if(m.length!==2)throw new Error("Sparse matrices can only be reshaped in two dimensions");m.forEach(function(ee){if(!nt(ee)||!vt(ee)||ee<=-2||ee===0)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+Rt(m)+")")});var p=this._size[0]*this._size[1];m=To(m,p);var g=m[0]*m[1];if(p!==g)throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var y=_?this.clone():this;if(this._size[0]===m[0]&&this._size[1]===m[1])return y;for(var x=[],M=0;M<y._ptr.length;M++)for(var S=0;S<y._ptr[M+1]-y._ptr[M];S++)x.push(M);for(var w=y._values.slice(),C=y._index.slice(),I=0;I<y._index.length;I++){var D=C[I],T=x[I],O=D*y._size[1]+T;x[I]=O%m[1],C[I]=Math.floor(O/m[1])}y._values.length=0,y._index.length=0,y._ptr.length=m[1]+1,y._size=m.slice();for(var B=0;B<y._ptr.length;B++)y._ptr[B]=0;for(var F=0;F<w.length;F++){var z=C[F],N=x[F],U=w[F],Y=h(z,y._ptr[N],y._ptr[N+1],y._index);l(Y,z,N,U,y._values,y._index,y._ptr)}return y},r.prototype.clone=function(){var m=new r({values:this._values?gt(this._values):void 0,index:gt(this._index),ptr:gt(this._ptr),size:gt(this._size),datatype:this._datatype});return m},r.prototype.size=function(){return this._size.slice(0)},r.prototype.map=function(m,_){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var p=this,g=this._size[0],y=this._size[1],x=function(S,w,C){return m(S,[w,C],p)};return d(this,0,g-1,0,y-1,x,_)};function d(m,_,p,g,y,x,M){var S=[],w=[],C=[],I=t,D=0;dn(m._datatype)&&(I=e.find(t,[m._datatype,m._datatype])||t,D=e.convert(0,m._datatype));for(var T=function(se,de,Se){se=x(se,de,Se),I(se,D)||(S.push(se),w.push(de))},O=g;O<=y;O++){C.push(S.length);var B=m._ptr[O],F=m._ptr[O+1];if(M)for(var z=B;z<F;z++){var N=m._index[z];N>=_&&N<=p&&T(m._values[z],N-_,O-g)}else{for(var U={},Y=B;Y<F;Y++){var ee=m._index[Y];U[ee]=m._values[Y]}for(var k=_;k<=p;k++){var q=k in U?U[k]:0;T(q,k-_,O-g)}}}return C.push(S.length),new r({values:S,index:w,ptr:C,size:[p-_+1,y-g+1]})}r.prototype.forEach=function(m,_){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var p=this,g=this._size[0],y=this._size[1],x=0;x<y;x++){var M=this._ptr[x],S=this._ptr[x+1];if(_)for(var w=M;w<S;w++){var C=this._index[w];m(this._values[w],[C,x],p)}else{for(var I={},D=M;D<S;D++){var T=this._index[D];I[T]=this._values[D]}for(var O=0;O<g;O++){var B=O in I?I[O]:0;m(B,[O,x],p)}}}},r.prototype[Symbol.iterator]=function*(){if(!this._values)throw new Error("Cannot iterate a Pattern only matrix");for(var m=this._size[1],_=0;_<m;_++)for(var p=this._ptr[_],g=this._ptr[_+1],y=p;y<g;y++){var x=this._index[y];yield{value:this._values[y],index:[x,_]}}},r.prototype.toArray=function(){return v(this._values,this._index,this._ptr,this._size,!0)},r.prototype.valueOf=function(){return v(this._values,this._index,this._ptr,this._size,!1)};function v(m,_,p,g,y){var x=g[0],M=g[1],S=[],w,C;for(w=0;w<x;w++)for(S[w]=[],C=0;C<M;C++)S[w][C]=0;for(C=0;C<M;C++)for(var I=p[C],D=p[C+1],T=I;T<D;T++)w=_[T],S[w][C]=m?y?gt(m[T]):m[T]:1;return S}return r.prototype.format=function(m){for(var _=this._size[0],p=this._size[1],g=this.density(),y="Sparse Matrix ["+Rt(_,m)+" x "+Rt(p,m)+"] density: "+Rt(g,m)+`
`,x=0;x<p;x++)for(var M=this._ptr[x],S=this._ptr[x+1],w=M;w<S;w++){var C=this._index[w];y+=`
    (`+Rt(C,m)+", "+Rt(x,m)+") ==> "+(this._values?Rt(this._values[w],m):"X")}return y},r.prototype.toString=function(){return Rt(this.toArray())},r.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},r.prototype.diagonal=function(m){if(m){if(Yt(m)&&(m=m.toNumber()),!nt(m)||!vt(m))throw new TypeError("The parameter k must be an integer number")}else m=0;var _=m>0?m:0,p=m<0?-m:0,g=this._size[0],y=this._size[1],x=Math.min(g-p,y-_),M=[],S=[],w=[];w[0]=0;for(var C=_;C<y&&M.length<x;C++)for(var I=this._ptr[C],D=this._ptr[C+1],T=I;T<D;T++){var O=this._index[T];if(O===C-_+p){M.push(this._values[T]),S[M.length-1]=O-p;break}}return w.push(M.length),new r({values:M,index:S,ptr:w,size:[x,1]})},r.fromJSON=function(m){return new r(m)},r.diagonal=function(m,_,p,g,y){if(!Qe(m))throw new TypeError("Array expected, size parameter");if(m.length!==2)throw new Error("Only two dimensions matrix are supported");if(m=m.map(function(ee){if(Yt(ee)&&(ee=ee.toNumber()),!nt(ee)||!vt(ee)||ee<1)throw new Error("Size values must be positive integers");return ee}),p){if(Yt(p)&&(p=p.toNumber()),!nt(p)||!vt(p))throw new TypeError("The parameter k must be an integer number")}else p=0;var x=t,M=0;dn(y)&&(x=e.find(t,[y,y])||t,M=e.convert(0,y));var S=p>0?p:0,w=p<0?-p:0,C=m[0],I=m[1],D=Math.min(C-w,I-S),T;if(Qe(_)){if(_.length!==D)throw new Error("Invalid value array length");T=function(k){return _[k]}}else if(Et(_)){var O=_.size();if(O.length!==1||O[0]!==D)throw new Error("Invalid matrix length");T=function(k){return _.get([k])}}else T=function(){return _};for(var B=[],F=[],z=[],N=0;N<I;N++){z.push(B.length);var U=N-S;if(U>=0&&U<D){var Y=T(U);x(Y,M)||(F.push(U+w),B.push(Y))}}return z.push(B.length),new r({values:B,index:F,ptr:z,size:[C,I]})},r.prototype.swapRows=function(m,_){if(!nt(m)||!vt(m)||!nt(_)||!vt(_))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return at(m,this._size[0]),at(_,this._size[0]),r._swapRows(m,_,this._size[1],this._values,this._index,this._ptr),this},r._forEachRow=function(m,_,p,g,y){for(var x=g[m],M=g[m+1],S=x;S<M;S++)y(p[S],_[S])},r._swapRows=function(m,_,p,g,y,x){for(var M=0;M<p;M++){var S=x[M],w=x[M+1],C=h(m,S,w,y),I=h(_,S,w,y);if(C<w&&I<w&&y[C]===m&&y[I]===_){if(g){var D=g[C];g[C]=g[I],g[I]=D}continue}if(C<w&&y[C]===m&&(I>=w||y[I]!==_)){var T=g?g[C]:void 0;y.splice(I,0,_),g&&g.splice(I,0,T),y.splice(I<=C?C+1:C,1),g&&g.splice(I<=C?C+1:C,1);continue}if(I<w&&y[I]===_&&(C>=w||y[C]!==m)){var O=g?g[I]:void 0;y.splice(C,0,m),g&&g.splice(C,0,O),y.splice(C<=I?I+1:I,1),g&&g.splice(C<=I?I+1:I,1)}}},r},{isClass:!0}),ju="matrix",xx=["typed","Matrix","DenseMatrix","SparseMatrix"],wx=ft(ju,xx,i=>{var{typed:e,Matrix:t,DenseMatrix:n,SparseMatrix:r}=i;return e(ju,{"":function(){return s([])},string:function(o){return s([],o)},"string, string":function(o,u){return s([],o,u)},Array:function(o){return s(o)},Matrix:function(o){return s(o,o.storage())},"Array | Matrix, string":s,"Array | Matrix, string, string":s});function s(a,o,u){if(o==="dense"||o==="default"||o===void 0)return new n(a,u);if(o==="sparse")return new r(a,u);throw new TypeError("Unknown matrix type "+JSON.stringify(o)+".")}}),$u="addScalar",Mx=["typed"],bx=ft($u,Mx,i=>{var{typed:e}=i;return e($u,{"number, number":Yu,"Complex, Complex":function(n,r){return n.add(r)},"BigNumber, BigNumber":function(n,r){return n.plus(r)},"Fraction, Fraction":function(n,r){return n.add(r)},"Unit, Unit":function(n,r){if(n.value===null||n.value===void 0)throw new Error("Parameter x contains a unit with undefined value");if(r.value===null||r.value===void 0)throw new Error("Parameter y contains a unit with undefined value");if(!n.equalBase(r))throw new Error("Units do not match");var s=n.clone();return s.value=this(s.value,r.value),s.fixPrefix=!1,s}})}),Sx="algorithm11",Ex=["typed","equalScalar"],Tx=ft(Sx,Ex,i=>{var{typed:e,equalScalar:t}=i;return function(r,s,a,o){var u=r._values,h=r._index,c=r._ptr,l=r._size,f=r._datatype;if(!u)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var d=l[0],v=l[1],m,_=t,p=0,g=a;typeof f=="string"&&(m=f,_=e.find(t,[m,m]),p=e.convert(0,m),s=e.convert(s,m),g=e.find(a,[m,m]));for(var y=[],x=[],M=[],S=0;S<v;S++){M[S]=x.length;for(var w=c[S],C=c[S+1],I=w;I<C;I++){var D=h[I],T=o?g(s,u[I]):g(u[I],s);_(T,p)||(x.push(D),y.push(T))}}return M[v]=x.length,r.createSparseMatrix({values:y,index:x,ptr:M,size:[d,v],datatype:m})}}),Ax="algorithm14",Cx=["typed"],Lx=ft(Ax,Cx,i=>{var{typed:e}=i;return function(r,s,a,o){var u=r._data,h=r._size,c=r._datatype,l,f=a;typeof c=="string"&&(l=c,s=e.convert(s,l),f=e.find(a,[l,l]));var d=h.length>0?t(f,0,h,h[0],u,s,o):[];return r.createDenseMatrix({data:d,size:gt(h),datatype:l})};function t(n,r,s,a,o,u,h){var c=[];if(r===s.length-1)for(var l=0;l<a;l++)c[l]=h?n(u,o[l]):n(o[l],u);else for(var f=0;f<a;f++)c[f]=t(n,r+1,s,s[r+1],o[f],u,h);return c}}),Rx="multiplyScalar",Px=["typed"],Nx=ft(Rx,Px,i=>{var{typed:e}=i;return e("multiplyScalar",{"number, number":Ju,"Complex, Complex":function(n,r){return n.mul(r)},"BigNumber, BigNumber":function(n,r){return n.times(r)},"Fraction, Fraction":function(n,r){return n.mul(r)},"number | Fraction | BigNumber | Complex, Unit":function(n,r){var s=r.clone();return s.value=s.value===null?s._normalize(n):this(s.value,n),s},"Unit, number | Fraction | BigNumber | Complex":function(n,r){var s=n.clone();return s.value=s.value===null?s._normalize(r):this(s.value,r),s},"Unit, Unit":function(n,r){return n.multiply(r)}})}),Qu="multiply",Ix=["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],Dx=ft(Qu,Ix,i=>{var{typed:e,matrix:t,addScalar:n,multiplyScalar:r,equalScalar:s,dot:a}=i,o=Tx({typed:e,equalScalar:s}),u=Lx({typed:e});function h(M,S){switch(M.length){case 1:switch(S.length){case 1:if(M[0]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(M[0]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+M[0]+") must match Matrix rows ("+S[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+S.length+" dimensions)")}break;case 2:switch(S.length){case 1:if(M[1]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+M[1]+") must match Vector length ("+S[0]+")");break;case 2:if(M[1]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+M[1]+") must match Matrix B rows ("+S[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+S.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+M.length+" dimensions)")}}function c(M,S,w){if(w===0)throw new Error("Cannot multiply two empty vectors");return a(M,S)}function l(M,S){if(S.storage()!=="dense")throw new Error("Support for SparseMatrix not implemented");return f(M,S)}function f(M,S){var w=M._data,C=M._size,I=M._datatype,D=S._data,T=S._size,O=S._datatype,B=C[0],F=T[1],z,N=n,U=r;I&&O&&I===O&&typeof I=="string"&&(z=I,N=e.find(n,[z,z]),U=e.find(r,[z,z]));for(var Y=[],ee=0;ee<F;ee++){for(var k=U(w[0],D[0][ee]),q=1;q<B;q++)k=N(k,U(w[q],D[q][ee]));Y[ee]=k}return M.createDenseMatrix({data:Y,size:[F],datatype:z})}var d=e("_multiplyMatrixVector",{"DenseMatrix, any":m,"SparseMatrix, any":g}),v=e("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":_,"DenseMatrix, SparseMatrix":p,"SparseMatrix, DenseMatrix":y,"SparseMatrix, SparseMatrix":x});function m(M,S){var w=M._data,C=M._size,I=M._datatype,D=S._data,T=S._datatype,O=C[0],B=C[1],F,z=n,N=r;I&&T&&I===T&&typeof I=="string"&&(F=I,z=e.find(n,[F,F]),N=e.find(r,[F,F]));for(var U=[],Y=0;Y<O;Y++){for(var ee=w[Y],k=N(ee[0],D[0]),q=1;q<B;q++)k=z(k,N(ee[q],D[q]));U[Y]=k}return M.createDenseMatrix({data:U,size:[O],datatype:F})}function _(M,S){var w=M._data,C=M._size,I=M._datatype,D=S._data,T=S._size,O=S._datatype,B=C[0],F=C[1],z=T[1],N,U=n,Y=r;I&&O&&I===O&&typeof I=="string"&&(N=I,U=e.find(n,[N,N]),Y=e.find(r,[N,N]));for(var ee=[],k=0;k<B;k++){var q=w[k];ee[k]=[];for(var oe=0;oe<z;oe++){for(var se=Y(q[0],D[0][oe]),de=1;de<F;de++)se=U(se,Y(q[de],D[de][oe]));ee[k][oe]=se}}return M.createDenseMatrix({data:ee,size:[B,z],datatype:N})}function p(M,S){var w=M._data,C=M._size,I=M._datatype,D=S._values,T=S._index,O=S._ptr,B=S._size,F=S._datatype;if(!D)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var z=C[0],N=B[1],U,Y=n,ee=r,k=s,q=0;I&&F&&I===F&&typeof I=="string"&&(U=I,Y=e.find(n,[U,U]),ee=e.find(r,[U,U]),k=e.find(s,[U,U]),q=e.convert(0,U));for(var oe=[],se=[],de=[],Se=S.createSparseMatrix({values:oe,index:se,ptr:de,size:[z,N],datatype:U}),Q=0;Q<N;Q++){de[Q]=se.length;var ve=O[Q],xe=O[Q+1];if(xe>ve)for(var fe=0,pe=0;pe<z;pe++){for(var Pe=pe+1,Z=void 0,K=ve;K<xe;K++){var ae=T[K];fe!==Pe?(Z=ee(w[pe][ae],D[K]),fe=Pe):Z=Y(Z,ee(w[pe][ae],D[K]))}fe===Pe&&!k(Z,q)&&(se.push(pe),oe.push(Z))}}return de[N]=se.length,Se}function g(M,S){var w=M._values,C=M._index,I=M._ptr,D=M._datatype;if(!w)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var T=S._data,O=S._datatype,B=M._size[0],F=S._size[0],z=[],N=[],U=[],Y,ee=n,k=r,q=s,oe=0;D&&O&&D===O&&typeof D=="string"&&(Y=D,ee=e.find(n,[Y,Y]),k=e.find(r,[Y,Y]),q=e.find(s,[Y,Y]),oe=e.convert(0,Y));var se=[],de=[];U[0]=0;for(var Se=0;Se<F;Se++){var Q=T[Se];if(!q(Q,oe))for(var ve=I[Se],xe=I[Se+1],fe=ve;fe<xe;fe++){var pe=C[fe];de[pe]?se[pe]=ee(se[pe],k(Q,w[fe])):(de[pe]=!0,N.push(pe),se[pe]=k(Q,w[fe]))}}for(var Pe=N.length,Z=0;Z<Pe;Z++){var K=N[Z];z[Z]=se[K]}return U[1]=N.length,M.createSparseMatrix({values:z,index:N,ptr:U,size:[B,1],datatype:Y})}function y(M,S){var w=M._values,C=M._index,I=M._ptr,D=M._datatype;if(!w)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var T=S._data,O=S._datatype,B=M._size[0],F=S._size[0],z=S._size[1],N,U=n,Y=r,ee=s,k=0;D&&O&&D===O&&typeof D=="string"&&(N=D,U=e.find(n,[N,N]),Y=e.find(r,[N,N]),ee=e.find(s,[N,N]),k=e.convert(0,N));for(var q=[],oe=[],se=[],de=M.createSparseMatrix({values:q,index:oe,ptr:se,size:[B,z],datatype:N}),Se=[],Q=[],ve=0;ve<z;ve++){se[ve]=oe.length;for(var xe=ve+1,fe=0;fe<F;fe++){var pe=T[fe][ve];if(!ee(pe,k))for(var Pe=I[fe],Z=I[fe+1],K=Pe;K<Z;K++){var ae=C[K];Q[ae]!==xe?(Q[ae]=xe,oe.push(ae),Se[ae]=Y(pe,w[K])):Se[ae]=U(Se[ae],Y(pe,w[K]))}}for(var me=se[ve],he=oe.length,Te=me;Te<he;Te++){var Le=oe[Te];q[Te]=Se[Le]}}return se[z]=oe.length,de}function x(M,S){var w=M._values,C=M._index,I=M._ptr,D=M._datatype,T=S._values,O=S._index,B=S._ptr,F=S._datatype,z=M._size[0],N=S._size[1],U=w&&T,Y,ee=n,k=r;D&&F&&D===F&&typeof D=="string"&&(Y=D,ee=e.find(n,[Y,Y]),k=e.find(r,[Y,Y]));for(var q=U?[]:void 0,oe=[],se=[],de=M.createSparseMatrix({values:q,index:oe,ptr:se,size:[z,N],datatype:Y}),Se=U?[]:void 0,Q=[],ve,xe,fe,pe,Pe,Z,K,ae,me=0;me<N;me++){se[me]=oe.length;var he=me+1;for(Pe=B[me],Z=B[me+1],pe=Pe;pe<Z;pe++)if(ae=O[pe],U)for(xe=I[ae],fe=I[ae+1],ve=xe;ve<fe;ve++)K=C[ve],Q[K]!==he?(Q[K]=he,oe.push(K),Se[K]=k(T[pe],w[ve])):Se[K]=ee(Se[K],k(T[pe],w[ve]));else for(xe=I[ae],fe=I[ae+1],ve=xe;ve<fe;ve++)K=C[ve],Q[K]!==he&&(Q[K]=he,oe.push(K));if(U)for(var Te=se[me],Le=oe.length,R=Te;R<Le;R++){var H=oe[R];q[R]=Se[H]}}return se[N]=oe.length,de}return e(Qu,C_({"Array, Array":function(S,w){h(Qn(S),Qn(w));var C=this(t(S),t(w));return Et(C)?C.valueOf():C},"Matrix, Matrix":function(S,w){var C=S.size(),I=w.size();return h(C,I),C.length===1?I.length===1?c(S,w,C[0]):l(S,w):I.length===1?d(S,w):v(S,w)},"Matrix, Array":function(S,w){return this(S,t(w))},"Array, Matrix":function(S,w){return this(t(S,w.storage()),w)},"SparseMatrix, any":function(S,w){return o(S,w,r,!1)},"DenseMatrix, any":function(S,w){return u(S,w,r,!1)},"any, SparseMatrix":function(S,w){return o(w,S,r,!0)},"any, DenseMatrix":function(S,w){return u(w,S,r,!0)},"Array, any":function(S,w){return u(t(S),w,r,!1).valueOf()},"any, Array":function(S,w){return u(t(w),S,r,!0).valueOf()},"any, any":r,"any, any, ...any":function(S,w,C){for(var I=this(S,w),D=0;D<C.length;D++)I=this(I,C[D]);return I}},r.signatures))}),Ku="conj",Fx=["typed"],zx=ft(Ku,Fx,i=>{var{typed:e}=i;return e(Ku,{number:function(n){return n},BigNumber:function(n){return n},Complex:function(n){return n.conjugate()},"Array | Matrix":function(n){return Xu(n,this)}})});function Bx(){throw new Error('No "matrix" implementation available')}var eh="size",Ox=["typed","config","?matrix"],Ux=ft(eh,Ox,i=>{var{typed:e,config:t,matrix:n}=i;return e(eh,{Matrix:function(s){return s.create(s.size())},Array:Qn,string:function(s){return t.matrix==="Array"?[s.length]:n([s.length])},"number | Complex | BigNumber | Unit | boolean | null":function(s){return t.matrix==="Array"?[]:n?n([]):Bx()}})}),th="dot",Vx=["typed","addScalar","multiplyScalar","conj","size"],Hx=ft(th,Vx,i=>{var{typed:e,addScalar:t,multiplyScalar:n,conj:r,size:s}=i;return e(th,{"Array | DenseMatrix, Array | DenseMatrix":o,"SparseMatrix, SparseMatrix":u});function a(c,l){var f=h(c),d=h(l),v,m;if(f.length===1)v=f[0];else if(f.length===2&&f[1]===1)v=f[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+f.join(", ")+")");if(d.length===1)m=d[0];else if(d.length===2&&d[1]===1)m=d[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+d.join(", ")+")");if(v!==m)throw new RangeError("Vectors must have equal length ("+v+" != "+m+")");if(v===0)throw new RangeError("Cannot calculate the dot product of empty vectors");return v}function o(c,l){var f=a(c,l),d=Et(c)?c._data:c,v=Et(c)?c._datatype:void 0,m=Et(l)?l._data:l,_=Et(l)?l._datatype:void 0,p=h(c).length===2,g=h(l).length===2,y=t,x=n;if(v&&_&&v===_&&typeof v=="string"){var M=v;y=e.find(t,[M,M]),x=e.find(n,[M,M])}if(!p&&!g){for(var S=x(r(d[0]),m[0]),w=1;w<f;w++)S=y(S,x(r(d[w]),m[w]));return S}if(!p&&g){for(var C=x(r(d[0]),m[0][0]),I=1;I<f;I++)C=y(C,x(r(d[I]),m[I][0]));return C}if(p&&!g){for(var D=x(r(d[0][0]),m[0]),T=1;T<f;T++)D=y(D,x(r(d[T][0]),m[T]));return D}if(p&&g){for(var O=x(r(d[0][0]),m[0][0]),B=1;B<f;B++)O=y(O,x(r(d[B][0]),m[B][0]));return O}}function u(c,l){a(c,l);for(var f=c._index,d=c._values,v=l._index,m=l._values,_=0,p=t,g=n,y=0,x=0;y<f.length&&x<v.length;){var M=f[y],S=v[x];if(M<S){y++;continue}if(M>S){x++;continue}M===S&&(_=p(_,g(d[y],m[x])),y++,x++)}return _}function h(c){return Et(c)?c.size():s(c)}}),Gx=ex({config:Ls}),kx=ix({}),Wx=ax({}),Fo=cx({}),nh=fx({Matrix:Fo}),mn=iy({BigNumber:Gx,Complex:kx,DenseMatrix:nh,Fraction:Wx}),ih=bx({typed:mn}),qx=zx({typed:mn}),rh=gx({config:Ls,typed:mn}),sh=Nx({typed:mn}),Xx=yx({Matrix:Fo,equalScalar:rh,typed:mn}),ah=wx({DenseMatrix:nh,Matrix:Fo,SparseMatrix:Xx,typed:mn}),Zx=Ux({matrix:ah,config:Ls,typed:mn}),Yx=Hx({addScalar:ih,conj:qx,multiplyScalar:sh,size:Zx,typed:mn}),jx=Dx({addScalar:ih,dot:Yx,equalScalar:rh,matrix:ah,multiplyScalar:sh,typed:mn});export{Ye as B,T0 as C,mr as L,Aa as M,Lt as P,Zc as S,P as V,ke as W,Ct as a,lt as b,$a as c,jx as d,mc as e,ah as m};
