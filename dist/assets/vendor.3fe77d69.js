var ah=Object.defineProperty;var za=Object.getOwnPropertySymbols;var lh=Object.prototype.hasOwnProperty,ch=Object.prototype.propertyIsEnumerable;var Oa=(i,e,t)=>e in i?ah(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ba=(i,e)=>{for(var t in e||(e={}))lh.call(e,t)&&Oa(i,t,e[t]);if(za)for(var t of za(e))ch.call(e,t)&&Oa(i,t,e[t]);return i};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const sa="135";const uh=0,Ua=1,hh=2,Mc=1,fh=2,rr=3,hr=0,at=1,Li=2,bc=1,Cn=0,ar=1,Ha=2,Va=3,Ga=4,dh=5,xi=100,ph=101,mh=102,ka=103,Wa=104,gh=200,vh=201,yh=202,_h=203,Sc=204,Ec=205,xh=206,wh=207,Mh=208,bh=209,Sh=210,Eh=0,Th=1,Ah=2,Bo=3,Ch=4,Lh=5,Rh=6,Ph=7,Ss=0,Nh=1,Dh=2,Xn=0,Ih=1,Fh=2,zh=3,Oh=4,Bh=5,Tc=300,xr=301,wr=302,Uo=303,Ho=304,Es=306,oa=307,Vo=1e3,Bt=1001,Go=1002,ht=1003,qa=1004,Xa=1005,Ht=1006,Uh=1007,Ts=1008,Nn=1009,Hh=1010,Vh=1011,fr=1012,Gh=1013,cs=1014,Tn=1015,Ei=1016,kh=1017,Wh=1018,qh=1019,Ti=1020,Xh=1021,Zn=1022,St=1023,Zh=1024,Yh=1025,jh=St,Yn=1026,Ri=1027,Jh=1028,$h=1029,Qh=1030,Kh=1031,ef=1032,tf=1033,Za=33776,Ya=33777,ja=33778,Ja=33779,$a=35840,Qa=35841,Ka=35842,el=35843,nf=36196,tl=37492,nl=37496,rf=37808,sf=37809,of=37810,af=37811,lf=37812,cf=37813,uf=37814,hf=37815,ff=37816,df=37817,pf=37818,mf=37819,gf=37820,vf=37821,yf=36492,_f=37840,xf=37841,wf=37842,Mf=37843,bf=37844,Sf=37845,Ef=37846,Tf=37847,Af=37848,Cf=37849,Lf=37850,Rf=37851,Pf=37852,Nf=37853,Df=2200,If=2201,Ff=2202,hs=2300,fs=2301,js=2302,wi=2400,Mi=2401,ds=2402,aa=2500,Ac=2501,zf=0,Pt=3e3,As=3001,la=3007,ca=3002,Cc=3004,Lc=3005,Rc=3006,Of=3200,Bf=3201,Fi=0,Uf=1,Js=7680,Hf=519,dr=35044,ps=35048,il="300 es";class Qn{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const r=n.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}const dt=[];for(let i=0;i<256;i++)dt[i]=(i<16?"0":"")+i.toString(16);const $s=Math.PI/180,ko=180/Math.PI;function en(){const i=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(dt[i&255]+dt[i>>8&255]+dt[i>>16&255]+dt[i>>24&255]+"-"+dt[e&255]+dt[e>>8&255]+"-"+dt[e>>16&15|64]+dt[e>>24&255]+"-"+dt[t&63|128]+dt[t>>8&255]+"-"+dt[t>>16&255]+dt[t>>24&255]+dt[n&255]+dt[n>>8&255]+dt[n>>16&255]+dt[n>>24&255]).toUpperCase()}function Ot(i,e,t){return Math.max(e,Math.min(t,i))}function Vf(i,e){return(i%e+e)%e}function Qs(i,e,t){return(1-t)*i+t*e}function rl(i){return(i&i-1)===0&&i!==0}function Gf(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}class le{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*n-o*r+e.x,this.y=s*r+o*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}le.prototype.isVector2=!0;class gt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,s,o,a,u,h){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=s,c[5]=u,c[6]=n,c[7]=o,c[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,s=this.elements,o=n[0],a=n[3],u=n[6],h=n[1],c=n[4],l=n[7],f=n[2],d=n[5],v=n[8],m=r[0],y=r[3],p=r[6],g=r[1],_=r[4],x=r[7],M=r[2],S=r[5],w=r[8];return s[0]=o*m+a*g+u*M,s[3]=o*y+a*_+u*S,s[6]=o*p+a*x+u*w,s[1]=h*m+c*g+l*M,s[4]=h*y+c*_+l*S,s[7]=h*p+c*x+l*w,s[2]=f*m+d*g+v*M,s[5]=f*y+d*_+v*S,s[8]=f*p+d*x+v*w,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],o=e[4],a=e[5],u=e[6],h=e[7],c=e[8];return t*o*c-t*a*h-n*s*c+n*a*u+r*s*h-r*o*u}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],o=e[4],a=e[5],u=e[6],h=e[7],c=e[8],l=c*o-a*h,f=a*u-c*s,d=h*s-o*u,v=t*l+n*f+r*d;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/v;return e[0]=l*m,e[1]=(r*h-c*n)*m,e[2]=(a*n-r*o)*m,e[3]=f*m,e[4]=(c*t-r*u)*m,e[5]=(r*s-a*t)*m,e[6]=d*m,e[7]=(n*u-h*t)*m,e[8]=(o*t-n*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,s,o,a){const u=Math.cos(s),h=Math.sin(s);return this.set(n*u,n*h,-n*(u*o+h*a)+o+e,-r*h,r*u,-r*(-h*o+u*a)+a+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,s=r[0],o=r[3],a=r[6],u=r[1],h=r[4],c=r[7];return r[0]=t*s+n*u,r[3]=t*o+n*h,r[6]=t*a+n*c,r[1]=-n*s+t*u,r[4]=-n*o+t*h,r[7]=-n*a+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<9;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}gt.prototype.isMatrix3=!0;function Pc(i){if(i.length===0)return-1/0;let e=i[0];for(let t=1,n=i.length;t<n;++t)i[t]>e&&(e=i[t]);return e}function Cs(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function sl(i,e=0){let t=3735928559^e,n=1103547991^e;for(let r=0,s;r<i.length;r++)s=i.charCodeAt(r),t=Math.imul(t^s,2654435761),n=Math.imul(n^s,1597334677);return t=Math.imul(t^t>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(t^t>>>13,3266489909),4294967296*(2097151&n)+(t>>>0)}let ei;class zi{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{ei===void 0&&(ei=Cs("canvas")),ei.width=e.width,ei.height=e.height;const n=ei.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=ei}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let kf=0;class yt extends Qn{constructor(e=yt.DEFAULT_IMAGE,t=yt.DEFAULT_MAPPING,n=Bt,r=Bt,s=Ht,o=Ts,a=St,u=Nn,h=1,c=Pt){super();Object.defineProperty(this,"id",{value:kf++}),this.uuid=en(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=u,this.offset=new le(0,0),this.repeat=new le(1,1),this.center=new le(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new gt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=en()),!t&&e.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(Ks(r[o].image)):s.push(Ks(r[o]))}else s=Ks(r);e.images[r.uuid]={uuid:r.uuid,url:s}}n.image=r.uuid}return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Tc)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Vo:e.x=e.x-Math.floor(e.x);break;case Bt:e.x=e.x<0?0:1;break;case Go:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Vo:e.y=e.y-Math.floor(e.y);break;case Bt:e.y=e.y<0?0:1;break;case Go:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}yt.DEFAULT_IMAGE=void 0;yt.DEFAULT_MAPPING=Tc;yt.prototype.isTexture=!0;function Ks(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?zi.getDataURL(i):i.data?{data:Array.prototype.slice.call(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class We{constructor(e=0,t=0,n=0,r=1){this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*n+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*n+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*n+o[11]*r+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,s;const u=e.elements,h=u[0],c=u[4],l=u[8],f=u[1],d=u[5],v=u[9],m=u[2],y=u[6],p=u[10];if(Math.abs(c-f)<.01&&Math.abs(l-m)<.01&&Math.abs(v-y)<.01){if(Math.abs(c+f)<.1&&Math.abs(l+m)<.1&&Math.abs(v+y)<.1&&Math.abs(h+d+p-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const _=(h+1)/2,x=(d+1)/2,M=(p+1)/2,S=(c+f)/4,w=(l+m)/4,C=(v+y)/4;return _>x&&_>M?_<.01?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(_),r=S/n,s=w/n):x>M?x<.01?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(x),n=S/r,s=C/r):M<.01?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(M),n=w/s,r=C/s),this.set(n,r,s,t),this}let g=Math.sqrt((y-v)*(y-v)+(l-m)*(l-m)+(f-c)*(f-c));return Math.abs(g)<.001&&(g=1),this.x=(y-v)/g,this.y=(l-m)/g,this.z=(f-c)/g,this.w=Math.acos((h+d+p-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}We.prototype.isVector4=!0;class Vt extends Qn{constructor(e,t,n={}){super();this.width=e,this.height=t,this.depth=1,this.scissor=new We(0,0,e,t),this.scissorTest=!1,this.viewport=new We(0,0,e,t),this.texture=new yt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Ht,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image=Ba({},this.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Vt.prototype.isWebGLRenderTarget=!0;class Wf extends Vt{constructor(e,t,n){super(e,t);const r=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=r.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}Wf.prototype.isWebGLMultipleRenderTargets=!0;class ua extends Vt{constructor(e,t,n={}){super(e,t,n);this.samples=4,this.ignoreDepthForMultisampleCopy=n.ignoreDepth!==void 0?n.ignoreDepth:!0,this.useRenderToTexture=n.useRenderToTexture!==void 0?n.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(e){return super.copy.call(this,e),this.samples=e.samples,this.useRenderToTexture=e.useRenderToTexture,this.useRenderbuffer=e.useRenderbuffer,this}}ua.prototype.isWebGLMultisampleRenderTarget=!0;class Rt{constructor(e=0,t=0,n=0,r=1){this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,s,o,a){let u=n[r+0],h=n[r+1],c=n[r+2],l=n[r+3];const f=s[o+0],d=s[o+1],v=s[o+2],m=s[o+3];if(a===0){e[t+0]=u,e[t+1]=h,e[t+2]=c,e[t+3]=l;return}if(a===1){e[t+0]=f,e[t+1]=d,e[t+2]=v,e[t+3]=m;return}if(l!==m||u!==f||h!==d||c!==v){let y=1-a;const p=u*f+h*d+c*v+l*m,g=p>=0?1:-1,_=1-p*p;if(_>Number.EPSILON){const M=Math.sqrt(_),S=Math.atan2(M,p*g);y=Math.sin(y*S)/M,a=Math.sin(a*S)/M}const x=a*g;if(u=u*y+f*x,h=h*y+d*x,c=c*y+v*x,l=l*y+m*x,y===1-a){const M=1/Math.sqrt(u*u+h*h+c*c+l*l);u*=M,h*=M,c*=M,l*=M}}e[t]=u,e[t+1]=h,e[t+2]=c,e[t+3]=l}static multiplyQuaternionsFlat(e,t,n,r,s,o){const a=n[r],u=n[r+1],h=n[r+2],c=n[r+3],l=s[o],f=s[o+1],d=s[o+2],v=s[o+3];return e[t]=a*v+c*l+u*d-h*f,e[t+1]=u*v+c*f+h*l-a*d,e[t+2]=h*v+c*d+a*f-u*l,e[t+3]=c*v-a*l-u*f-h*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,u=Math.sin,h=a(n/2),c=a(r/2),l=a(s/2),f=u(n/2),d=u(r/2),v=u(s/2);switch(o){case"XYZ":this._x=f*c*l+h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l-f*d*v;break;case"YXZ":this._x=f*c*l+h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l+f*d*v;break;case"ZXY":this._x=f*c*l-h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l-f*d*v;break;case"ZYX":this._x=f*c*l-h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l+f*d*v;break;case"YZX":this._x=f*c*l+h*d*v,this._y=h*d*l+f*c*v,this._z=h*c*v-f*d*l,this._w=h*c*l-f*d*v;break;case"XZY":this._x=f*c*l-h*d*v,this._y=h*d*l-f*c*v,this._z=h*c*v+f*d*l,this._w=h*c*l+f*d*v;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],s=t[8],o=t[1],a=t[5],u=t[9],h=t[2],c=t[6],l=t[10],f=n+a+l;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(c-u)*d,this._y=(s-h)*d,this._z=(o-r)*d}else if(n>a&&n>l){const d=2*Math.sqrt(1+n-a-l);this._w=(c-u)/d,this._x=.25*d,this._y=(r+o)/d,this._z=(s+h)/d}else if(a>l){const d=2*Math.sqrt(1+a-n-l);this._w=(s-h)/d,this._x=(r+o)/d,this._y=.25*d,this._z=(u+c)/d}else{const d=2*Math.sqrt(1+l-n-a);this._w=(o-r)/d,this._x=(s+h)/d,this._y=(u+c)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ot(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,s=e._z,o=e._w,a=t._x,u=t._y,h=t._z,c=t._w;return this._x=n*c+o*a+r*h-s*u,this._y=r*c+o*u+s*a-n*h,this._z=s*c+o*h+n*u-r*a,this._w=o*c-n*a-r*u-s*h,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+n*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=n,this._y=r,this._z=s,this;const u=1-a*a;if(u<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*n+t*this._x,this._y=d*r+t*this._y,this._z=d*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(u),c=Math.atan2(h,a),l=Math.sin((1-t)*c)/h,f=Math.sin(t*c)/h;return this._w=o*l+this._w*f,this._x=n*l+this._x*f,this._y=r*l+this._y*f,this._z=s*l+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(s),n*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Rt.prototype.isQuaternion=!0;class P{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ol.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(ol.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*r,this.y=s[1]*t+s[4]*n+s[7]*r,this.z=s[2]*t+s[5]*n+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*n+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*n+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,s=e.x,o=e.y,a=e.z,u=e.w,h=u*t+o*r-a*n,c=u*n+a*t-s*r,l=u*r+s*n-o*t,f=-s*t-o*n-a*r;return this.x=h*u+f*-s+c*-a-l*-o,this.y=c*u+f*-o+l*-s-h*-a,this.z=l*u+f*-a+h*-o-c*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*r,this.y=s[1]*t+s[5]*n+s[9]*r,this.z=s[2]*t+s[6]*n+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,s=e.z,o=t.x,a=t.y,u=t.z;return this.x=r*u-s*a,this.y=s*o-n*u,this.z=n*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return eo.copy(this).projectOnVector(e),this.sub(eo)}reflect(e){return this.sub(eo.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Ot(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}P.prototype.isVector3=!0;const eo=new P,ol=new Rt;class Jt{constructor(e=new P(1/0,1/0,1/0),t=new P(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let u=0,h=e.length;u<h;u+=3){const c=e[u],l=e[u+1],f=e[u+2];c<t&&(t=c),l<n&&(n=l),f<r&&(r=f),c>s&&(s=c),l>o&&(o=l),f>a&&(a=f)}return this.min.set(t,n,r),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let u=0,h=e.count;u<h;u++){const c=e.getX(u),l=e.getY(u),f=e.getZ(u);c<t&&(t=c),l<n&&(n=l),f<r&&(r=f),c>s&&(s=c),l>o&&(o=l),f>a&&(a=f)}return this.min.set(t,n,r),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Yi.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),to.copy(t.boundingBox),to.applyMatrix4(e.matrixWorld),this.union(to));const n=e.children;for(let r=0,s=n.length;r<s;r++)this.expandByObject(n[r]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Yi),Yi.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ji),Pr.subVectors(this.max,ji),ti.subVectors(e.a,ji),ni.subVectors(e.b,ji),ii.subVectors(e.c,ji),vn.subVectors(ni,ti),yn.subVectors(ii,ni),Gn.subVectors(ti,ii);let t=[0,-vn.z,vn.y,0,-yn.z,yn.y,0,-Gn.z,Gn.y,vn.z,0,-vn.x,yn.z,0,-yn.x,Gn.z,0,-Gn.x,-vn.y,vn.x,0,-yn.y,yn.x,0,-Gn.y,Gn.x,0];return!no(t,ti,ni,ii,Pr)||(t=[1,0,0,0,1,0,0,0,1],!no(t,ti,ni,ii,Pr))?!1:(Nr.crossVectors(vn,yn),t=[Nr.x,Nr.y,Nr.z],no(t,ti,ni,ii,Pr))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Yi.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(Yi).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(on[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),on[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),on[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),on[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),on[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),on[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),on[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),on[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(on),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Jt.prototype.isBox3=!0;const on=[new P,new P,new P,new P,new P,new P,new P,new P],Yi=new P,to=new Jt,ti=new P,ni=new P,ii=new P,vn=new P,yn=new P,Gn=new P,ji=new P,Pr=new P,Nr=new P,kn=new P;function no(i,e,t,n,r){for(let s=0,o=i.length-3;s<=o;s+=3){kn.fromArray(i,s);const a=r.x*Math.abs(kn.x)+r.y*Math.abs(kn.y)+r.z*Math.abs(kn.z),u=e.dot(kn),h=t.dot(kn),c=n.dot(kn);if(Math.max(-Math.max(u,h,c),Math.min(u,h,c))>a)return!1}return!0}const qf=new Jt,al=new P,io=new P,ro=new P;class Oi{constructor(e=new P,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):qf.setFromPoints(e).getCenter(n);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){ro.subVectors(e,this.center);const t=ro.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),r=(n-this.radius)*.5;this.center.add(ro.multiplyScalar(r/n)),this.radius+=r}return this}union(e){return io.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(al.copy(e.center).add(io)),this.expandByPoint(al.copy(e.center).sub(io)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const an=new P,so=new P,Dr=new P,_n=new P,oo=new P,Ir=new P,ao=new P;class Bi{constructor(e=new P,t=new P(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,an)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=an.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(an.copy(this.direction).multiplyScalar(t).add(this.origin),an.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){so.copy(e).add(t).multiplyScalar(.5),Dr.copy(t).sub(e).normalize(),_n.copy(this.origin).sub(so);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Dr),a=_n.dot(this.direction),u=-_n.dot(Dr),h=_n.lengthSq(),c=Math.abs(1-o*o);let l,f,d,v;if(c>0)if(l=o*u-a,f=o*a-u,v=s*c,l>=0)if(f>=-v)if(f<=v){const m=1/c;l*=m,f*=m,d=l*(l+o*f+2*a)+f*(o*l+f+2*u)+h}else f=s,l=Math.max(0,-(o*f+a)),d=-l*l+f*(f+2*u)+h;else f=-s,l=Math.max(0,-(o*f+a)),d=-l*l+f*(f+2*u)+h;else f<=-v?(l=Math.max(0,-(-o*s+a)),f=l>0?-s:Math.min(Math.max(-s,-u),s),d=-l*l+f*(f+2*u)+h):f<=v?(l=0,f=Math.min(Math.max(-s,-u),s),d=f*(f+2*u)+h):(l=Math.max(0,-(o*s+a)),f=l>0?s:Math.min(Math.max(-s,-u),s),d=-l*l+f*(f+2*u)+h);else f=o>0?-s:s,l=Math.max(0,-(o*f+a)),d=-l*l+f*(f+2*u)+h;return n&&n.copy(this.direction).multiplyScalar(l).add(this.origin),r&&r.copy(Dr).multiplyScalar(f).add(so),d}intersectSphere(e,t){an.subVectors(e.center,this.origin);const n=an.dot(this.direction),r=an.dot(an)-n*n,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=n-o,u=n+o;return a<0&&u<0?null:a<0?this.at(u,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,s,o,a,u;const h=1/this.direction.x,c=1/this.direction.y,l=1/this.direction.z,f=this.origin;return h>=0?(n=(e.min.x-f.x)*h,r=(e.max.x-f.x)*h):(n=(e.max.x-f.x)*h,r=(e.min.x-f.x)*h),c>=0?(s=(e.min.y-f.y)*c,o=(e.max.y-f.y)*c):(s=(e.max.y-f.y)*c,o=(e.min.y-f.y)*c),n>o||s>r||((s>n||n!==n)&&(n=s),(o<r||r!==r)&&(r=o),l>=0?(a=(e.min.z-f.z)*l,u=(e.max.z-f.z)*l):(a=(e.max.z-f.z)*l,u=(e.min.z-f.z)*l),n>u||a>r)||((a>n||n!==n)&&(n=a),(u<r||r!==r)&&(r=u),r<0)?null:this.at(n>=0?n:r,t)}intersectsBox(e){return this.intersectBox(e,an)!==null}intersectTriangle(e,t,n,r,s){oo.subVectors(t,e),Ir.subVectors(n,e),ao.crossVectors(oo,Ir);let o=this.direction.dot(ao),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;_n.subVectors(this.origin,e);const u=a*this.direction.dot(Ir.crossVectors(_n,Ir));if(u<0)return null;const h=a*this.direction.dot(oo.cross(_n));if(h<0||u+h>o)return null;const c=-a*_n.dot(ao);return c<0?null:this.at(c/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Re{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,s,o,a,u,h,c,l,f,d,v,m,y){const p=this.elements;return p[0]=e,p[4]=t,p[8]=n,p[12]=r,p[1]=s,p[5]=o,p[9]=a,p[13]=u,p[2]=h,p[6]=c,p[10]=l,p[14]=f,p[3]=d,p[7]=v,p[11]=m,p[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Re().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/ri.setFromMatrixColumn(e,0).length(),s=1/ri.setFromMatrixColumn(e,1).length(),o=1/ri.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,s=e.z,o=Math.cos(n),a=Math.sin(n),u=Math.cos(r),h=Math.sin(r),c=Math.cos(s),l=Math.sin(s);if(e.order==="XYZ"){const f=o*c,d=o*l,v=a*c,m=a*l;t[0]=u*c,t[4]=-u*l,t[8]=h,t[1]=d+v*h,t[5]=f-m*h,t[9]=-a*u,t[2]=m-f*h,t[6]=v+d*h,t[10]=o*u}else if(e.order==="YXZ"){const f=u*c,d=u*l,v=h*c,m=h*l;t[0]=f+m*a,t[4]=v*a-d,t[8]=o*h,t[1]=o*l,t[5]=o*c,t[9]=-a,t[2]=d*a-v,t[6]=m+f*a,t[10]=o*u}else if(e.order==="ZXY"){const f=u*c,d=u*l,v=h*c,m=h*l;t[0]=f-m*a,t[4]=-o*l,t[8]=v+d*a,t[1]=d+v*a,t[5]=o*c,t[9]=m-f*a,t[2]=-o*h,t[6]=a,t[10]=o*u}else if(e.order==="ZYX"){const f=o*c,d=o*l,v=a*c,m=a*l;t[0]=u*c,t[4]=v*h-d,t[8]=f*h+m,t[1]=u*l,t[5]=m*h+f,t[9]=d*h-v,t[2]=-h,t[6]=a*u,t[10]=o*u}else if(e.order==="YZX"){const f=o*u,d=o*h,v=a*u,m=a*h;t[0]=u*c,t[4]=m-f*l,t[8]=v*l+d,t[1]=l,t[5]=o*c,t[9]=-a*c,t[2]=-h*c,t[6]=d*l+v,t[10]=f-m*l}else if(e.order==="XZY"){const f=o*u,d=o*h,v=a*u,m=a*h;t[0]=u*c,t[4]=-l,t[8]=h*c,t[1]=f*l+m,t[5]=o*c,t[9]=d*l-v,t[2]=v*l-d,t[6]=a*c,t[10]=m*l+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Xf,e,Zf)}lookAt(e,t,n){const r=this.elements;return Ft.subVectors(e,t),Ft.lengthSq()===0&&(Ft.z=1),Ft.normalize(),xn.crossVectors(n,Ft),xn.lengthSq()===0&&(Math.abs(n.z)===1?Ft.x+=1e-4:Ft.z+=1e-4,Ft.normalize(),xn.crossVectors(n,Ft)),xn.normalize(),Fr.crossVectors(Ft,xn),r[0]=xn.x,r[4]=Fr.x,r[8]=Ft.x,r[1]=xn.y,r[5]=Fr.y,r[9]=Ft.y,r[2]=xn.z,r[6]=Fr.z,r[10]=Ft.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,s=this.elements,o=n[0],a=n[4],u=n[8],h=n[12],c=n[1],l=n[5],f=n[9],d=n[13],v=n[2],m=n[6],y=n[10],p=n[14],g=n[3],_=n[7],x=n[11],M=n[15],S=r[0],w=r[4],C=r[8],D=r[12],I=r[1],T=r[5],B=r[9],O=r[13],F=r[2],z=r[6],N=r[10],U=r[14],Y=r[3],ee=r[7],k=r[11],q=r[15];return s[0]=o*S+a*I+u*F+h*Y,s[4]=o*w+a*T+u*z+h*ee,s[8]=o*C+a*B+u*N+h*k,s[12]=o*D+a*O+u*U+h*q,s[1]=c*S+l*I+f*F+d*Y,s[5]=c*w+l*T+f*z+d*ee,s[9]=c*C+l*B+f*N+d*k,s[13]=c*D+l*O+f*U+d*q,s[2]=v*S+m*I+y*F+p*Y,s[6]=v*w+m*T+y*z+p*ee,s[10]=v*C+m*B+y*N+p*k,s[14]=v*D+m*O+y*U+p*q,s[3]=g*S+_*I+x*F+M*Y,s[7]=g*w+_*T+x*z+M*ee,s[11]=g*C+_*B+x*N+M*k,s[15]=g*D+_*O+x*U+M*q,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],s=e[12],o=e[1],a=e[5],u=e[9],h=e[13],c=e[2],l=e[6],f=e[10],d=e[14],v=e[3],m=e[7],y=e[11],p=e[15];return v*(+s*u*l-r*h*l-s*a*f+n*h*f+r*a*d-n*u*d)+m*(+t*u*d-t*h*f+s*o*f-r*o*d+r*h*c-s*u*c)+y*(+t*h*l-t*a*d-s*o*l+n*o*d+s*a*c-n*h*c)+p*(-r*a*c-t*u*l+t*a*f+r*o*l-n*o*f+n*u*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],s=e[3],o=e[4],a=e[5],u=e[6],h=e[7],c=e[8],l=e[9],f=e[10],d=e[11],v=e[12],m=e[13],y=e[14],p=e[15],g=l*y*h-m*f*h+m*u*d-a*y*d-l*u*p+a*f*p,_=v*f*h-c*y*h-v*u*d+o*y*d+c*u*p-o*f*p,x=c*m*h-v*l*h+v*a*d-o*m*d-c*a*p+o*l*p,M=v*l*u-c*m*u-v*a*f+o*m*f+c*a*y-o*l*y,S=t*g+n*_+r*x+s*M;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/S;return e[0]=g*w,e[1]=(m*f*s-l*y*s-m*r*d+n*y*d+l*r*p-n*f*p)*w,e[2]=(a*y*s-m*u*s+m*r*h-n*y*h-a*r*p+n*u*p)*w,e[3]=(l*u*s-a*f*s-l*r*h+n*f*h+a*r*d-n*u*d)*w,e[4]=_*w,e[5]=(c*y*s-v*f*s+v*r*d-t*y*d-c*r*p+t*f*p)*w,e[6]=(v*u*s-o*y*s-v*r*h+t*y*h+o*r*p-t*u*p)*w,e[7]=(o*f*s-c*u*s+c*r*h-t*f*h-o*r*d+t*u*d)*w,e[8]=x*w,e[9]=(v*l*s-c*m*s-v*n*d+t*m*d+c*n*p-t*l*p)*w,e[10]=(o*m*s-v*a*s+v*n*h-t*m*h-o*n*p+t*a*p)*w,e[11]=(c*a*s-o*l*s-c*n*h+t*l*h+o*n*d-t*a*d)*w,e[12]=M*w,e[13]=(c*m*r-v*l*r+v*n*f-t*m*f-c*n*y+t*l*y)*w,e[14]=(v*a*r-o*m*r-v*n*u+t*m*u+o*n*y-t*a*y)*w,e[15]=(o*l*r-c*a*r+c*n*u-t*l*u-o*n*f+t*a*f)*w,this}scale(e){const t=this.elements,n=e.x,r=e.y,s=e.z;return t[0]*=n,t[4]*=r,t[8]*=s,t[1]*=n,t[5]*=r,t[9]*=s,t[2]*=n,t[6]*=r,t[10]*=s,t[3]*=n,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),s=1-n,o=e.x,a=e.y,u=e.z,h=s*o,c=s*a;return this.set(h*o+n,h*a-r*u,h*u+r*a,0,h*a+r*u,c*a+n,c*u-r*o,0,h*u-r*a,c*u+r*o,s*u*u+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,r,s,o){return this.set(1,n,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,s=t._x,o=t._y,a=t._z,u=t._w,h=s+s,c=o+o,l=a+a,f=s*h,d=s*c,v=s*l,m=o*c,y=o*l,p=a*l,g=u*h,_=u*c,x=u*l,M=n.x,S=n.y,w=n.z;return r[0]=(1-(m+p))*M,r[1]=(d+x)*M,r[2]=(v-_)*M,r[3]=0,r[4]=(d-x)*S,r[5]=(1-(f+p))*S,r[6]=(y+g)*S,r[7]=0,r[8]=(v+_)*w,r[9]=(y-g)*w,r[10]=(1-(f+m))*w,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let s=ri.set(r[0],r[1],r[2]).length();const o=ri.set(r[4],r[5],r[6]).length(),a=ri.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],Wt.copy(this);const h=1/s,c=1/o,l=1/a;return Wt.elements[0]*=h,Wt.elements[1]*=h,Wt.elements[2]*=h,Wt.elements[4]*=c,Wt.elements[5]*=c,Wt.elements[6]*=c,Wt.elements[8]*=l,Wt.elements[9]*=l,Wt.elements[10]*=l,t.setFromRotationMatrix(Wt),n.x=s,n.y=o,n.z=a,this}makePerspective(e,t,n,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,u=2*s/(t-e),h=2*s/(n-r),c=(t+e)/(t-e),l=(n+r)/(n-r),f=-(o+s)/(o-s),d=-2*o*s/(o-s);return a[0]=u,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=h,a[9]=l,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,r,s,o){const a=this.elements,u=1/(t-e),h=1/(n-r),c=1/(o-s),l=(t+e)*u,f=(n+r)*h,d=(o+s)*c;return a[0]=2*u,a[4]=0,a[8]=0,a[12]=-l,a[1]=0,a[5]=2*h,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<16;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Re.prototype.isMatrix4=!0;const ri=new P,Wt=new Re,Xf=new P(0,0,0),Zf=new P(1,1,1),xn=new P,Fr=new P,Ft=new P,ll=new Re,cl=new Rt;class Ui{constructor(e=0,t=0,n=0,r=Ui.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r=this._order){return this._x=e,this._y=t,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],u=r[1],h=r[5],c=r[9],l=r[2],f=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(Ot(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-Ot(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(u,h)):(this._y=Math.atan2(-l,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ot(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-l,d),this._z=Math.atan2(-o,h)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-Ot(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(f,d),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-o,h));break;case"YZX":this._z=Math.asin(Ot(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-l,s)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Ot(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return ll.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ll,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return cl.setFromEuler(this),this.setFromQuaternion(cl,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new P(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Ui.prototype.isEuler=!0;Ui.DefaultOrder="XYZ";Ui.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Yf{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let jf=0;const ul=new P,si=new Rt,ln=new Re,zr=new P,Ji=new P,Jf=new P,$f=new Rt,hl=new P(1,0,0),fl=new P(0,1,0),dl=new P(0,0,1),Qf={type:"added"},pl={type:"removed"};class Ge extends Qn{constructor(){super();Object.defineProperty(this,"id",{value:jf++}),this.uuid=en(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ge.DefaultUp.clone();const e=new P,t=new Ui,n=new Rt,r=new P(1,1,1);function s(){n.setFromEuler(t,!1)}function o(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Re},normalMatrix:{value:new gt}}),this.matrix=new Re,this.matrixWorld=new Re,this.matrixAutoUpdate=Ge.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Yf,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return si.setFromAxisAngle(e,t),this.quaternion.multiply(si),this}rotateOnWorldAxis(e,t){return si.setFromAxisAngle(e,t),this.quaternion.premultiply(si),this}rotateX(e){return this.rotateOnAxis(hl,e)}rotateY(e){return this.rotateOnAxis(fl,e)}rotateZ(e){return this.rotateOnAxis(dl,e)}translateOnAxis(e,t){return ul.copy(e).applyQuaternion(this.quaternion),this.position.add(ul.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(hl,e)}translateY(e){return this.translateOnAxis(fl,e)}translateZ(e){return this.translateOnAxis(dl,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(ln.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?zr.copy(e):zr.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Ji.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ln.lookAt(Ji,zr,this.up):ln.lookAt(zr,Ji,this.up),this.quaternion.setFromRotationMatrix(ln),r&&(ln.extractRotation(r.matrixWorld),si.setFromRotationMatrix(ln),this.quaternion.premultiply(si.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Qf)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(pl)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(pl)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),ln.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ln.multiply(e.parent.matrixWorld)),e.applyMatrix4(ln),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const o=this.children[n].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ji,e,Jf),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ji,$f,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(a,u){return a[u.uuid]===void 0&&(a[u.uuid]=u.toJSON(e)),u.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const u=a.shapes;if(Array.isArray(u))for(let h=0,c=u.length;h<c;h++){const l=u[h];s(e.shapes,l)}else s(e.shapes,u)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let u=0,h=this.material.length;u<h;u++)a.push(s(e.materials,this.material[u]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const u=this.animations[a];r.animations.push(s(e.animations,u))}}if(t){const a=o(e.geometries),u=o(e.materials),h=o(e.textures),c=o(e.images),l=o(e.shapes),f=o(e.skeletons),d=o(e.animations);a.length>0&&(n.geometries=a),u.length>0&&(n.materials=u),h.length>0&&(n.textures=h),c.length>0&&(n.images=c),l.length>0&&(n.shapes=l),f.length>0&&(n.skeletons=f),d.length>0&&(n.animations=d)}return n.object=r,n;function o(a){const u=[];for(const h in a){const c=a[h];delete c.metadata,u.push(c)}return u}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const r=e.children[n];this.add(r.clone())}return this}}Ge.DefaultUp=new P(0,1,0);Ge.DefaultMatrixAutoUpdate=!0;Ge.prototype.isObject3D=!0;const qt=new P,cn=new P,lo=new P,un=new P,oi=new P,ai=new P,ml=new P,co=new P,uo=new P,ho=new P;class ot{constructor(e=new P,t=new P,n=new P){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t),qt.subVectors(e,t),r.cross(qt);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,n,r,s){qt.subVectors(r,t),cn.subVectors(n,t),lo.subVectors(e,t);const o=qt.dot(qt),a=qt.dot(cn),u=qt.dot(lo),h=cn.dot(cn),c=cn.dot(lo),l=o*h-a*a;if(l===0)return s.set(-2,-1,-1);const f=1/l,d=(h*u-a*c)*f,v=(o*c-a*u)*f;return s.set(1-d-v,v,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,un),un.x>=0&&un.y>=0&&un.x+un.y<=1}static getUV(e,t,n,r,s,o,a,u){return this.getBarycoord(e,t,n,r,un),u.set(0,0),u.addScaledVector(s,un.x),u.addScaledVector(o,un.y),u.addScaledVector(a,un.z),u}static isFrontFacing(e,t,n,r){return qt.subVectors(n,t),cn.subVectors(e,t),qt.cross(cn).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,n,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return qt.subVectors(this.c,this.b),cn.subVectors(this.a,this.b),qt.cross(cn).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return ot.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return ot.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,s){return ot.getUV(e,this.a,this.b,this.c,t,n,r,s)}containsPoint(e){return ot.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return ot.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,s=this.c;let o,a;oi.subVectors(r,n),ai.subVectors(s,n),co.subVectors(e,n);const u=oi.dot(co),h=ai.dot(co);if(u<=0&&h<=0)return t.copy(n);uo.subVectors(e,r);const c=oi.dot(uo),l=ai.dot(uo);if(c>=0&&l<=c)return t.copy(r);const f=u*l-c*h;if(f<=0&&u>=0&&c<=0)return o=u/(u-c),t.copy(n).addScaledVector(oi,o);ho.subVectors(e,s);const d=oi.dot(ho),v=ai.dot(ho);if(v>=0&&d<=v)return t.copy(s);const m=d*h-u*v;if(m<=0&&h>=0&&v<=0)return a=h/(h-v),t.copy(n).addScaledVector(ai,a);const y=c*v-d*l;if(y<=0&&l-c>=0&&d-v>=0)return ml.subVectors(s,r),a=(l-c)/(l-c+(d-v)),t.copy(r).addScaledVector(ml,a);const p=1/(y+m+f);return o=m*p,a=f*p,t.copy(n).addScaledVector(oi,o).addScaledVector(ai,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Kf=0;class Mt extends Qn{constructor(){super();Object.defineProperty(this,"id",{value:Kf++}),this.uuid=en(),this.name="",this.type="Material",this.fog=!0,this.blending=ar,this.side=hr,this.vertexColors=!1,this.opacity=1,this.format=St,this.transparent=!1,this.blendSrc=Sc,this.blendDst=Ec,this.blendEquation=xi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Bo,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Hf,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Js,this.stencilZFail=Js,this.stencilZPass=Js,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===bc;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==ar&&(n.blending=this.blending),this.side!==hr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==St&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function r(s){const o=[];for(const a in s){const u=s[a];delete u.metadata,o.push(u)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(n.textures=s),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const r=t.length;n=new Array(r);for(let s=0;s!==r;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Mt.prototype.isMaterial=!0;const Nc={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Xt={h:0,s:0,l:0},Or={h:0,s:0,l:0};function fo(i,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?i+(e-i)*6*t:t<1/2?e:t<2/3?i+(e-i)*6*(2/3-t):i}function po(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function mo(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}class Ee{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Vf(e,1),t=Ot(t,0,1),n=Ot(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,s=2*n-r;this.r=fo(s,r,e+1/3),this.g=fo(s,r,e),this.b=fo(s,r,e-1/3)}return this}setStyle(e){function t(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const s=n[1],o=n[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,t(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,t(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,u=parseInt(r[2],10)/100,h=parseInt(r[3],10)/100;return t(r[4]),this.setHSL(a,u,h)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=n[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Nc[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=po(e.r),this.g=po(e.g),this.b=po(e.b),this}copyLinearToSRGB(e){return this.r=mo(e.r),this.g=mo(e.g),this.b=mo(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,n=this.g,r=this.b,s=Math.max(t,n,r),o=Math.min(t,n,r);let a,u;const h=(o+s)/2;if(o===s)a=0,u=0;else{const c=s-o;switch(u=h<=.5?c/(s+o):c/(2-s-o),s){case t:a=(n-r)/c+(n<r?6:0);break;case n:a=(r-t)/c+2;break;case r:a=(t-n)/c+4;break}a/=6}return e.h=a,e.s=u,e.l=h,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,n){return this.getHSL(Xt),Xt.h+=e,Xt.s+=t,Xt.l+=n,this.setHSL(Xt.h,Xt.s,Xt.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Xt),e.getHSL(Or);const n=Qs(Xt.h,Or.h,t),r=Qs(Xt.s,Or.s,t),s=Qs(Xt.l,Or.l,t);return this.setHSL(n,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ee.NAMES=Nc;Ee.prototype.isColor=!0;Ee.prototype.r=1;Ee.prototype.g=1;Ee.prototype.b=1;class ha extends Mt{constructor(e){super();this.type="MeshBasicMaterial",this.color=new Ee(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ss,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}ha.prototype.isMeshBasicMaterial=!0;const Xe=new P,Br=new le;class ct{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=dr,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new Ee),t[n++]=o.r,t[n++]=o.g,t[n++]=o.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new le),t[n++]=o.x,t[n++]=o.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new P),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new We),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z,t[n++]=o.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Br.fromBufferAttribute(this,t),Br.applyMatrix3(e),this.setXY(t,Br.x,Br.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Xe.fromBufferAttribute(this,t),Xe.applyMatrix3(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.applyMatrix4(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.applyNormalMatrix(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Xe.x=this.getX(t),Xe.y=this.getY(t),Xe.z=this.getZ(t),Xe.transformDirection(e),this.setXYZ(t,Xe.x,Xe.y,Xe.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==dr&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}ct.prototype.isBufferAttribute=!0;class Dc extends ct{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Ic extends ct{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class ed extends ct{constructor(e,t,n){super(new Uint16Array(e),t,n)}}ed.prototype.isFloat16BufferAttribute=!0;class st extends ct{constructor(e,t,n){super(new Float32Array(e),t,n)}}let td=0;const Ut=new Re,go=new Ge,li=new P,zt=new Jt,$i=new Jt,ut=new P;class Ye extends Qn{constructor(){super();Object.defineProperty(this,"id",{value:td++}),this.uuid=en(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Pc(e)>65535?Ic:Dc)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new gt().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ut.makeRotationFromQuaternion(e),this.applyMatrix4(Ut),this}rotateX(e){return Ut.makeRotationX(e),this.applyMatrix4(Ut),this}rotateY(e){return Ut.makeRotationY(e),this.applyMatrix4(Ut),this}rotateZ(e){return Ut.makeRotationZ(e),this.applyMatrix4(Ut),this}translate(e,t,n){return Ut.makeTranslation(e,t,n),this.applyMatrix4(Ut),this}scale(e,t,n){return Ut.makeScale(e,t,n),this.applyMatrix4(Ut),this}lookAt(e){return go.lookAt(e),go.updateMatrix(),this.applyMatrix4(go.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(li).negate(),this.translate(li.x,li.y,li.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new st(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Jt);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new P(-1/0,-1/0,-1/0),new P(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,r=t.length;n<r;n++){const s=t[n];zt.setFromBufferAttribute(s),this.morphTargetsRelative?(ut.addVectors(this.boundingBox.min,zt.min),this.boundingBox.expandByPoint(ut),ut.addVectors(this.boundingBox.max,zt.max),this.boundingBox.expandByPoint(ut)):(this.boundingBox.expandByPoint(zt.min),this.boundingBox.expandByPoint(zt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Oi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new P,1/0);return}if(e){const n=this.boundingSphere.center;if(zt.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];$i.setFromBufferAttribute(a),this.morphTargetsRelative?(ut.addVectors(zt.min,$i.min),zt.expandByPoint(ut),ut.addVectors(zt.max,$i.max),zt.expandByPoint(ut)):(zt.expandByPoint($i.min),zt.expandByPoint($i.max))}zt.getCenter(n);let r=0;for(let s=0,o=e.count;s<o;s++)ut.fromBufferAttribute(e,s),r=Math.max(r,n.distanceToSquared(ut));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],u=this.morphTargetsRelative;for(let h=0,c=a.count;h<c;h++)ut.fromBufferAttribute(a,h),u&&(li.fromBufferAttribute(e,h),ut.add(li)),r=Math.max(r,n.distanceToSquared(ut))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,r=t.position.array,s=t.normal.array,o=t.uv.array,a=r.length/3;t.tangent===void 0&&this.setAttribute("tangent",new ct(new Float32Array(4*a),4));const u=t.tangent.array,h=[],c=[];for(let I=0;I<a;I++)h[I]=new P,c[I]=new P;const l=new P,f=new P,d=new P,v=new le,m=new le,y=new le,p=new P,g=new P;function _(I,T,B){l.fromArray(r,I*3),f.fromArray(r,T*3),d.fromArray(r,B*3),v.fromArray(o,I*2),m.fromArray(o,T*2),y.fromArray(o,B*2),f.sub(l),d.sub(l),m.sub(v),y.sub(v);const O=1/(m.x*y.y-y.x*m.y);!isFinite(O)||(p.copy(f).multiplyScalar(y.y).addScaledVector(d,-m.y).multiplyScalar(O),g.copy(d).multiplyScalar(m.x).addScaledVector(f,-y.x).multiplyScalar(O),h[I].add(p),h[T].add(p),h[B].add(p),c[I].add(g),c[T].add(g),c[B].add(g))}let x=this.groups;x.length===0&&(x=[{start:0,count:n.length}]);for(let I=0,T=x.length;I<T;++I){const B=x[I],O=B.start,F=B.count;for(let z=O,N=O+F;z<N;z+=3)_(n[z+0],n[z+1],n[z+2])}const M=new P,S=new P,w=new P,C=new P;function D(I){w.fromArray(s,I*3),C.copy(w);const T=h[I];M.copy(T),M.sub(w.multiplyScalar(w.dot(T))).normalize(),S.crossVectors(C,T);const O=S.dot(c[I])<0?-1:1;u[I*4]=M.x,u[I*4+1]=M.y,u[I*4+2]=M.z,u[I*4+3]=O}for(let I=0,T=x.length;I<T;++I){const B=x[I],O=B.start,F=B.count;for(let z=O,N=O+F;z<N;z+=3)D(n[z+0]),D(n[z+1]),D(n[z+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new ct(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let f=0,d=n.count;f<d;f++)n.setXYZ(f,0,0,0);const r=new P,s=new P,o=new P,a=new P,u=new P,h=new P,c=new P,l=new P;if(e)for(let f=0,d=e.count;f<d;f+=3){const v=e.getX(f+0),m=e.getX(f+1),y=e.getX(f+2);r.fromBufferAttribute(t,v),s.fromBufferAttribute(t,m),o.fromBufferAttribute(t,y),c.subVectors(o,s),l.subVectors(r,s),c.cross(l),a.fromBufferAttribute(n,v),u.fromBufferAttribute(n,m),h.fromBufferAttribute(n,y),a.add(c),u.add(c),h.add(c),n.setXYZ(v,a.x,a.y,a.z),n.setXYZ(m,u.x,u.y,u.z),n.setXYZ(y,h.x,h.y,h.z)}else for(let f=0,d=t.count;f<d;f+=3)r.fromBufferAttribute(t,f+0),s.fromBufferAttribute(t,f+1),o.fromBufferAttribute(t,f+2),c.subVectors(o,s),l.subVectors(r,s),c.cross(l),n.setXYZ(f+0,c.x,c.y,c.z),n.setXYZ(f+1,c.x,c.y,c.z),n.setXYZ(f+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(e.attributes[r]===void 0)continue;const o=n[r].array,a=e.attributes[r],u=a.array,h=a.itemSize*t,c=Math.min(u.length,o.length-h);for(let l=0,f=h;l<c;l++,f++)o[f]=u[l]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)ut.fromBufferAttribute(e,t),ut.normalize(),e.setXYZ(t,ut.x,ut.y,ut.z)}toNonIndexed(){function e(a,u){const h=a.array,c=a.itemSize,l=a.normalized,f=new h.constructor(u.length*c);let d=0,v=0;for(let m=0,y=u.length;m<y;m++){a.isInterleavedBufferAttribute?d=u[m]*a.data.stride+a.offset:d=u[m]*c;for(let p=0;p<c;p++)f[v++]=h[d++]}return new ct(f,c,l)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Ye,n=this.index.array,r=this.attributes;for(const a in r){const u=r[a],h=e(u,n);t.setAttribute(a,h)}const s=this.morphAttributes;for(const a in s){const u=[],h=s[a];for(let c=0,l=h.length;c<l;c++){const f=h[c],d=e(f,n);u.push(d)}t.morphAttributes[a]=u}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,u=o.length;a<u;a++){const h=o[a];t.addGroup(h.start,h.count,h.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const h in u)u[h]!==void 0&&(e[h]=u[h]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const u in n){const h=n[u];e.data.attributes[u]=h.toJSON(e.data)}const r={};let s=!1;for(const u in this.morphAttributes){const h=this.morphAttributes[u],c=[];for(let l=0,f=h.length;l<f;l++){const d=h[l];c.push(d.toJSON(e.data))}c.length>0&&(r[u]=c,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const r=e.attributes;for(const h in r){const c=r[h];this.setAttribute(h,c.clone(t))}const s=e.morphAttributes;for(const h in s){const c=[],l=s[h];for(let f=0,d=l.length;f<d;f++)c.push(l[f].clone(t));this.morphAttributes[h]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let h=0,c=o.length;h<c;h++){const l=o[h];this.addGroup(l.start,l.count,l.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const u=e.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Ye.prototype.isBufferGeometry=!0;const gl=new Re,ci=new Bi,vo=new Oi,wn=new P,Mn=new P,bn=new P,yo=new P,_o=new P,xo=new P,Ur=new P,Hr=new P,Vr=new P,Gr=new le,kr=new le,Wr=new le,wo=new P,qr=new P;class Lt extends Ge{constructor(e=new Ye,t=new ha){super();this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),vo.copy(n.boundingSphere),vo.applyMatrix4(s),e.ray.intersectsSphere(vo)===!1)||(gl.copy(s).invert(),ci.copy(e.ray).applyMatrix4(gl),n.boundingBox!==null&&ci.intersectsBox(n.boundingBox)===!1))return;let o;if(n.isBufferGeometry){const a=n.index,u=n.attributes.position,h=n.morphAttributes.position,c=n.morphTargetsRelative,l=n.attributes.uv,f=n.attributes.uv2,d=n.groups,v=n.drawRange;if(a!==null)if(Array.isArray(r))for(let m=0,y=d.length;m<y;m++){const p=d[m],g=r[p.materialIndex],_=Math.max(p.start,v.start),x=Math.min(a.count,Math.min(p.start+p.count,v.start+v.count));for(let M=_,S=x;M<S;M+=3){const w=a.getX(M),C=a.getX(M+1),D=a.getX(M+2);o=Xr(this,g,e,ci,u,h,c,l,f,w,C,D),o&&(o.faceIndex=Math.floor(M/3),o.face.materialIndex=p.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),y=Math.min(a.count,v.start+v.count);for(let p=m,g=y;p<g;p+=3){const _=a.getX(p),x=a.getX(p+1),M=a.getX(p+2);o=Xr(this,r,e,ci,u,h,c,l,f,_,x,M),o&&(o.faceIndex=Math.floor(p/3),t.push(o))}}else if(u!==void 0)if(Array.isArray(r))for(let m=0,y=d.length;m<y;m++){const p=d[m],g=r[p.materialIndex],_=Math.max(p.start,v.start),x=Math.min(u.count,Math.min(p.start+p.count,v.start+v.count));for(let M=_,S=x;M<S;M+=3){const w=M,C=M+1,D=M+2;o=Xr(this,g,e,ci,u,h,c,l,f,w,C,D),o&&(o.faceIndex=Math.floor(M/3),o.face.materialIndex=p.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),y=Math.min(u.count,v.start+v.count);for(let p=m,g=y;p<g;p+=3){const _=p,x=p+1,M=p+2;o=Xr(this,r,e,ci,u,h,c,l,f,_,x,M),o&&(o.faceIndex=Math.floor(p/3),t.push(o))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Lt.prototype.isMesh=!0;function nd(i,e,t,n,r,s,o,a){let u;if(e.side===at?u=n.intersectTriangle(o,s,r,!0,a):u=n.intersectTriangle(r,s,o,e.side!==Li,a),u===null)return null;qr.copy(a),qr.applyMatrix4(i.matrixWorld);const h=t.ray.origin.distanceTo(qr);return h<t.near||h>t.far?null:{distance:h,point:qr.clone(),object:i}}function Xr(i,e,t,n,r,s,o,a,u,h,c,l){wn.fromBufferAttribute(r,h),Mn.fromBufferAttribute(r,c),bn.fromBufferAttribute(r,l);const f=i.morphTargetInfluences;if(s&&f){Ur.set(0,0,0),Hr.set(0,0,0),Vr.set(0,0,0);for(let v=0,m=s.length;v<m;v++){const y=f[v],p=s[v];y!==0&&(yo.fromBufferAttribute(p,h),_o.fromBufferAttribute(p,c),xo.fromBufferAttribute(p,l),o?(Ur.addScaledVector(yo,y),Hr.addScaledVector(_o,y),Vr.addScaledVector(xo,y)):(Ur.addScaledVector(yo.sub(wn),y),Hr.addScaledVector(_o.sub(Mn),y),Vr.addScaledVector(xo.sub(bn),y)))}wn.add(Ur),Mn.add(Hr),bn.add(Vr)}i.isSkinnedMesh&&(i.boneTransform(h,wn),i.boneTransform(c,Mn),i.boneTransform(l,bn));const d=nd(i,e,t,n,wn,Mn,bn,wo);if(d){a&&(Gr.fromBufferAttribute(a,h),kr.fromBufferAttribute(a,c),Wr.fromBufferAttribute(a,l),d.uv=ot.getUV(wo,wn,Mn,bn,Gr,kr,Wr,new le)),u&&(Gr.fromBufferAttribute(u,h),kr.fromBufferAttribute(u,c),Wr.fromBufferAttribute(u,l),d.uv2=ot.getUV(wo,wn,Mn,bn,Gr,kr,Wr,new le));const v={a:h,b:c,c:l,normal:new P,materialIndex:0};ot.getNormal(wn,Mn,bn,v.normal),d.face=v}return d}class Mr extends Ye{constructor(e=1,t=1,n=1,r=1,s=1,o=1){super();this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const u=[],h=[],c=[],l=[];let f=0,d=0;v("z","y","x",-1,-1,n,t,e,o,s,0),v("z","y","x",1,-1,n,t,-e,o,s,1),v("x","z","y",1,1,e,n,t,r,o,2),v("x","z","y",1,-1,e,n,-t,r,o,3),v("x","y","z",1,-1,e,t,n,r,s,4),v("x","y","z",-1,-1,e,t,-n,r,s,5),this.setIndex(u),this.setAttribute("position",new st(h,3)),this.setAttribute("normal",new st(c,3)),this.setAttribute("uv",new st(l,2));function v(m,y,p,g,_,x,M,S,w,C,D){const I=x/w,T=M/C,B=x/2,O=M/2,F=S/2,z=w+1,N=C+1;let U=0,Y=0;const ee=new P;for(let k=0;k<N;k++){const q=k*T-O;for(let ae=0;ae<z;ae++){const se=ae*I-B;ee[m]=se*g,ee[y]=q*_,ee[p]=F,h.push(ee.x,ee.y,ee.z),ee[m]=0,ee[y]=0,ee[p]=S>0?1:-1,c.push(ee.x,ee.y,ee.z),l.push(ae/w),l.push(1-k/C),U+=1}}for(let k=0;k<C;k++)for(let q=0;q<w;q++){const ae=f+q+z*k,se=f+q+z*(k+1),de=f+(q+1)+z*(k+1),Se=f+(q+1)+z*k;u.push(ae,se,Se),u.push(se,de,Se),Y+=6}a.addGroup(d,Y,D),d+=Y,f+=U}}static fromJSON(e){return new Mr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Pi(i){const e={};for(const t in i){e[t]={};for(const n in i[t]){const r=i[t][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][n]=r.clone():Array.isArray(r)?e[t][n]=r.slice():e[t][n]=r}}return e}function _t(i){const e={};for(let t=0;t<i.length;t++){const n=Pi(i[t]);for(const r in n)e[r]=n[r]}return e}const id={clone:Pi,merge:_t};var rd=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,sd=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class jn extends Mt{constructor(e){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=rd,this.fragmentShader=sd,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Pi(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)this.extensions[r]===!0&&(n[r]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}jn.prototype.isShaderMaterial=!0;class fa extends Ge{constructor(){super();this.type="Camera",this.matrixWorldInverse=new Re,this.projectionMatrix=new Re,this.projectionMatrixInverse=new Re}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}fa.prototype.isCamera=!0;class Ct extends fa{constructor(e=50,t=1,n=.1,r=2e3){super();this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=ko*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan($s*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return ko*2*Math.atan(Math.tan($s*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan($s*.5*this.fov)/this.zoom,n=2*t,r=this.aspect*n,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const u=o.fullWidth,h=o.fullHeight;s+=o.offsetX*r/u,t-=o.offsetY*n/h,r*=o.width/u,n*=o.height/h}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Ct.prototype.isPerspectiveCamera=!0;const ui=90,hi=1;class da extends Ge{constructor(e,t,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new Ct(ui,hi,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new P(1,0,0)),this.add(r);const s=new Ct(ui,hi,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new P(-1,0,0)),this.add(s);const o=new Ct(ui,hi,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new P(0,1,0)),this.add(o);const a=new Ct(ui,hi,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new P(0,-1,0)),this.add(a);const u=new Ct(ui,hi,e,t);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new P(0,0,1)),this.add(u);const h=new Ct(ui,hi,e,t);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new P(0,0,-1)),this.add(h)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,o,a,u,h]=this.children,c=e.xr.enabled,l=e.getRenderTarget();e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,s),e.setRenderTarget(n,2),e.render(t,o),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,u),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,h),e.setRenderTarget(l),e.xr.enabled=c}}class Ls extends yt{constructor(e,t,n,r,s,o,a,u,h,c){e=e!==void 0?e:[],t=t!==void 0?t:xr;super(e,t,n,r,s,o,a,u,h,c);this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}Ls.prototype.isCubeTexture=!0;class Fc extends Vt{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n);super(e,e,t);t=t||{},this.texture=new Ls(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Ht,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=St,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Mr(5,5,5),s=new jn({name:"CubemapFromEquirect",uniforms:Pi(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:at,blending:Cn});s.uniforms.tEquirect.value=t;const o=new Lt(r,s),a=t.minFilter;return t.minFilter===Ts&&(t.minFilter=Ht),new da(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,r);e.setRenderTarget(s)}}Fc.prototype.isWebGLCubeRenderTarget=!0;const Mo=new P,od=new P,ad=new gt;class fn{constructor(e=new P(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=Mo.subVectors(n,t).cross(od.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Mo),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(n).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||ad.getNormalMatrix(e),r=this.coplanarPoint(Mo).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}fn.prototype.isPlane=!0;const fi=new Oi,Zr=new P;class Rs{constructor(e=new fn,t=new fn,n=new fn,r=new fn,s=new fn,o=new fn){this.planes=[e,t,n,r,s,o]}set(e,t,n,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],s=n[1],o=n[2],a=n[3],u=n[4],h=n[5],c=n[6],l=n[7],f=n[8],d=n[9],v=n[10],m=n[11],y=n[12],p=n[13],g=n[14],_=n[15];return t[0].setComponents(a-r,l-u,m-f,_-y).normalize(),t[1].setComponents(a+r,l+u,m+f,_+y).normalize(),t[2].setComponents(a+s,l+h,m+d,_+p).normalize(),t[3].setComponents(a-s,l-h,m-d,_-p).normalize(),t[4].setComponents(a-o,l-c,m-v,_-g).normalize(),t[5].setComponents(a+o,l+c,m+v,_+g).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),fi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(fi)}intersectsSprite(e){return fi.center.set(0,0,0),fi.radius=.7071067811865476,fi.applyMatrix4(e.matrixWorld),this.intersectsSphere(fi)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(Zr.x=r.normal.x>0?e.max.x:e.min.x,Zr.y=r.normal.y>0?e.max.y:e.min.y,Zr.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Zr)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function zc(){let i=null,e=!1,t=null,n=null;function r(s,o){t(s,o),n=i.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(n=i.requestAnimationFrame(r),e=!0)},stop:function(){i.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){i=s}}}function ld(i,e){const t=e.isWebGL2,n=new WeakMap;function r(h,c){const l=h.array,f=h.usage,d=i.createBuffer();i.bindBuffer(c,d),i.bufferData(c,l,f),h.onUploadCallback();let v=5126;return l instanceof Float32Array?v=5126:l instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):l instanceof Uint16Array?h.isFloat16BufferAttribute?t?v=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):v=5123:l instanceof Int16Array?v=5122:l instanceof Uint32Array?v=5125:l instanceof Int32Array?v=5124:l instanceof Int8Array?v=5120:(l instanceof Uint8Array||l instanceof Uint8ClampedArray)&&(v=5121),{buffer:d,type:v,bytesPerElement:l.BYTES_PER_ELEMENT,version:h.version}}function s(h,c,l){const f=c.array,d=c.updateRange;i.bindBuffer(l,h),d.count===-1?i.bufferSubData(l,0,f):(t?i.bufferSubData(l,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):i.bufferSubData(l,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function o(h){return h.isInterleavedBufferAttribute&&(h=h.data),n.get(h)}function a(h){h.isInterleavedBufferAttribute&&(h=h.data);const c=n.get(h);c&&(i.deleteBuffer(c.buffer),n.delete(h))}function u(h,c){if(h.isGLBufferAttribute){const f=n.get(h);(!f||f.version<h.version)&&n.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const l=n.get(h);l===void 0?n.set(h,r(h,c)):l.version<h.version&&(s(l.buffer,h,c),l.version=h.version)}return{get:o,remove:a,update:u}}class pa extends Ye{constructor(e=1,t=1,n=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(n),u=Math.floor(r),h=a+1,c=u+1,l=e/a,f=t/u,d=[],v=[],m=[],y=[];for(let p=0;p<c;p++){const g=p*f-o;for(let _=0;_<h;_++){const x=_*l-s;v.push(x,-g,0),m.push(0,0,1),y.push(_/a),y.push(1-p/u)}}for(let p=0;p<u;p++)for(let g=0;g<a;g++){const _=g+h*p,x=g+h*(p+1),M=g+1+h*(p+1),S=g+1+h*p;d.push(_,x,S),d.push(x,M,S)}this.setIndex(d),this.setAttribute("position",new st(v,3)),this.setAttribute("normal",new st(m,3)),this.setAttribute("uv",new st(y,2))}static fromJSON(e){return new pa(e.width,e.height,e.widthSegments,e.heightSegments)}}var cd=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,ud=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hd=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,fd=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,dd=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,pd=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,md="vec3 transformed = vec3( position );",gd=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,vd=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,yd=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,_d=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,xd=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,wd=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Md=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,bd=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Sd=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Ed=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Td=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Ad=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Cd=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Ld=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Rd=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Pd=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Nd=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Dd=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Id="gl_FragColor = linearToOutputTexel( gl_FragColor );",Fd=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}`,zd=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Od=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Bd=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Ud=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Hd=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Vd=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Gd=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,kd=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Wd=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,qd=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Xd=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Zd=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Yd=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,jd=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Jd=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,$d=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Qd=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Kd=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,ep=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,tp=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,np=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ip=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,rp=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,sp=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,op=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,ap=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,lp=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,cp=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,up=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,hp=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,fp=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,dp=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,pp=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,mp=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,gp=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,vp=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,yp=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,_p=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,xp=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,wp=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Mp=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,bp=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Sp=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Ep=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Tp=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Ap=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Cp=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Lp=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Rp=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Pp=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Np=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Dp=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Ip=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Fp=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,zp=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Op=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Bp=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Up=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Hp=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Vp=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Gp=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,kp=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Wp=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,qp=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Xp=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Zp=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Yp=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,jp=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Jp=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,$p=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Qp=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Kp=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,em=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,tm=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,nm=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const im=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,rm=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sm=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,om=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,am=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,lm=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,cm=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,um=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,hm=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fm=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,dm=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,pm=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,mm=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,gm=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vm=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ym=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_m=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,xm=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wm=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Mm=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,bm=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Sm=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Em=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Tm=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Am=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Cm=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Lm=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Rm=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Pm=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Nm=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Dm=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Im=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Oe={alphamap_fragment:cd,alphamap_pars_fragment:ud,alphatest_fragment:hd,alphatest_pars_fragment:fd,aomap_fragment:dd,aomap_pars_fragment:pd,begin_vertex:md,beginnormal_vertex:gd,bsdfs:vd,bumpmap_pars_fragment:yd,clipping_planes_fragment:_d,clipping_planes_pars_fragment:xd,clipping_planes_pars_vertex:wd,clipping_planes_vertex:Md,color_fragment:bd,color_pars_fragment:Sd,color_pars_vertex:Ed,color_vertex:Td,common:Ad,cube_uv_reflection_fragment:Cd,defaultnormal_vertex:Ld,displacementmap_pars_vertex:Rd,displacementmap_vertex:Pd,emissivemap_fragment:Nd,emissivemap_pars_fragment:Dd,encodings_fragment:Id,encodings_pars_fragment:Fd,envmap_fragment:zd,envmap_common_pars_fragment:Od,envmap_pars_fragment:Bd,envmap_pars_vertex:Ud,envmap_physical_pars_fragment:Jd,envmap_vertex:Hd,fog_vertex:Vd,fog_pars_vertex:Gd,fog_fragment:kd,fog_pars_fragment:Wd,gradientmap_pars_fragment:qd,lightmap_fragment:Xd,lightmap_pars_fragment:Zd,lights_lambert_vertex:Yd,lights_pars_begin:jd,lights_toon_fragment:$d,lights_toon_pars_fragment:Qd,lights_phong_fragment:Kd,lights_phong_pars_fragment:ep,lights_physical_fragment:tp,lights_physical_pars_fragment:np,lights_fragment_begin:ip,lights_fragment_maps:rp,lights_fragment_end:sp,logdepthbuf_fragment:op,logdepthbuf_pars_fragment:ap,logdepthbuf_pars_vertex:lp,logdepthbuf_vertex:cp,map_fragment:up,map_pars_fragment:hp,map_particle_fragment:fp,map_particle_pars_fragment:dp,metalnessmap_fragment:pp,metalnessmap_pars_fragment:mp,morphnormal_vertex:gp,morphtarget_pars_vertex:vp,morphtarget_vertex:yp,normal_fragment_begin:_p,normal_fragment_maps:xp,normal_pars_fragment:wp,normal_pars_vertex:Mp,normal_vertex:bp,normalmap_pars_fragment:Sp,clearcoat_normal_fragment_begin:Ep,clearcoat_normal_fragment_maps:Tp,clearcoat_pars_fragment:Ap,output_fragment:Cp,packing:Lp,premultiplied_alpha_fragment:Rp,project_vertex:Pp,dithering_fragment:Np,dithering_pars_fragment:Dp,roughnessmap_fragment:Ip,roughnessmap_pars_fragment:Fp,shadowmap_pars_fragment:zp,shadowmap_pars_vertex:Op,shadowmap_vertex:Bp,shadowmask_pars_fragment:Up,skinbase_vertex:Hp,skinning_pars_vertex:Vp,skinning_vertex:Gp,skinnormal_vertex:kp,specularmap_fragment:Wp,specularmap_pars_fragment:qp,tonemapping_fragment:Xp,tonemapping_pars_fragment:Zp,transmission_fragment:Yp,transmission_pars_fragment:jp,uv_pars_fragment:Jp,uv_pars_vertex:$p,uv_vertex:Qp,uv2_pars_fragment:Kp,uv2_pars_vertex:em,uv2_vertex:tm,worldpos_vertex:nm,background_vert:im,background_frag:rm,cube_vert:sm,cube_frag:om,depth_vert:am,depth_frag:lm,distanceRGBA_vert:cm,distanceRGBA_frag:um,equirect_vert:hm,equirect_frag:fm,linedashed_vert:dm,linedashed_frag:pm,meshbasic_vert:mm,meshbasic_frag:gm,meshlambert_vert:vm,meshlambert_frag:ym,meshmatcap_vert:_m,meshmatcap_frag:xm,meshnormal_vert:wm,meshnormal_frag:Mm,meshphong_vert:bm,meshphong_frag:Sm,meshphysical_vert:Em,meshphysical_frag:Tm,meshtoon_vert:Am,meshtoon_frag:Cm,points_vert:Lm,points_frag:Rm,shadow_vert:Pm,shadow_frag:Nm,sprite_vert:Dm,sprite_frag:Im},ge={common:{diffuse:{value:new Ee(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new gt},uv2Transform:{value:new gt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new le(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ee(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ee(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new gt}},sprite:{diffuse:{value:new Ee(16777215)},opacity:{value:1},center:{value:new le(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new gt}}},Kt={basic:{uniforms:_t([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.fog]),vertexShader:Oe.meshbasic_vert,fragmentShader:Oe.meshbasic_frag},lambert:{uniforms:_t([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.fog,ge.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Oe.meshlambert_vert,fragmentShader:Oe.meshlambert_frag},phong:{uniforms:_t([ge.common,ge.specularmap,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)},specular:{value:new Ee(1118481)},shininess:{value:30}}]),vertexShader:Oe.meshphong_vert,fragmentShader:Oe.meshphong_frag},standard:{uniforms:_t([ge.common,ge.envmap,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.roughnessmap,ge.metalnessmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Oe.meshphysical_vert,fragmentShader:Oe.meshphysical_frag},toon:{uniforms:_t([ge.common,ge.aomap,ge.lightmap,ge.emissivemap,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.gradientmap,ge.fog,ge.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Oe.meshtoon_vert,fragmentShader:Oe.meshtoon_frag},matcap:{uniforms:_t([ge.common,ge.bumpmap,ge.normalmap,ge.displacementmap,ge.fog,{matcap:{value:null}}]),vertexShader:Oe.meshmatcap_vert,fragmentShader:Oe.meshmatcap_frag},points:{uniforms:_t([ge.points,ge.fog]),vertexShader:Oe.points_vert,fragmentShader:Oe.points_frag},dashed:{uniforms:_t([ge.common,ge.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Oe.linedashed_vert,fragmentShader:Oe.linedashed_frag},depth:{uniforms:_t([ge.common,ge.displacementmap]),vertexShader:Oe.depth_vert,fragmentShader:Oe.depth_frag},normal:{uniforms:_t([ge.common,ge.bumpmap,ge.normalmap,ge.displacementmap,{opacity:{value:1}}]),vertexShader:Oe.meshnormal_vert,fragmentShader:Oe.meshnormal_frag},sprite:{uniforms:_t([ge.sprite,ge.fog]),vertexShader:Oe.sprite_vert,fragmentShader:Oe.sprite_frag},background:{uniforms:{uvTransform:{value:new gt},t2D:{value:null}},vertexShader:Oe.background_vert,fragmentShader:Oe.background_frag},cube:{uniforms:_t([ge.envmap,{opacity:{value:1}}]),vertexShader:Oe.cube_vert,fragmentShader:Oe.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Oe.equirect_vert,fragmentShader:Oe.equirect_frag},distanceRGBA:{uniforms:_t([ge.common,ge.displacementmap,{referencePosition:{value:new P},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Oe.distanceRGBA_vert,fragmentShader:Oe.distanceRGBA_frag},shadow:{uniforms:_t([ge.lights,ge.fog,{color:{value:new Ee(0)},opacity:{value:1}}]),vertexShader:Oe.shadow_vert,fragmentShader:Oe.shadow_frag}};Kt.physical={uniforms:_t([Kt.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new le(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Ee(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new le},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Ee(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Ee(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Oe.meshphysical_vert,fragmentShader:Oe.meshphysical_frag};function Fm(i,e,t,n,r){const s=new Ee(0);let o=0,a,u,h=null,c=0,l=null;function f(v,m){let y=!1,p=m.isScene===!0?m.background:null;p&&p.isTexture&&(p=e.get(p));const g=i.xr,_=g.getSession&&g.getSession();_&&_.environmentBlendMode==="additive"&&(p=null),p===null?d(s,o):p&&p.isColor&&(d(p,1),y=!0),(i.autoClear||y)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),p&&(p.isCubeTexture||p.mapping===Es)?(u===void 0&&(u=new Lt(new Mr(1,1,1),new jn({name:"BackgroundCubeMaterial",uniforms:Pi(Kt.cube.uniforms),vertexShader:Kt.cube.vertexShader,fragmentShader:Kt.cube.fragmentShader,side:at,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(x,M,S){this.matrixWorld.copyPosition(S.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(u)),u.material.uniforms.envMap.value=p,u.material.uniforms.flipEnvMap.value=p.isCubeTexture&&p.isRenderTargetTexture===!1?-1:1,(h!==p||c!==p.version||l!==i.toneMapping)&&(u.material.needsUpdate=!0,h=p,c=p.version,l=i.toneMapping),v.unshift(u,u.geometry,u.material,0,0,null)):p&&p.isTexture&&(a===void 0&&(a=new Lt(new pa(2,2),new jn({name:"BackgroundMaterial",uniforms:Pi(Kt.background.uniforms),vertexShader:Kt.background.vertexShader,fragmentShader:Kt.background.fragmentShader,side:hr,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(a)),a.material.uniforms.t2D.value=p,p.matrixAutoUpdate===!0&&p.updateMatrix(),a.material.uniforms.uvTransform.value.copy(p.matrix),(h!==p||c!==p.version||l!==i.toneMapping)&&(a.material.needsUpdate=!0,h=p,c=p.version,l=i.toneMapping),v.unshift(a,a.geometry,a.material,0,0,null))}function d(v,m){t.buffers.color.setClear(v.r,v.g,v.b,m,r)}return{getClearColor:function(){return s},setClearColor:function(v,m=1){s.set(v),o=m,d(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(v){o=v,d(s,o)},render:f}}function zm(i,e,t,n){const r=i.getParameter(34921),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),o=n.isWebGL2||s!==null,a={},u=m(null);let h=u;function c(O,F,z,N,U){let Y=!1;if(o){const ee=v(N,z,F);h!==ee&&(h=ee,f(h.object)),Y=y(N,U),Y&&p(N,U)}else{const ee=F.wireframe===!0;(h.geometry!==N.id||h.program!==z.id||h.wireframe!==ee)&&(h.geometry=N.id,h.program=z.id,h.wireframe=ee,Y=!0)}O.isInstancedMesh===!0&&(Y=!0),U!==null&&t.update(U,34963),Y&&(w(O,F,z,N),U!==null&&i.bindBuffer(34963,t.get(U).buffer))}function l(){return n.isWebGL2?i.createVertexArray():s.createVertexArrayOES()}function f(O){return n.isWebGL2?i.bindVertexArray(O):s.bindVertexArrayOES(O)}function d(O){return n.isWebGL2?i.deleteVertexArray(O):s.deleteVertexArrayOES(O)}function v(O,F,z){const N=z.wireframe===!0;let U=a[O.id];U===void 0&&(U={},a[O.id]=U);let Y=U[F.id];Y===void 0&&(Y={},U[F.id]=Y);let ee=Y[N];return ee===void 0&&(ee=m(l()),Y[N]=ee),ee}function m(O){const F=[],z=[],N=[];for(let U=0;U<r;U++)F[U]=0,z[U]=0,N[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:F,enabledAttributes:z,attributeDivisors:N,object:O,attributes:{},index:null}}function y(O,F){const z=h.attributes,N=O.attributes;let U=0;for(const Y in N){const ee=z[Y],k=N[Y];if(ee===void 0||ee.attribute!==k||ee.data!==k.data)return!0;U++}return h.attributesNum!==U||h.index!==F}function p(O,F){const z={},N=O.attributes;let U=0;for(const Y in N){const ee=N[Y],k={};k.attribute=ee,ee.data&&(k.data=ee.data),z[Y]=k,U++}h.attributes=z,h.attributesNum=U,h.index=F}function g(){const O=h.newAttributes;for(let F=0,z=O.length;F<z;F++)O[F]=0}function _(O){x(O,0)}function x(O,F){const z=h.newAttributes,N=h.enabledAttributes,U=h.attributeDivisors;z[O]=1,N[O]===0&&(i.enableVertexAttribArray(O),N[O]=1),U[O]!==F&&((n.isWebGL2?i:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](O,F),U[O]=F)}function M(){const O=h.newAttributes,F=h.enabledAttributes;for(let z=0,N=F.length;z<N;z++)F[z]!==O[z]&&(i.disableVertexAttribArray(z),F[z]=0)}function S(O,F,z,N,U,Y){n.isWebGL2===!0&&(z===5124||z===5125)?i.vertexAttribIPointer(O,F,z,U,Y):i.vertexAttribPointer(O,F,z,N,U,Y)}function w(O,F,z,N){if(n.isWebGL2===!1&&(O.isInstancedMesh||N.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;g();const U=N.attributes,Y=z.getAttributes(),ee=F.defaultAttributeValues;for(const k in Y){const q=Y[k];if(q.location>=0){let ae=U[k];if(ae===void 0&&(k==="instanceMatrix"&&O.instanceMatrix&&(ae=O.instanceMatrix),k==="instanceColor"&&O.instanceColor&&(ae=O.instanceColor)),ae!==void 0){const se=ae.normalized,de=ae.itemSize,Se=t.get(ae);if(Se===void 0)continue;const Q=Se.buffer,ve=Se.type,xe=Se.bytesPerElement;if(ae.isInterleavedBufferAttribute){const fe=ae.data,pe=fe.stride,Pe=ae.offset;if(fe&&fe.isInstancedInterleavedBuffer){for(let Z=0;Z<q.locationSize;Z++)x(q.location+Z,fe.meshPerAttribute);O.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=fe.meshPerAttribute*fe.count)}else for(let Z=0;Z<q.locationSize;Z++)_(q.location+Z);i.bindBuffer(34962,Q);for(let Z=0;Z<q.locationSize;Z++)S(q.location+Z,de/q.locationSize,ve,se,pe*xe,(Pe+de/q.locationSize*Z)*xe)}else{if(ae.isInstancedBufferAttribute){for(let fe=0;fe<q.locationSize;fe++)x(q.location+fe,ae.meshPerAttribute);O.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=ae.meshPerAttribute*ae.count)}else for(let fe=0;fe<q.locationSize;fe++)_(q.location+fe);i.bindBuffer(34962,Q);for(let fe=0;fe<q.locationSize;fe++)S(q.location+fe,de/q.locationSize,ve,se,de*xe,de/q.locationSize*fe*xe)}}else if(ee!==void 0){const se=ee[k];if(se!==void 0)switch(se.length){case 2:i.vertexAttrib2fv(q.location,se);break;case 3:i.vertexAttrib3fv(q.location,se);break;case 4:i.vertexAttrib4fv(q.location,se);break;default:i.vertexAttrib1fv(q.location,se)}}}}M()}function C(){T();for(const O in a){const F=a[O];for(const z in F){const N=F[z];for(const U in N)d(N[U].object),delete N[U];delete F[z]}delete a[O]}}function D(O){if(a[O.id]===void 0)return;const F=a[O.id];for(const z in F){const N=F[z];for(const U in N)d(N[U].object),delete N[U];delete F[z]}delete a[O.id]}function I(O){for(const F in a){const z=a[F];if(z[O.id]===void 0)continue;const N=z[O.id];for(const U in N)d(N[U].object),delete N[U];delete z[O.id]}}function T(){B(),h!==u&&(h=u,f(h.object))}function B(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:c,reset:T,resetDefaultState:B,dispose:C,releaseStatesOfGeometry:D,releaseStatesOfProgram:I,initAttributes:g,enableAttribute:_,disableUnusedAttributes:M}}function Om(i,e,t,n){const r=n.isWebGL2;let s;function o(h){s=h}function a(h,c){i.drawArrays(s,h,c),t.update(c,s,1)}function u(h,c,l){if(l===0)return;let f,d;if(r)f=i,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](s,h,c,l),t.update(c,s,l)}this.setMode=o,this.render=a,this.renderInstances=u}function Bm(i,e,t){let n;function r(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const w=e.get("EXT_texture_filter_anisotropic");n=i.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(w){if(w==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";w="mediump"}return w==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&i instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const u=s(a);u!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",u,"instead."),a=u);const h=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,l=i.getParameter(34930),f=i.getParameter(35660),d=i.getParameter(3379),v=i.getParameter(34076),m=i.getParameter(34921),y=i.getParameter(36347),p=i.getParameter(36348),g=i.getParameter(36349),_=f>0,x=o||e.has("OES_texture_float"),M=_&&x,S=o?i.getParameter(36183):0;return{isWebGL2:o,drawBuffers:h,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:l,maxVertexTextures:f,maxTextureSize:d,maxCubemapSize:v,maxAttributes:m,maxVertexUniforms:y,maxVaryings:p,maxFragmentUniforms:g,vertexTextures:_,floatFragmentTextures:x,floatVertexTextures:M,maxSamples:S}}function Um(i){const e=this;let t=null,n=0,r=!1,s=!1;const o=new fn,a=new gt,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(l,f,d){const v=l.length!==0||f||n!==0||r;return r=f,t=c(l,d,0),n=l.length,v},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1,h()},this.setState=function(l,f,d){const v=l.clippingPlanes,m=l.clipIntersection,y=l.clipShadows,p=i.get(l);if(!r||v===null||v.length===0||s&&!y)s?c(null):h();else{const g=s?0:n,_=g*4;let x=p.clippingState||null;u.value=x,x=c(v,f,_,d);for(let M=0;M!==_;++M)x[M]=t[M];p.clippingState=x,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=g}};function h(){u.value!==t&&(u.value=t,u.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function c(l,f,d,v){const m=l!==null?l.length:0;let y=null;if(m!==0){if(y=u.value,v!==!0||y===null){const p=d+m*4,g=f.matrixWorldInverse;a.getNormalMatrix(g),(y===null||y.length<p)&&(y=new Float32Array(p));for(let _=0,x=d;_!==m;++_,x+=4)o.copy(l[_]).applyMatrix4(g,a),o.normal.toArray(y,x),y[x+3]=o.constant}u.value=y,u.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,y}}function Hm(i){let e=new WeakMap;function t(o,a){return a===Uo?o.mapping=xr:a===Ho&&(o.mapping=wr),o}function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Uo||a===Ho)if(e.has(o)){const u=e.get(o).texture;return t(u,o.mapping)}else{const u=o.image;if(u&&u.height>0){const h=i.getRenderTarget(),c=new Fc(u.height/2);return c.fromEquirectangularTexture(i,o),e.set(o,c),i.setRenderTarget(h),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const u=e.get(a);u!==void 0&&(e.delete(a),u.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class ma extends fa{constructor(e=-1,t=1,n=1,r=-1,s=.1,o=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-e,o=n+e,a=r+t,u=r-t;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=h*this.view.offsetX,o=s+h*this.view.width,a-=c*this.view.offsetY,u=a-c*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,u,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}ma.prototype.isOrthographicCamera=!0;class Ps extends jn{constructor(e){super(e);this.type="RawShaderMaterial"}}Ps.prototype.isRawShaderMaterial=!0;const Ai=4,Ln=8,Qt=Math.pow(2,Ln),Oc=[.125,.215,.35,.446,.526,.582],Bc=Ln-Ai+1+Oc.length,di=20,Jn={[Pt]:0,[As]:1,[ca]:2,[Cc]:3,[Lc]:4,[Rc]:5,[la]:6},bo=new ma,{_lodPlanes:Qi,_sizeLods:vl,_sigmas:Yr}=km(),yl=new Ee;let So=null;const qn=(1+Math.sqrt(5))/2,pi=1/qn,_l=[new P(1,1,1),new P(-1,1,1),new P(1,1,-1),new P(-1,1,-1),new P(0,qn,pi),new P(0,qn,-pi),new P(pi,0,qn),new P(-pi,0,qn),new P(qn,pi,0),new P(-qn,pi,0)];class Vm{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=Wm(di),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){So=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(e,n,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Ml(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=wl(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Qi.length;e++)Qi[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(So),e.scissorTest=!1,jr(e,0,0,e.width,e.height)}_fromTexture(e){So=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:ht,minFilter:ht,generateMipmaps:!1,type:Nn,format:jh,encoding:Gm(e)?e.encoding:ca,depthBuffer:!1},n=xl(t);return n.depthBuffer=!e,this._pingPongRenderTarget=xl(t),n}_compileMaterial(e){const t=new Lt(Qi[0],e);this._renderer.compile(t,bo)}_sceneToCubeUV(e,t,n,r){const a=new Ct(90,1,t,n),u=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],c=this._renderer,l=c.autoClear,f=c.outputEncoding,d=c.toneMapping;c.getClearColor(yl),c.toneMapping=Xn,c.outputEncoding=Pt,c.autoClear=!1;const v=new ha({name:"PMREM.Background",side:at,depthWrite:!1,depthTest:!1}),m=new Lt(new Mr,v);let y=!1;const p=e.background;p?p.isColor&&(v.color.copy(p),e.background=null,y=!0):(v.color.copy(yl),y=!0);for(let g=0;g<6;g++){const _=g%3;_==0?(a.up.set(0,u[g],0),a.lookAt(h[g],0,0)):_==1?(a.up.set(0,0,u[g]),a.lookAt(0,h[g],0)):(a.up.set(0,u[g],0),a.lookAt(0,0,h[g])),jr(r,_*Qt,g>2?Qt:0,Qt,Qt),c.setRenderTarget(r),y&&c.render(m,a),c.render(e,a)}m.geometry.dispose(),m.material.dispose(),c.toneMapping=d,c.outputEncoding=f,c.autoClear=l,e.background=p}_setEncoding(e,t){e.value=Jn[t.encoding]}_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===xr||e.mapping===wr;r?this._cubemapShader==null&&(this._cubemapShader=Ml()):this._equirectShader==null&&(this._equirectShader=wl());const s=r?this._cubemapShader:this._equirectShader,o=new Lt(Qi[0],s),a=s.uniforms;a.envMap.value=e,r||a.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(a.inputEncoding,e),this._setEncoding(a.outputEncoding,t.texture),jr(t,0,0,3*Qt,2*Qt),n.setRenderTarget(t),n.render(o,bo)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let r=1;r<Bc;r++){const s=Math.sqrt(Yr[r]*Yr[r]-Yr[r-1]*Yr[r-1]),o=_l[(r-1)%_l.length];this._blur(e,r-1,r,s,o)}t.autoClear=n}_blur(e,t,n,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,n,r,"latitudinal",s),this._halfBlur(o,e,n,n,r,"longitudinal",s)}_halfBlur(e,t,n,r,s,o,a){const u=this._renderer,h=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,l=new Lt(Qi[r],h),f=h.uniforms,d=vl[n]-1,v=isFinite(s)?Math.PI/(2*d):2*Math.PI/(2*di-1),m=s/v,y=isFinite(s)?1+Math.floor(c*m):di;y>di&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${di}`);const p=[];let g=0;for(let S=0;S<di;++S){const w=S/m,C=Math.exp(-w*w/2);p.push(C),S==0?g+=C:S<y&&(g+=2*C)}for(let S=0;S<p.length;S++)p[S]=p[S]/g;f.envMap.value=e.texture,f.samples.value=y,f.weights.value=p,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a),f.dTheta.value=v,f.mipInt.value=Ln-n,this._setEncoding(f.inputEncoding,e.texture),this._setEncoding(f.outputEncoding,e.texture);const _=vl[r],x=3*Math.max(0,Qt-2*_),M=(r===0?0:2*Qt)+2*_*(r>Ln-Ai?r-Ln+Ai:0);jr(t,x,M,3*_,2*_),u.setRenderTarget(t),u.render(l,bo)}}function Gm(i){return i===void 0||i.type!==Nn?!1:i.encoding===Pt||i.encoding===As||i.encoding===la}function km(){const i=[],e=[],t=[];let n=Ln;for(let r=0;r<Bc;r++){const s=Math.pow(2,n);e.push(s);let o=1/s;r>Ln-Ai?o=Oc[r-Ln+Ai-1]:r==0&&(o=0),t.push(o);const a=1/(s-1),u=-a/2,h=1+a/2,c=[u,u,h,u,h,h,u,u,h,h,u,h],l=6,f=6,d=3,v=2,m=1,y=new Float32Array(d*f*l),p=new Float32Array(v*f*l),g=new Float32Array(m*f*l);for(let x=0;x<l;x++){const M=x%3*2/3-1,S=x>2?0:-1,w=[M,S,0,M+2/3,S,0,M+2/3,S+1,0,M,S,0,M+2/3,S+1,0,M,S+1,0];y.set(w,d*f*x),p.set(c,v*f*x);const C=[x,x,x,x,x,x];g.set(C,m*f*x)}const _=new Ye;_.setAttribute("position",new ct(y,d)),_.setAttribute("uv",new ct(p,v)),_.setAttribute("faceIndex",new ct(g,m)),i.push(_),n>Ai&&n--}return{_lodPlanes:i,_sizeLods:e,_sigmas:t}}function xl(i){const e=new Vt(3*Qt,3*Qt,i);return e.texture.mapping=Es,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function jr(i,e,t,n,r){i.viewport.set(e,t,n,r),i.scissor.set(e,t,n,r)}function Wm(i){const e=new Float32Array(i),t=new P(0,1,0);return new Ps({name:"SphericalGaussianBlur",defines:{n:i},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Jn[Pt]},outputEncoding:{value:Jn[Pt]}},vertexShader:ga(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${va()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function wl(){const i=new le(1,1);return new Ps({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:i},inputEncoding:{value:Jn[Pt]},outputEncoding:{value:Jn[Pt]}},vertexShader:ga(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${va()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function Ml(){return new Ps({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Jn[Pt]},outputEncoding:{value:Jn[Pt]}},vertexShader:ga(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${va()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Cn,depthTest:!1,depthWrite:!1})}function ga(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function va(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function qm(i){let e=new WeakMap,t=null;function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const u=a.mapping,h=u===Uo||u===Ho,c=u===xr||u===wr;if(h||c){if(e.has(a))return e.get(a).texture;{const l=a.image;if(h&&l&&l.height>0||c&&l&&r(l)){const f=i.getRenderTarget();t===null&&(t=new Vm(i));const d=h?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),i.setRenderTarget(f),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function r(a){let u=0;const h=6;for(let c=0;c<h;c++)a[c]!==void 0&&u++;return u===h}function s(a){const u=a.target;u.removeEventListener("dispose",s);const h=e.get(u);h!==void 0&&(e.delete(u),h.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:o}}function Xm(i){const e={};function t(n){if(e[n]!==void 0)return e[n];let r;switch(n){case"WEBGL_depth_texture":r=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=i.getExtension(n)}return e[n]=r,r}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const r=t(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function Zm(i,e,t,n){const r={},s=new WeakMap;function o(l){const f=l.target;f.index!==null&&e.remove(f.index);for(const v in f.attributes)e.remove(f.attributes[v]);f.removeEventListener("dispose",o),delete r[f.id];const d=s.get(f);d&&(e.remove(d),s.delete(f)),n.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(l,f){return r[f.id]===!0||(f.addEventListener("dispose",o),r[f.id]=!0,t.memory.geometries++),f}function u(l){const f=l.attributes;for(const v in f)e.update(f[v],34962);const d=l.morphAttributes;for(const v in d){const m=d[v];for(let y=0,p=m.length;y<p;y++)e.update(m[y],34962)}}function h(l){const f=[],d=l.index,v=l.attributes.position;let m=0;if(d!==null){const g=d.array;m=d.version;for(let _=0,x=g.length;_<x;_+=3){const M=g[_+0],S=g[_+1],w=g[_+2];f.push(M,S,S,w,w,M)}}else{const g=v.array;m=v.version;for(let _=0,x=g.length/3-1;_<x;_+=3){const M=_+0,S=_+1,w=_+2;f.push(M,S,S,w,w,M)}}const y=new(Pc(f)>65535?Ic:Dc)(f,1);y.version=m;const p=s.get(l);p&&e.remove(p),s.set(l,y)}function c(l){const f=s.get(l);if(f){const d=l.index;d!==null&&f.version<d.version&&h(l)}else h(l);return s.get(l)}return{get:a,update:u,getWireframeAttribute:c}}function Ym(i,e,t,n){const r=n.isWebGL2;let s;function o(f){s=f}let a,u;function h(f){a=f.type,u=f.bytesPerElement}function c(f,d){i.drawElements(s,d,a,f*u),t.update(d,s,1)}function l(f,d,v){if(v===0)return;let m,y;if(r)m=i,y="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[y](s,d,a,f*u,v),t.update(d,s,v)}this.setMode=o,this.setIndex=h,this.render=c,this.renderInstances=l}function jm(i){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(s/3);break;case 1:t.lines+=a*(s/2);break;case 3:t.lines+=a*(s-1);break;case 2:t.lines+=a*s;break;case 0:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:n}}class ya extends yt{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r},this.magFilter=ht,this.minFilter=ht,this.wrapR=Bt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ya.prototype.isDataTexture2DArray=!0;function Jm(i,e){return i[0]-e[0]}function $m(i,e){return Math.abs(e[1])-Math.abs(i[1])}function bl(i,e){let t=1;const n=e.isInterleavedBufferAttribute?e.data.array:e.array;n instanceof Int8Array?t=127:n instanceof Int16Array?t=32767:n instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),i.divideScalar(t)}function Qm(i,e,t){const n={},r=new Float32Array(8),s=new WeakMap,o=new P,a=[];for(let h=0;h<8;h++)a[h]=[h,0];function u(h,c,l,f){const d=h.morphTargetInfluences;if(e.isWebGL2===!0){const v=c.morphAttributes.position.length;let m=s.get(c);if(m===void 0||m.count!==v){m!==void 0&&m.texture.dispose();const g=c.morphAttributes.normal!==void 0,_=c.morphAttributes.position,x=c.morphAttributes.normal||[],M=c.attributes.position.count,S=g===!0?2:1;let w=M*S,C=1;w>e.maxTextureSize&&(C=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);const D=new Float32Array(w*C*4*v),I=new ya(D,w,C,v);I.format=St,I.type=Tn;const T=S*4;for(let B=0;B<v;B++){const O=_[B],F=x[B],z=w*C*4*B;for(let N=0;N<O.count;N++){o.fromBufferAttribute(O,N),O.normalized===!0&&bl(o,O);const U=N*T;D[z+U+0]=o.x,D[z+U+1]=o.y,D[z+U+2]=o.z,D[z+U+3]=0,g===!0&&(o.fromBufferAttribute(F,N),F.normalized===!0&&bl(o,F),D[z+U+4]=o.x,D[z+U+5]=o.y,D[z+U+6]=o.z,D[z+U+7]=0)}}m={count:v,texture:I,size:new le(w,C)},s.set(c,m)}let y=0;for(let g=0;g<d.length;g++)y+=d[g];const p=c.morphTargetsRelative?1:1-y;f.getUniforms().setValue(i,"morphTargetBaseInfluence",p),f.getUniforms().setValue(i,"morphTargetInfluences",d),f.getUniforms().setValue(i,"morphTargetsTexture",m.texture,t),f.getUniforms().setValue(i,"morphTargetsTextureSize",m.size)}else{const v=d===void 0?0:d.length;let m=n[c.id];if(m===void 0||m.length!==v){m=[];for(let x=0;x<v;x++)m[x]=[x,0];n[c.id]=m}for(let x=0;x<v;x++){const M=m[x];M[0]=x,M[1]=d[x]}m.sort($m);for(let x=0;x<8;x++)x<v&&m[x][1]?(a[x][0]=m[x][0],a[x][1]=m[x][1]):(a[x][0]=Number.MAX_SAFE_INTEGER,a[x][1]=0);a.sort(Jm);const y=c.morphAttributes.position,p=c.morphAttributes.normal;let g=0;for(let x=0;x<8;x++){const M=a[x],S=M[0],w=M[1];S!==Number.MAX_SAFE_INTEGER&&w?(y&&c.getAttribute("morphTarget"+x)!==y[S]&&c.setAttribute("morphTarget"+x,y[S]),p&&c.getAttribute("morphNormal"+x)!==p[S]&&c.setAttribute("morphNormal"+x,p[S]),r[x]=w,g+=w):(y&&c.hasAttribute("morphTarget"+x)===!0&&c.deleteAttribute("morphTarget"+x),p&&c.hasAttribute("morphNormal"+x)===!0&&c.deleteAttribute("morphNormal"+x),r[x]=0)}const _=c.morphTargetsRelative?1:1-g;f.getUniforms().setValue(i,"morphTargetBaseInfluence",_),f.getUniforms().setValue(i,"morphTargetInfluences",r)}}return{update:u}}function Km(i,e,t,n){let r=new WeakMap;function s(u){const h=n.render.frame,c=u.geometry,l=e.get(u,c);return r.get(l)!==h&&(e.update(l),r.set(l,h)),u.isInstancedMesh&&(u.hasEventListener("dispose",a)===!1&&u.addEventListener("dispose",a),t.update(u.instanceMatrix,34962),u.instanceColor!==null&&t.update(u.instanceColor,34962)),l}function o(){r=new WeakMap}function a(u){const h=u.target;h.removeEventListener("dispose",a),t.remove(h.instanceMatrix),h.instanceColor!==null&&t.remove(h.instanceColor)}return{update:s,dispose:o}}class Uc extends yt{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r},this.magFilter=ht,this.minFilter=ht,this.wrapR=Bt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Uc.prototype.isDataTexture3D=!0;const Hc=new yt,Vc=new ya,Gc=new Uc,kc=new Ls,Sl=[],El=[],Tl=new Float32Array(16),Al=new Float32Array(9),Cl=new Float32Array(4);function Hi(i,e,t){const n=i[0];if(n<=0||n>0)return i;const r=e*t;let s=Sl[r];if(s===void 0&&(s=new Float32Array(r),Sl[r]=s),e!==0){n.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,i[o].toArray(s,a)}return s}function Et(i,e){if(i.length!==e.length)return!1;for(let t=0,n=i.length;t<n;t++)if(i[t]!==e[t])return!1;return!0}function xt(i,e){for(let t=0,n=e.length;t<n;t++)i[t]=e[t]}function Ns(i,e){let t=El[e];t===void 0&&(t=new Int32Array(e),El[e]=t);for(let n=0;n!==e;++n)t[n]=i.allocateTextureUnit();return t}function eg(i,e){const t=this.cache;t[0]!==e&&(i.uniform1f(this.addr,e),t[0]=e)}function tg(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(i.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Et(t,e))return;i.uniform2fv(this.addr,e),xt(t,e)}}function ng(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(i.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(i.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Et(t,e))return;i.uniform3fv(this.addr,e),xt(t,e)}}function ig(i,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(i.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Et(t,e))return;i.uniform4fv(this.addr,e),xt(t,e)}}function rg(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(Et(t,e))return;i.uniformMatrix2fv(this.addr,!1,e),xt(t,e)}else{if(Et(t,n))return;Cl.set(n),i.uniformMatrix2fv(this.addr,!1,Cl),xt(t,n)}}function sg(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(Et(t,e))return;i.uniformMatrix3fv(this.addr,!1,e),xt(t,e)}else{if(Et(t,n))return;Al.set(n),i.uniformMatrix3fv(this.addr,!1,Al),xt(t,n)}}function og(i,e){const t=this.cache,n=e.elements;if(n===void 0){if(Et(t,e))return;i.uniformMatrix4fv(this.addr,!1,e),xt(t,e)}else{if(Et(t,n))return;Tl.set(n),i.uniformMatrix4fv(this.addr,!1,Tl),xt(t,n)}}function ag(i,e){const t=this.cache;t[0]!==e&&(i.uniform1i(this.addr,e),t[0]=e)}function lg(i,e){const t=this.cache;Et(t,e)||(i.uniform2iv(this.addr,e),xt(t,e))}function cg(i,e){const t=this.cache;Et(t,e)||(i.uniform3iv(this.addr,e),xt(t,e))}function ug(i,e){const t=this.cache;Et(t,e)||(i.uniform4iv(this.addr,e),xt(t,e))}function hg(i,e){const t=this.cache;t[0]!==e&&(i.uniform1ui(this.addr,e),t[0]=e)}function fg(i,e){const t=this.cache;Et(t,e)||(i.uniform2uiv(this.addr,e),xt(t,e))}function dg(i,e){const t=this.cache;Et(t,e)||(i.uniform3uiv(this.addr,e),xt(t,e))}function pg(i,e){const t=this.cache;Et(t,e)||(i.uniform4uiv(this.addr,e),xt(t,e))}function mg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.safeSetTexture2D(e||Hc,r)}function gg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.setTexture3D(e||Gc,r)}function vg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.safeSetTextureCube(e||kc,r)}function yg(i,e,t){const n=this.cache,r=t.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),t.setTexture2DArray(e||Vc,r)}function _g(i){switch(i){case 5126:return eg;case 35664:return tg;case 35665:return ng;case 35666:return ig;case 35674:return rg;case 35675:return sg;case 35676:return og;case 5124:case 35670:return ag;case 35667:case 35671:return lg;case 35668:case 35672:return cg;case 35669:case 35673:return ug;case 5125:return hg;case 36294:return fg;case 36295:return dg;case 36296:return pg;case 35678:case 36198:case 36298:case 36306:case 35682:return mg;case 35679:case 36299:case 36307:return gg;case 35680:case 36300:case 36308:case 36293:return vg;case 36289:case 36303:case 36311:case 36292:return yg}}function xg(i,e){i.uniform1fv(this.addr,e)}function wg(i,e){const t=Hi(e,this.size,2);i.uniform2fv(this.addr,t)}function Mg(i,e){const t=Hi(e,this.size,3);i.uniform3fv(this.addr,t)}function bg(i,e){const t=Hi(e,this.size,4);i.uniform4fv(this.addr,t)}function Sg(i,e){const t=Hi(e,this.size,4);i.uniformMatrix2fv(this.addr,!1,t)}function Eg(i,e){const t=Hi(e,this.size,9);i.uniformMatrix3fv(this.addr,!1,t)}function Tg(i,e){const t=Hi(e,this.size,16);i.uniformMatrix4fv(this.addr,!1,t)}function Ag(i,e){i.uniform1iv(this.addr,e)}function Cg(i,e){i.uniform2iv(this.addr,e)}function Lg(i,e){i.uniform3iv(this.addr,e)}function Rg(i,e){i.uniform4iv(this.addr,e)}function Pg(i,e){i.uniform1uiv(this.addr,e)}function Ng(i,e){i.uniform2uiv(this.addr,e)}function Dg(i,e){i.uniform3uiv(this.addr,e)}function Ig(i,e){i.uniform4uiv(this.addr,e)}function Fg(i,e,t){const n=e.length,r=Ns(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.safeSetTexture2D(e[s]||Hc,r[s])}function zg(i,e,t){const n=e.length,r=Ns(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.setTexture3D(e[s]||Gc,r[s])}function Og(i,e,t){const n=e.length,r=Ns(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.safeSetTextureCube(e[s]||kc,r[s])}function Bg(i,e,t){const n=e.length,r=Ns(t,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)t.setTexture2DArray(e[s]||Vc,r[s])}function Ug(i){switch(i){case 5126:return xg;case 35664:return wg;case 35665:return Mg;case 35666:return bg;case 35674:return Sg;case 35675:return Eg;case 35676:return Tg;case 5124:case 35670:return Ag;case 35667:case 35671:return Cg;case 35668:case 35672:return Lg;case 35669:case 35673:return Rg;case 5125:return Pg;case 36294:return Ng;case 36295:return Dg;case 36296:return Ig;case 35678:case 36198:case 36298:case 36306:case 35682:return Fg;case 35679:case 36299:case 36307:return zg;case 35680:case 36300:case 36308:case 36293:return Og;case 36289:case 36303:case 36311:case 36292:return Bg}}function Hg(i,e,t){this.id=i,this.addr=t,this.cache=[],this.setValue=_g(e.type)}function Wc(i,e,t){this.id=i,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Ug(e.type)}Wc.prototype.updateCache=function(i){const e=this.cache;i instanceof Float32Array&&e.length!==i.length&&(this.cache=new Float32Array(i.length)),xt(e,i)};function qc(i){this.id=i,this.seq=[],this.map={}}qc.prototype.setValue=function(i,e,t){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const o=n[r];o.setValue(i,e[o.id],t)}};const Eo=/(\w+)(\])?(\[|\.)?/g;function Ll(i,e){i.seq.push(e),i.map[e.id]=e}function Vg(i,e,t){const n=i.name,r=n.length;for(Eo.lastIndex=0;;){const s=Eo.exec(n),o=Eo.lastIndex;let a=s[1];const u=s[2]==="]",h=s[3];if(u&&(a=a|0),h===void 0||h==="["&&o+2===r){Ll(t,h===void 0?new Hg(a,i,e):new Wc(a,i,e));break}else{let l=t.map[a];l===void 0&&(l=new qc(a),Ll(t,l)),t=l}}}function Rn(i,e){this.seq=[],this.map={};const t=i.getProgramParameter(e,35718);for(let n=0;n<t;++n){const r=i.getActiveUniform(e,n),s=i.getUniformLocation(e,r.name);Vg(r,s,this)}}Rn.prototype.setValue=function(i,e,t,n){const r=this.map[e];r!==void 0&&r.setValue(i,t,n)};Rn.prototype.setOptional=function(i,e,t){const n=e[t];n!==void 0&&this.setValue(i,t,n)};Rn.upload=function(i,e,t,n){for(let r=0,s=e.length;r!==s;++r){const o=e[r],a=t[o.id];a.needsUpdate!==!1&&o.setValue(i,a.value,n)}};Rn.seqWithValue=function(i,e){const t=[];for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.id in e&&t.push(s)}return t};function Rl(i,e,t){const n=i.createShader(e);return i.shaderSource(n,t),i.compileShader(n),n}let Gg=0;function kg(i){const e=i.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function Xc(i){switch(i){case Pt:return["Linear","( value )"];case As:return["sRGB","( value )"];case ca:return["RGBE","( value )"];case Cc:return["RGBM","( value, 7.0 )"];case Lc:return["RGBM","( value, 16.0 )"];case Rc:return["RGBD","( value, 256.0 )"];case la:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function Pl(i,e,t){const n=i.getShaderParameter(e,35713),r=i.getShaderInfoLog(e).trim();return n&&r===""?"":t.toUpperCase()+`

`+r+`

`+kg(i.getShaderSource(e))}function Wn(i,e){const t=Xc(e);return"vec4 "+i+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Wg(i,e){const t=Xc(e);return"vec4 "+i+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function qg(i,e){let t;switch(e){case Ih:t="Linear";break;case Fh:t="Reinhard";break;case zh:t="OptimizedCineon";break;case Oh:t="ACESFilmic";break;case Bh:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+i+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xg(i){return[i.extensionDerivatives||i.envMapCubeUV||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap||i.transmission)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(sr).join(`
`)}function Zg(i){const e=[];for(const t in i){const n=i[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function Yg(i,e){const t={},n=i.getProgramParameter(e,35721);for(let r=0;r<n;r++){const s=i.getActiveAttrib(e,r),o=s.name;let a=1;s.type===35674&&(a=2),s.type===35675&&(a=3),s.type===35676&&(a=4),t[o]={type:s.type,location:i.getAttribLocation(e,o),locationSize:a}}return t}function sr(i){return i!==""}function Nl(i,e){return i.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Dl(i,e){return i.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const jg=/^[ \t]*#include +<([\w\d./]+)>/gm;function Wo(i){return i.replace(jg,Jg)}function Jg(i,e){const t=Oe[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Wo(t)}const $g=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Qg=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Il(i){return i.replace(Qg,Zc).replace($g,Kg)}function Kg(i,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Zc(i,e,t,n)}function Zc(i,e,t,n){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Fl(i){let e="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?e+=`
#define HIGH_PRECISION`:i.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function ev(i){let e="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===Mc?e="SHADOWMAP_TYPE_PCF":i.shadowMapType===fh?e="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===rr&&(e="SHADOWMAP_TYPE_VSM"),e}function tv(i){let e="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case xr:case wr:e="ENVMAP_TYPE_CUBE";break;case Es:case oa:e="ENVMAP_TYPE_CUBE_UV";break}return e}function nv(i){let e="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case wr:case oa:e="ENVMAP_MODE_REFRACTION";break}return e}function iv(i){let e="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case Ss:e="ENVMAP_BLENDING_MULTIPLY";break;case Nh:e="ENVMAP_BLENDING_MIX";break;case Dh:e="ENVMAP_BLENDING_ADD";break}return e}function rv(i,e,t,n){const r=i.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const u=ev(t),h=tv(t),c=nv(t),l=iv(t),f=i.gammaFactor>0?i.gammaFactor:1,d=t.isWebGL2?"":Xg(t),v=Zg(s),m=r.createProgram();let y,p,g=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=[v].filter(sr).join(`
`),y.length>0&&(y+=`
`),p=[d,v].filter(sr).join(`
`),p.length>0&&(p+=`
`)):(y=[Fl(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(sr).join(`
`),p=[d,Fl(t),"#define SHADER_NAME "+t.shaderName,v,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.envMap?"#define "+c:"",t.envMap?"#define "+l:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+u:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Xn?"#define TONE_MAPPING":"",t.toneMapping!==Xn?Oe.tonemapping_pars_fragment:"",t.toneMapping!==Xn?qg("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===Zn?"#define OPAQUE":"",Oe.encodings_pars_fragment,t.map?Wn("mapTexelToLinear",t.mapEncoding):"",t.matcap?Wn("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?Wn("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?Wn("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularColorMap?Wn("specularColorMapTexelToLinear",t.specularColorMapEncoding):"",t.sheenColorMap?Wn("sheenColorMapTexelToLinear",t.sheenColorMapEncoding):"",t.lightMap?Wn("lightMapTexelToLinear",t.lightMapEncoding):"",Wg("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(sr).join(`
`)),o=Wo(o),o=Nl(o,t),o=Dl(o,t),a=Wo(a),a=Nl(a,t),a=Dl(a,t),o=Il(o),a=Il(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(g=`#version 300 es
`,y=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,p=["#define varying in",t.glslVersion===il?"":"out highp vec4 pc_fragColor;",t.glslVersion===il?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+p);const _=g+y+o,x=g+p+a,M=Rl(r,35633,_),S=Rl(r,35632,x);if(r.attachShader(m,M),r.attachShader(m,S),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),i.debug.checkShaderErrors){const D=r.getProgramInfoLog(m).trim(),I=r.getShaderInfoLog(M).trim(),T=r.getShaderInfoLog(S).trim();let B=!0,O=!0;if(r.getProgramParameter(m,35714)===!1){B=!1;const F=Pl(r,M,"vertex"),z=Pl(r,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,35715)+`

Program Info Log: `+D+`
`+F+`
`+z)}else D!==""?console.warn("THREE.WebGLProgram: Program Info Log:",D):(I===""||T==="")&&(O=!1);O&&(this.diagnostics={runnable:B,programLog:D,vertexShader:{log:I,prefix:y},fragmentShader:{log:T,prefix:p}})}r.deleteShader(M),r.deleteShader(S);let w;this.getUniforms=function(){return w===void 0&&(w=new Rn(r,m)),w};let C;return this.getAttributes=function(){return C===void 0&&(C=Yg(r,m)),C},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Gg++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=M,this.fragmentShader=S,this}function sv(i,e,t,n,r,s,o){const a=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,c=r.floatVertexTextures,l=r.maxVertexUniforms,f=r.vertexTextures;let d=r.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function y(w){const D=w.skeleton.bones;if(c)return 1024;{const T=Math.floor((l-20)/4),B=Math.min(T,D.length);return B<D.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+D.length+" bones. This GPU supports "+B+"."),0):B}}function p(w){let C;return w&&w.isTexture?C=w.encoding:w&&w.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),C=w.texture.encoding):C=Pt,C}function g(w,C,D,I,T){const B=I.fog,O=w.isMeshStandardMaterial?I.environment:null,F=(w.isMeshStandardMaterial?t:e).get(w.envMap||O),z=v[w.type],N=T.isSkinnedMesh?y(T):0;w.precision!==null&&(d=r.getMaxPrecision(w.precision),d!==w.precision&&console.warn("THREE.WebGLProgram.getParameters:",w.precision,"not supported, using",d,"instead."));let U,Y;if(z){const se=Kt[z];U=se.vertexShader,Y=se.fragmentShader}else U=w.vertexShader,Y=w.fragmentShader;const ee=i.getRenderTarget(),k=w.alphaTest>0,q=w.clearcoat>0;return{isWebGL2:u,shaderID:z,shaderName:w.type,vertexShader:U,fragmentShader:Y,defines:w.defines,isRawShaderMaterial:w.isRawShaderMaterial===!0,glslVersion:w.glslVersion,precision:d,instancing:T.isInstancedMesh===!0,instancingColor:T.isInstancedMesh===!0&&T.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ee!==null?p(ee.texture):i.outputEncoding,map:!!w.map,mapEncoding:p(w.map),matcap:!!w.matcap,matcapEncoding:p(w.matcap),envMap:!!F,envMapMode:F&&F.mapping,envMapEncoding:p(F),envMapCubeUV:!!F&&(F.mapping===Es||F.mapping===oa),lightMap:!!w.lightMap,lightMapEncoding:p(w.lightMap),aoMap:!!w.aoMap,emissiveMap:!!w.emissiveMap,emissiveMapEncoding:p(w.emissiveMap),bumpMap:!!w.bumpMap,normalMap:!!w.normalMap,objectSpaceNormalMap:w.normalMapType===Uf,tangentSpaceNormalMap:w.normalMapType===Fi,clearcoat:q,clearcoatMap:q&&!!w.clearcoatMap,clearcoatRoughnessMap:q&&!!w.clearcoatRoughnessMap,clearcoatNormalMap:q&&!!w.clearcoatNormalMap,displacementMap:!!w.displacementMap,roughnessMap:!!w.roughnessMap,metalnessMap:!!w.metalnessMap,specularMap:!!w.specularMap,specularIntensityMap:!!w.specularIntensityMap,specularColorMap:!!w.specularColorMap,specularColorMapEncoding:p(w.specularColorMap),alphaMap:!!w.alphaMap,alphaTest:k,gradientMap:!!w.gradientMap,sheen:w.sheen>0,sheenColorMap:!!w.sheenColorMap,sheenColorMapEncoding:p(w.sheenColorMap),sheenRoughnessMap:!!w.sheenRoughnessMap,transmission:w.transmission>0,transmissionMap:!!w.transmissionMap,thicknessMap:!!w.thicknessMap,combine:w.combine,vertexTangents:!!w.normalMap&&!!T.geometry&&!!T.geometry.attributes.tangent,vertexColors:w.vertexColors,vertexAlphas:w.vertexColors===!0&&!!T.geometry&&!!T.geometry.attributes.color&&T.geometry.attributes.color.itemSize===4,vertexUvs:!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatMap||!!w.clearcoatRoughnessMap||!!w.clearcoatNormalMap||!!w.displacementMap||!!w.transmissionMap||!!w.thicknessMap||!!w.specularIntensityMap||!!w.specularColorMap||!!w.sheenColorMap||w.sheenRoughnessMap,uvsVertexOnly:!(!!w.map||!!w.bumpMap||!!w.normalMap||!!w.specularMap||!!w.alphaMap||!!w.emissiveMap||!!w.roughnessMap||!!w.metalnessMap||!!w.clearcoatNormalMap||w.transmission>0||!!w.transmissionMap||!!w.thicknessMap||!!w.specularIntensityMap||!!w.specularColorMap||w.sheen>0||!!w.sheenColorMap||!!w.sheenRoughnessMap)&&!!w.displacementMap,fog:!!B,useFog:w.fog,fogExp2:B&&B.isFogExp2,flatShading:!!w.flatShading,sizeAttenuation:w.sizeAttenuation,logarithmicDepthBuffer:h,skinning:T.isSkinnedMesh===!0&&N>0,maxBones:N,useVertexTexture:c,morphTargets:!!T.geometry&&!!T.geometry.morphAttributes.position,morphNormals:!!T.geometry&&!!T.geometry.morphAttributes.normal,morphTargetsCount:!!T.geometry&&!!T.geometry.morphAttributes.position?T.geometry.morphAttributes.position.length:0,numDirLights:C.directional.length,numPointLights:C.point.length,numSpotLights:C.spot.length,numRectAreaLights:C.rectArea.length,numHemiLights:C.hemi.length,numDirLightShadows:C.directionalShadowMap.length,numPointLightShadows:C.pointShadowMap.length,numSpotLightShadows:C.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,format:w.format,dithering:w.dithering,shadowMapEnabled:i.shadowMap.enabled&&D.length>0,shadowMapType:i.shadowMap.type,toneMapping:w.toneMapped?i.toneMapping:Xn,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:w.premultipliedAlpha,doubleSided:w.side===Li,flipSided:w.side===at,depthPacking:w.depthPacking!==void 0?w.depthPacking:!1,index0AttributeName:w.index0AttributeName,extensionDerivatives:w.extensions&&w.extensions.derivatives,extensionFragDepth:w.extensions&&w.extensions.fragDepth,extensionDrawBuffers:w.extensions&&w.extensions.drawBuffers,extensionShaderTextureLOD:w.extensions&&w.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:w.customProgramCacheKey()}}function _(w){const C=[];if(w.shaderID?C.push(w.shaderID):(C.push(sl(w.fragmentShader)),C.push(sl(w.vertexShader))),w.defines!==void 0)for(const D in w.defines)C.push(D),C.push(w.defines[D]);if(w.isRawShaderMaterial===!1){for(let D=0;D<m.length;D++)C.push(w[m[D]]);C.push(i.outputEncoding),C.push(i.gammaFactor)}return C.push(w.customProgramCacheKey),C.join()}function x(w){const C=v[w.type];let D;if(C){const I=Kt[C];D=id.clone(I.uniforms)}else D=w.uniforms;return D}function M(w,C){let D;for(let I=0,T=a.length;I<T;I++){const B=a[I];if(B.cacheKey===C){D=B,++D.usedTimes;break}}return D===void 0&&(D=new rv(i,C,w,s),a.push(D)),D}function S(w){if(--w.usedTimes===0){const C=a.indexOf(w);a[C]=a[a.length-1],a.pop(),w.destroy()}}return{getParameters:g,getProgramCacheKey:_,getUniforms:x,acquireProgram:M,releaseProgram:S,programs:a}}function ov(){let i=new WeakMap;function e(s){let o=i.get(s);return o===void 0&&(o={},i.set(s,o)),o}function t(s){i.delete(s)}function n(s,o,a){i.get(s)[o]=a}function r(){i=new WeakMap}return{get:e,remove:t,update:n,dispose:r}}function av(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.program!==e.program?i.program.id-e.program.id:i.material.id!==e.material.id?i.material.id-e.material.id:i.z!==e.z?i.z-e.z:i.id-e.id}function zl(i,e){return i.groupOrder!==e.groupOrder?i.groupOrder-e.groupOrder:i.renderOrder!==e.renderOrder?i.renderOrder-e.renderOrder:i.z!==e.z?e.z-i.z:i.id-e.id}function Ol(i){const e=[];let t=0;const n=[],r=[],s=[],o={id:-1};function a(){t=0,n.length=0,r.length=0,s.length=0}function u(d,v,m,y,p,g){let _=e[t];const x=i.get(m);return _===void 0?(_={id:d.id,object:d,geometry:v,material:m,program:x.program||o,groupOrder:y,renderOrder:d.renderOrder,z:p,group:g},e[t]=_):(_.id=d.id,_.object=d,_.geometry=v,_.material=m,_.program=x.program||o,_.groupOrder=y,_.renderOrder=d.renderOrder,_.z=p,_.group=g),t++,_}function h(d,v,m,y,p,g){const _=u(d,v,m,y,p,g);m.transmission>0?r.push(_):m.transparent===!0?s.push(_):n.push(_)}function c(d,v,m,y,p,g){const _=u(d,v,m,y,p,g);m.transmission>0?r.unshift(_):m.transparent===!0?s.unshift(_):n.unshift(_)}function l(d,v){n.length>1&&n.sort(d||av),r.length>1&&r.sort(v||zl),s.length>1&&s.sort(v||zl)}function f(){for(let d=t,v=e.length;d<v;d++){const m=e[d];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.program=null,m.group=null}}return{opaque:n,transmissive:r,transparent:s,init:a,push:h,unshift:c,finish:f,sort:l}}function lv(i){let e=new WeakMap;function t(r,s){let o;return e.has(r)===!1?(o=new Ol(i),e.set(r,[o])):s>=e.get(r).length?(o=new Ol(i),e.get(r).push(o)):o=e.get(r)[s],o}function n(){e=new WeakMap}return{get:t,dispose:n}}function cv(){const i={};return{get:function(e){if(i[e.id]!==void 0)return i[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new P,color:new Ee};break;case"SpotLight":t={position:new P,direction:new P,color:new Ee,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new P,color:new Ee,distance:0,decay:0};break;case"HemisphereLight":t={direction:new P,skyColor:new Ee,groundColor:new Ee};break;case"RectAreaLight":t={color:new Ee,position:new P,halfWidth:new P,halfHeight:new P};break}return i[e.id]=t,t}}}function uv(){const i={};return{get:function(e){if(i[e.id]!==void 0)return i[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[e.id]=t,t}}}let hv=0;function fv(i,e){return(e.castShadow?1:0)-(i.castShadow?1:0)}function dv(i,e){const t=new cv,n=uv(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let c=0;c<9;c++)r.probe.push(new P);const s=new P,o=new Re,a=new Re;function u(c,l){let f=0,d=0,v=0;for(let D=0;D<9;D++)r.probe[D].set(0,0,0);let m=0,y=0,p=0,g=0,_=0,x=0,M=0,S=0;c.sort(fv);const w=l!==!0?Math.PI:1;for(let D=0,I=c.length;D<I;D++){const T=c[D],B=T.color,O=T.intensity,F=T.distance,z=T.shadow&&T.shadow.map?T.shadow.map.texture:null;if(T.isAmbientLight)f+=B.r*O*w,d+=B.g*O*w,v+=B.b*O*w;else if(T.isLightProbe)for(let N=0;N<9;N++)r.probe[N].addScaledVector(T.sh.coefficients[N],O);else if(T.isDirectionalLight){const N=t.get(T);if(N.color.copy(T.color).multiplyScalar(T.intensity*w),T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,r.directionalShadow[m]=Y,r.directionalShadowMap[m]=z,r.directionalShadowMatrix[m]=T.shadow.matrix,x++}r.directional[m]=N,m++}else if(T.isSpotLight){const N=t.get(T);if(N.position.setFromMatrixPosition(T.matrixWorld),N.color.copy(B).multiplyScalar(O*w),N.distance=F,N.coneCos=Math.cos(T.angle),N.penumbraCos=Math.cos(T.angle*(1-T.penumbra)),N.decay=T.decay,T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,r.spotShadow[p]=Y,r.spotShadowMap[p]=z,r.spotShadowMatrix[p]=T.shadow.matrix,S++}r.spot[p]=N,p++}else if(T.isRectAreaLight){const N=t.get(T);N.color.copy(B).multiplyScalar(O),N.halfWidth.set(T.width*.5,0,0),N.halfHeight.set(0,T.height*.5,0),r.rectArea[g]=N,g++}else if(T.isPointLight){const N=t.get(T);if(N.color.copy(T.color).multiplyScalar(T.intensity*w),N.distance=T.distance,N.decay=T.decay,T.castShadow){const U=T.shadow,Y=n.get(T);Y.shadowBias=U.bias,Y.shadowNormalBias=U.normalBias,Y.shadowRadius=U.radius,Y.shadowMapSize=U.mapSize,Y.shadowCameraNear=U.camera.near,Y.shadowCameraFar=U.camera.far,r.pointShadow[y]=Y,r.pointShadowMap[y]=z,r.pointShadowMatrix[y]=T.shadow.matrix,M++}r.point[y]=N,y++}else if(T.isHemisphereLight){const N=t.get(T);N.skyColor.copy(T.color).multiplyScalar(O*w),N.groundColor.copy(T.groundColor).multiplyScalar(O*w),r.hemi[_]=N,_++}}g>0&&(e.isWebGL2||i.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=ge.LTC_FLOAT_1,r.rectAreaLTC2=ge.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=ge.LTC_HALF_1,r.rectAreaLTC2=ge.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=f,r.ambient[1]=d,r.ambient[2]=v;const C=r.hash;(C.directionalLength!==m||C.pointLength!==y||C.spotLength!==p||C.rectAreaLength!==g||C.hemiLength!==_||C.numDirectionalShadows!==x||C.numPointShadows!==M||C.numSpotShadows!==S)&&(r.directional.length=m,r.spot.length=p,r.rectArea.length=g,r.point.length=y,r.hemi.length=_,r.directionalShadow.length=x,r.directionalShadowMap.length=x,r.pointShadow.length=M,r.pointShadowMap.length=M,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=x,r.pointShadowMatrix.length=M,r.spotShadowMatrix.length=S,C.directionalLength=m,C.pointLength=y,C.spotLength=p,C.rectAreaLength=g,C.hemiLength=_,C.numDirectionalShadows=x,C.numPointShadows=M,C.numSpotShadows=S,r.version=hv++)}function h(c,l){let f=0,d=0,v=0,m=0,y=0;const p=l.matrixWorldInverse;for(let g=0,_=c.length;g<_;g++){const x=c[g];if(x.isDirectionalLight){const M=r.directional[f];M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(p),f++}else if(x.isSpotLight){const M=r.spot[v];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),M.direction.setFromMatrixPosition(x.matrixWorld),s.setFromMatrixPosition(x.target.matrixWorld),M.direction.sub(s),M.direction.transformDirection(p),v++}else if(x.isRectAreaLight){const M=r.rectArea[m];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),a.identity(),o.copy(x.matrixWorld),o.premultiply(p),a.extractRotation(o),M.halfWidth.set(x.width*.5,0,0),M.halfHeight.set(0,x.height*.5,0),M.halfWidth.applyMatrix4(a),M.halfHeight.applyMatrix4(a),m++}else if(x.isPointLight){const M=r.point[d];M.position.setFromMatrixPosition(x.matrixWorld),M.position.applyMatrix4(p),d++}else if(x.isHemisphereLight){const M=r.hemi[y];M.direction.setFromMatrixPosition(x.matrixWorld),M.direction.transformDirection(p),M.direction.normalize(),y++}}}return{setup:u,setupView:h,state:r}}function Bl(i,e){const t=new dv(i,e),n=[],r=[];function s(){n.length=0,r.length=0}function o(l){n.push(l)}function a(l){r.push(l)}function u(l){t.setup(n,l)}function h(l){t.setupView(n,l)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:t},setupLights:u,setupLightsView:h,pushLight:o,pushShadow:a}}function pv(i,e){let t=new WeakMap;function n(s,o=0){let a;return t.has(s)===!1?(a=new Bl(i,e),t.set(s,[a])):o>=t.get(s).length?(a=new Bl(i,e),t.get(s).push(a)):a=t.get(s)[o],a}function r(){t=new WeakMap}return{get:n,dispose:r}}class Yc extends Mt{constructor(e){super();this.type="MeshDepthMaterial",this.depthPacking=Of,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Yc.prototype.isMeshDepthMaterial=!0;class jc extends Mt{constructor(e){super();this.type="MeshDistanceMaterial",this.referencePosition=new P,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}jc.prototype.isMeshDistanceMaterial=!0;const mv=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,gv=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Jc(i,e,t){let n=new Rs;const r=new le,s=new le,o=new We,a=new Yc({depthPacking:Bf}),u=new jc,h={},c=t.maxTextureSize,l={0:at,1:hr,2:Li},f=new jn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new le},radius:{value:4}},vertexShader:mv,fragmentShader:gv}),d=f.clone();d.defines.HORIZONTAL_PASS=1;const v=new Ye;v.setAttribute("position",new ct(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new Lt(v,f),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Mc,this.render=function(x,M,S){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||x.length===0)return;const w=i.getRenderTarget(),C=i.getActiveCubeFace(),D=i.getActiveMipmapLevel(),I=i.state;I.setBlending(Cn),I.buffers.color.setClear(1,1,1,1),I.buffers.depth.setTest(!0),I.setScissorTest(!1);for(let T=0,B=x.length;T<B;T++){const O=x[T],F=O.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",O,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;r.copy(F.mapSize);const z=F.getFrameExtents();if(r.multiply(z),s.copy(F.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(s.x=Math.floor(c/z.x),r.x=s.x*z.x,F.mapSize.x=s.x),r.y>c&&(s.y=Math.floor(c/z.y),r.y=s.y*z.y,F.mapSize.y=s.y)),F.map===null&&!F.isPointLightShadow&&this.type===rr){const U={minFilter:Ht,magFilter:Ht,format:St};F.map=new Vt(r.x,r.y,U),F.map.texture.name=O.name+".shadowMap",F.mapPass=new Vt(r.x,r.y,U),F.camera.updateProjectionMatrix()}if(F.map===null){const U={minFilter:ht,magFilter:ht,format:St};F.map=new Vt(r.x,r.y,U),F.map.texture.name=O.name+".shadowMap",F.camera.updateProjectionMatrix()}i.setRenderTarget(F.map),i.clear();const N=F.getViewportCount();for(let U=0;U<N;U++){const Y=F.getViewport(U);o.set(s.x*Y.x,s.y*Y.y,s.x*Y.z,s.y*Y.w),I.viewport(o),F.updateMatrices(O,U),n=F.getFrustum(),_(M,S,F.camera,O,this.type)}!F.isPointLightShadow&&this.type===rr&&p(F,S),F.needsUpdate=!1}y.needsUpdate=!1,i.setRenderTarget(w,C,D)};function p(x,M){const S=e.update(m);f.defines.VSM_SAMPLES!==x.blurSamples&&(f.defines.VSM_SAMPLES=x.blurSamples,d.defines.VSM_SAMPLES=x.blurSamples,f.needsUpdate=!0,d.needsUpdate=!0),f.uniforms.shadow_pass.value=x.map.texture,f.uniforms.resolution.value=x.mapSize,f.uniforms.radius.value=x.radius,i.setRenderTarget(x.mapPass),i.clear(),i.renderBufferDirect(M,null,S,f,m,null),d.uniforms.shadow_pass.value=x.mapPass.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,i.setRenderTarget(x.map),i.clear(),i.renderBufferDirect(M,null,S,d,m,null)}function g(x,M,S,w,C,D,I){let T=null;const B=w.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(B!==void 0?T=B:T=w.isPointLight===!0?u:a,i.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const O=T.uuid,F=S.uuid;let z=h[O];z===void 0&&(z={},h[O]=z);let N=z[F];N===void 0&&(N=T.clone(),z[F]=N),T=N}return T.visible=S.visible,T.wireframe=S.wireframe,I===rr?T.side=S.shadowSide!==null?S.shadowSide:S.side:T.side=S.shadowSide!==null?S.shadowSide:l[S.side],T.alphaMap=S.alphaMap,T.alphaTest=S.alphaTest,T.clipShadows=S.clipShadows,T.clippingPlanes=S.clippingPlanes,T.clipIntersection=S.clipIntersection,T.displacementMap=S.displacementMap,T.displacementScale=S.displacementScale,T.displacementBias=S.displacementBias,T.wireframeLinewidth=S.wireframeLinewidth,T.linewidth=S.linewidth,w.isPointLight===!0&&T.isMeshDistanceMaterial===!0&&(T.referencePosition.setFromMatrixPosition(w.matrixWorld),T.nearDistance=C,T.farDistance=D),T}function _(x,M,S,w,C){if(x.visible===!1)return;if(x.layers.test(M.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&C===rr)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse,x.matrixWorld);const T=e.update(x),B=x.material;if(Array.isArray(B)){const O=T.groups;for(let F=0,z=O.length;F<z;F++){const N=O[F],U=B[N.materialIndex];if(U&&U.visible){const Y=g(x,T,U,w,S.near,S.far,C);i.renderBufferDirect(S,null,T,Y,x,N)}}}else if(B.visible){const O=g(x,T,B,w,S.near,S.far,C);i.renderBufferDirect(S,null,T,O,x,null)}}const I=x.children;for(let T=0,B=I.length;T<B;T++)_(I[T],M,S,w,C)}}function vv(i,e,t){const n=t.isWebGL2;function r(){let L=!1;const $=new We;let te=null;const ue=new We(0,0,0,0);return{setMask:function(ce){te!==ce&&!L&&(i.colorMask(ce,ce,ce,ce),te=ce)},setLocked:function(ce){L=ce},setClear:function(ce,ye,we,Fe,Je){Je===!0&&(ce*=Fe,ye*=Fe,we*=Fe),$.set(ce,ye,we,Fe),ue.equals($)===!1&&(i.clearColor(ce,ye,we,Fe),ue.copy($))},reset:function(){L=!1,te=null,ue.set(-1,0,0,0)}}}function s(){let L=!1,$=null,te=null,ue=null;return{setTest:function(ce){ce?se(2929):de(2929)},setMask:function(ce){$!==ce&&!L&&(i.depthMask(ce),$=ce)},setFunc:function(ce){if(te!==ce){if(ce)switch(ce){case Eh:i.depthFunc(512);break;case Th:i.depthFunc(519);break;case Ah:i.depthFunc(513);break;case Bo:i.depthFunc(515);break;case Ch:i.depthFunc(514);break;case Lh:i.depthFunc(518);break;case Rh:i.depthFunc(516);break;case Ph:i.depthFunc(517);break;default:i.depthFunc(515)}else i.depthFunc(515);te=ce}},setLocked:function(ce){L=ce},setClear:function(ce){ue!==ce&&(i.clearDepth(ce),ue=ce)},reset:function(){L=!1,$=null,te=null,ue=null}}}function o(){let L=!1,$=null,te=null,ue=null,ce=null,ye=null,we=null,Fe=null,Je=null;return{setTest:function(Ue){L||(Ue?se(2960):de(2960))},setMask:function(Ue){$!==Ue&&!L&&(i.stencilMask(Ue),$=Ue)},setFunc:function(Ue,Dt,It){(te!==Ue||ue!==Dt||ce!==It)&&(i.stencilFunc(Ue,Dt,It),te=Ue,ue=Dt,ce=It)},setOp:function(Ue,Dt,It){(ye!==Ue||we!==Dt||Fe!==It)&&(i.stencilOp(Ue,Dt,It),ye=Ue,we=Dt,Fe=It)},setLocked:function(Ue){L=Ue},setClear:function(Ue){Je!==Ue&&(i.clearStencil(Ue),Je=Ue)},reset:function(){L=!1,$=null,te=null,ue=null,ce=null,ye=null,we=null,Fe=null,Je=null}}}const a=new r,u=new s,h=new o;let c={},l={},f=null,d=!1,v=null,m=null,y=null,p=null,g=null,_=null,x=null,M=!1,S=null,w=null,C=null,D=null,I=null;const T=i.getParameter(35661);let B=!1,O=0;const F=i.getParameter(7938);F.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(F)[1]),B=O>=1):F.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),B=O>=2);let z=null,N={};const U=i.getParameter(3088),Y=i.getParameter(2978),ee=new We().fromArray(U),k=new We().fromArray(Y);function q(L,$,te){const ue=new Uint8Array(4),ce=i.createTexture();i.bindTexture(L,ce),i.texParameteri(L,10241,9728),i.texParameteri(L,10240,9728);for(let ye=0;ye<te;ye++)i.texImage2D($+ye,0,6408,1,1,0,6408,5121,ue);return ce}const ae={};ae[3553]=q(3553,3553,1),ae[34067]=q(34067,34069,6),a.setClear(0,0,0,1),u.setClear(1),h.setClear(0),se(2929),u.setFunc(Bo),Pe(!1),Z(Ua),se(2884),fe(Cn);function se(L){c[L]!==!0&&(i.enable(L),c[L]=!0)}function de(L){c[L]!==!1&&(i.disable(L),c[L]=!1)}function Se(L,$){return l[L]!==$?(i.bindFramebuffer(L,$),l[L]=$,n&&(L===36009&&(l[36160]=$),L===36160&&(l[36009]=$)),!0):!1}function Q(L){return f!==L?(i.useProgram(L),f=L,!0):!1}const ve={[xi]:32774,[ph]:32778,[mh]:32779};if(n)ve[ka]=32775,ve[Wa]=32776;else{const L=e.get("EXT_blend_minmax");L!==null&&(ve[ka]=L.MIN_EXT,ve[Wa]=L.MAX_EXT)}const xe={[gh]:0,[vh]:1,[yh]:768,[Sc]:770,[Sh]:776,[Mh]:774,[xh]:772,[_h]:769,[Ec]:771,[bh]:775,[wh]:773};function fe(L,$,te,ue,ce,ye,we,Fe){if(L===Cn){d===!0&&(de(3042),d=!1);return}if(d===!1&&(se(3042),d=!0),L!==dh){if(L!==v||Fe!==M){if((m!==xi||g!==xi)&&(i.blendEquation(32774),m=xi,g=xi),Fe)switch(L){case ar:i.blendFuncSeparate(1,771,1,771);break;case Ha:i.blendFunc(1,1);break;case Va:i.blendFuncSeparate(0,0,769,771);break;case Ga:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",L);break}else switch(L){case ar:i.blendFuncSeparate(770,771,1,771);break;case Ha:i.blendFunc(770,1);break;case Va:i.blendFunc(0,769);break;case Ga:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",L);break}y=null,p=null,_=null,x=null,v=L,M=Fe}return}ce=ce||$,ye=ye||te,we=we||ue,($!==m||ce!==g)&&(i.blendEquationSeparate(ve[$],ve[ce]),m=$,g=ce),(te!==y||ue!==p||ye!==_||we!==x)&&(i.blendFuncSeparate(xe[te],xe[ue],xe[ye],xe[we]),y=te,p=ue,_=ye,x=we),v=L,M=null}function pe(L,$){L.side===Li?de(2884):se(2884);let te=L.side===at;$&&(te=!te),Pe(te),L.blending===ar&&L.transparent===!1?fe(Cn):fe(L.blending,L.blendEquation,L.blendSrc,L.blendDst,L.blendEquationAlpha,L.blendSrcAlpha,L.blendDstAlpha,L.premultipliedAlpha),u.setFunc(L.depthFunc),u.setTest(L.depthTest),u.setMask(L.depthWrite),a.setMask(L.colorWrite);const ue=L.stencilWrite;h.setTest(ue),ue&&(h.setMask(L.stencilWriteMask),h.setFunc(L.stencilFunc,L.stencilRef,L.stencilFuncMask),h.setOp(L.stencilFail,L.stencilZFail,L.stencilZPass)),oe(L.polygonOffset,L.polygonOffsetFactor,L.polygonOffsetUnits),L.alphaToCoverage===!0?se(32926):de(32926)}function Pe(L){S!==L&&(L?i.frontFace(2304):i.frontFace(2305),S=L)}function Z(L){L!==uh?(se(2884),L!==w&&(L===Ua?i.cullFace(1029):L===hh?i.cullFace(1028):i.cullFace(1032))):de(2884),w=L}function K(L){L!==C&&(B&&i.lineWidth(L),C=L)}function oe(L,$,te){L?(se(32823),(D!==$||I!==te)&&(i.polygonOffset($,te),D=$,I=te)):de(32823)}function me(L){L?se(3089):de(3089)}function he(L){L===void 0&&(L=33984+T-1),z!==L&&(i.activeTexture(L),z=L)}function Te(L,$){z===null&&he();let te=N[z];te===void 0&&(te={type:void 0,texture:void 0},N[z]=te),(te.type!==L||te.texture!==$)&&(i.bindTexture(L,$||ae[L]),te.type=L,te.texture=$)}function Le(){const L=N[z];L!==void 0&&L.type!==void 0&&(i.bindTexture(L.type,null),L.type=void 0,L.texture=void 0)}function R(){try{i.compressedTexImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function V(){try{i.texSubImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function E(){try{i.texStorage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function b(){try{i.texImage2D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function H(){try{i.texImage3D.apply(i,arguments)}catch(L){console.error("THREE.WebGLState:",L)}}function G(L){ee.equals(L)===!1&&(i.scissor(L.x,L.y,L.z,L.w),ee.copy(L))}function ie(L){k.equals(L)===!1&&(i.viewport(L.x,L.y,L.z,L.w),k.copy(L))}function J(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),n===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),c={},z=null,N={},l={},f=null,d=!1,v=null,m=null,y=null,p=null,g=null,_=null,x=null,M=!1,S=null,w=null,C=null,D=null,I=null,ee.set(0,0,i.canvas.width,i.canvas.height),k.set(0,0,i.canvas.width,i.canvas.height),a.reset(),u.reset(),h.reset()}return{buffers:{color:a,depth:u,stencil:h},enable:se,disable:de,bindFramebuffer:Se,useProgram:Q,setBlending:fe,setMaterial:pe,setFlipSided:Pe,setCullFace:Z,setLineWidth:K,setPolygonOffset:oe,setScissorTest:me,activeTexture:he,bindTexture:Te,unbindTexture:Le,compressedTexImage2D:R,texImage2D:b,texImage3D:H,texStorage2D:E,texSubImage2D:V,scissor:G,viewport:ie,reset:J}}function yv(i,e,t,n,r,s,o){const a=r.isWebGL2,u=r.maxTextures,h=r.maxCubemapSize,c=r.maxTextureSize,l=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,v=new WeakMap;let m,y=!1;try{y=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(E,b){return y?new OffscreenCanvas(E,b):Cs("canvas")}function g(E,b,H,G){let ie=1;if((E.width>G||E.height>G)&&(ie=G/Math.max(E.width,E.height)),ie<1||b===!0)if(typeof HTMLImageElement!="undefined"&&E instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&E instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&E instanceof ImageBitmap){const J=b?Gf:Math.floor,L=J(ie*E.width),$=J(ie*E.height);m===void 0&&(m=p(L,$));const te=H?p(L,$):m;return te.width=L,te.height=$,te.getContext("2d").drawImage(E,0,0,L,$),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+E.width+"x"+E.height+") to ("+L+"x"+$+")."),te}else return"data"in E&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+E.width+"x"+E.height+")."),E;return E}function _(E){return rl(E.width)&&rl(E.height)}function x(E){return a?!1:E.wrapS!==Bt||E.wrapT!==Bt||E.minFilter!==ht&&E.minFilter!==Ht}function M(E,b){return E.generateMipmaps&&b&&E.minFilter!==ht&&E.minFilter!==Ht}function S(E){i.generateMipmap(E)}function w(E,b,H){if(a===!1)return b;if(E!==null){if(i[E]!==void 0)return i[E];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+E+"'")}let G=b;return b===6403&&(H===5126&&(G=33326),H===5131&&(G=33325),H===5121&&(G=33321)),b===6407&&(H===5126&&(G=34837),H===5131&&(G=34843),H===5121&&(G=32849)),b===6408&&(H===5126&&(G=34836),H===5131&&(G=34842),H===5121&&(G=32856)),(G===33325||G===33326||G===34842||G===34836)&&e.get("EXT_color_buffer_float"),G}function C(E,b,H){return M(E,H)===!0?Math.log2(Math.max(b.width,b.height))+1:E.mipmaps.length>0?E.mipmaps.length:1}function D(E){return E===ht||E===qa||E===Xa?9728:9729}function I(E){const b=E.target;b.removeEventListener("dispose",I),B(b),b.isVideoTexture&&v.delete(b),o.memory.textures--}function T(E){const b=E.target;b.removeEventListener("dispose",T),O(b)}function B(E){const b=n.get(E);b.__webglInit!==void 0&&(i.deleteTexture(b.__webglTexture),n.remove(E))}function O(E){const b=E.texture,H=n.get(E),G=n.get(b);if(!!E){if(G.__webglTexture!==void 0&&(i.deleteTexture(G.__webglTexture),o.memory.textures--),E.depthTexture&&E.depthTexture.dispose(),E.isWebGLCubeRenderTarget)for(let ie=0;ie<6;ie++)i.deleteFramebuffer(H.__webglFramebuffer[ie]),H.__webglDepthbuffer&&i.deleteRenderbuffer(H.__webglDepthbuffer[ie]);else i.deleteFramebuffer(H.__webglFramebuffer),H.__webglDepthbuffer&&i.deleteRenderbuffer(H.__webglDepthbuffer),H.__webglMultisampledFramebuffer&&i.deleteFramebuffer(H.__webglMultisampledFramebuffer),H.__webglColorRenderbuffer&&i.deleteRenderbuffer(H.__webglColorRenderbuffer),H.__webglDepthRenderbuffer&&i.deleteRenderbuffer(H.__webglDepthRenderbuffer);if(E.isWebGLMultipleRenderTargets)for(let ie=0,J=b.length;ie<J;ie++){const L=n.get(b[ie]);L.__webglTexture&&(i.deleteTexture(L.__webglTexture),o.memory.textures--),n.remove(b[ie])}n.remove(b),n.remove(E)}}let F=0;function z(){F=0}function N(){const E=F;return E>=u&&console.warn("THREE.WebGLTextures: Trying to use "+E+" texture units while this GPU supports only "+u),F+=1,E}function U(E,b){const H=n.get(E);if(E.isVideoTexture&&he(E),E.version>0&&H.__version!==E.version){const G=E.image;if(G===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(G.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Se(H,E,b);return}}t.activeTexture(33984+b),t.bindTexture(3553,H.__webglTexture)}function Y(E,b){const H=n.get(E);if(E.version>0&&H.__version!==E.version){Se(H,E,b);return}t.activeTexture(33984+b),t.bindTexture(35866,H.__webglTexture)}function ee(E,b){const H=n.get(E);if(E.version>0&&H.__version!==E.version){Se(H,E,b);return}t.activeTexture(33984+b),t.bindTexture(32879,H.__webglTexture)}function k(E,b){const H=n.get(E);if(E.version>0&&H.__version!==E.version){Q(H,E,b);return}t.activeTexture(33984+b),t.bindTexture(34067,H.__webglTexture)}const q={[Vo]:10497,[Bt]:33071,[Go]:33648},ae={[ht]:9728,[qa]:9984,[Xa]:9986,[Ht]:9729,[Uh]:9985,[Ts]:9987};function se(E,b,H){if(H?(i.texParameteri(E,10242,q[b.wrapS]),i.texParameteri(E,10243,q[b.wrapT]),(E===32879||E===35866)&&i.texParameteri(E,32882,q[b.wrapR]),i.texParameteri(E,10240,ae[b.magFilter]),i.texParameteri(E,10241,ae[b.minFilter])):(i.texParameteri(E,10242,33071),i.texParameteri(E,10243,33071),(E===32879||E===35866)&&i.texParameteri(E,32882,33071),(b.wrapS!==Bt||b.wrapT!==Bt)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(E,10240,D(b.magFilter)),i.texParameteri(E,10241,D(b.minFilter)),b.minFilter!==ht&&b.minFilter!==Ht&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const G=e.get("EXT_texture_filter_anisotropic");if(b.type===Tn&&e.has("OES_texture_float_linear")===!1||a===!1&&b.type===Ei&&e.has("OES_texture_half_float_linear")===!1)return;(b.anisotropy>1||n.get(b).__currentAnisotropy)&&(i.texParameterf(E,G.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,r.getMaxAnisotropy())),n.get(b).__currentAnisotropy=b.anisotropy)}}function de(E,b){E.__webglInit===void 0&&(E.__webglInit=!0,b.addEventListener("dispose",I),E.__webglTexture=i.createTexture(),o.memory.textures++)}function Se(E,b,H){let G=3553;b.isDataTexture2DArray&&(G=35866),b.isDataTexture3D&&(G=32879),de(E,b),t.activeTexture(33984+H),t.bindTexture(G,E.__webglTexture),i.pixelStorei(37440,b.flipY),i.pixelStorei(37441,b.premultiplyAlpha),i.pixelStorei(3317,b.unpackAlignment),i.pixelStorei(37443,0);const ie=x(b)&&_(b.image)===!1,J=g(b.image,ie,!1,c),L=_(J)||a,$=s.convert(b.format);let te=s.convert(b.type),ue=w(b.internalFormat,$,te,b.encoding);se(G,b,L);let ce;const ye=b.mipmaps;if(b.isDepthTexture)ue=6402,a?b.type===Tn?ue=36012:b.type===cs?ue=33190:b.type===Ti?ue=35056:ue=33189:b.type===Tn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),b.format===Yn&&ue===6402&&b.type!==fr&&b.type!==cs&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),b.type=fr,te=s.convert(b.type)),b.format===Ri&&ue===6402&&(ue=34041,b.type!==Ti&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),b.type=Ti,te=s.convert(b.type))),t.texImage2D(3553,0,ue,J.width,J.height,0,$,te,null);else if(b.isDataTexture)if(ye.length>0&&L){for(let we=0,Fe=ye.length;we<Fe;we++)ce=ye[we],t.texImage2D(3553,we,ue,ce.width,ce.height,0,$,te,ce.data);b.generateMipmaps=!1}else t.texImage2D(3553,0,ue,J.width,J.height,0,$,te,J.data);else if(b.isCompressedTexture)for(let we=0,Fe=ye.length;we<Fe;we++)ce=ye[we],b.format!==St&&b.format!==Zn?$!==null?t.compressedTexImage2D(3553,we,ue,ce.width,ce.height,0,ce.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,we,ue,ce.width,ce.height,0,$,te,ce.data);else if(b.isDataTexture2DArray)t.texImage3D(35866,0,ue,J.width,J.height,J.depth,0,$,te,J.data);else if(b.isDataTexture3D)t.texImage3D(32879,0,ue,J.width,J.height,J.depth,0,$,te,J.data);else{const we=C(b,J,L),Fe=a&&b.isVideoTexture!==!0,Je=E.__version===void 0;if(ye.length>0&&L){Fe&&Je&&t.texStorage2D(3553,we,ue,ye[0].width,ye[0].height);for(let Ue=0,Dt=ye.length;Ue<Dt;Ue++)ce=ye[Ue],Fe?t.texSubImage2D(3553,Ue,0,0,$,te,ce):t.texImage2D(3553,Ue,ue,$,te,ce);b.generateMipmaps=!1}else Fe?(Je&&t.texStorage2D(3553,we,ue,J.width,J.height),t.texSubImage2D(3553,0,0,0,$,te,J)):t.texImage2D(3553,0,ue,$,te,J)}M(b,L)&&S(G),E.__version=b.version,b.onUpdate&&b.onUpdate(b)}function Q(E,b,H){if(b.image.length!==6)return;de(E,b),t.activeTexture(33984+H),t.bindTexture(34067,E.__webglTexture),i.pixelStorei(37440,b.flipY),i.pixelStorei(37441,b.premultiplyAlpha),i.pixelStorei(3317,b.unpackAlignment),i.pixelStorei(37443,0);const G=b&&(b.isCompressedTexture||b.image[0].isCompressedTexture),ie=b.image[0]&&b.image[0].isDataTexture,J=[];for(let we=0;we<6;we++)!G&&!ie?J[we]=g(b.image[we],!1,!0,h):J[we]=ie?b.image[we].image:b.image[we];const L=J[0],$=_(L)||a,te=s.convert(b.format),ue=s.convert(b.type),ce=w(b.internalFormat,te,ue,b.encoding);se(34067,b,$);let ye;if(G)for(let we=0;we<6;we++){ye=J[we].mipmaps;for(let Fe=0;Fe<ye.length;Fe++){const Je=ye[Fe];b.format!==St&&b.format!==Zn?te!==null?t.compressedTexImage2D(34069+we,Fe,ce,Je.width,Je.height,0,Je.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+we,Fe,ce,Je.width,Je.height,0,te,ue,Je.data)}}else{ye=b.mipmaps;for(let we=0;we<6;we++)if(ie){t.texImage2D(34069+we,0,ce,J[we].width,J[we].height,0,te,ue,J[we].data);for(let Fe=0;Fe<ye.length;Fe++){const Ue=ye[Fe].image[we].image;t.texImage2D(34069+we,Fe+1,ce,Ue.width,Ue.height,0,te,ue,Ue.data)}}else{t.texImage2D(34069+we,0,ce,te,ue,J[we]);for(let Fe=0;Fe<ye.length;Fe++){const Je=ye[Fe];t.texImage2D(34069+we,Fe+1,ce,te,ue,Je.image[we])}}}M(b,$)&&S(34067),E.__version=b.version,b.onUpdate&&b.onUpdate(b)}function ve(E,b,H,G,ie){const J=s.convert(H.format),L=s.convert(H.type),$=w(H.internalFormat,J,L,H.encoding);n.get(b).__hasExternalTextures||(ie===32879||ie===35866?t.texImage3D(ie,0,$,b.width,b.height,b.depth,0,J,L,null):t.texImage2D(ie,0,$,b.width,b.height,0,J,L,null)),t.bindFramebuffer(36160,E),b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,G,ie,n.get(H).__webglTexture,0,me(b)):i.framebufferTexture2D(36160,G,ie,n.get(H).__webglTexture,0),t.bindFramebuffer(36160,null)}function xe(E,b,H){if(i.bindRenderbuffer(36161,E),b.depthBuffer&&!b.stencilBuffer){let G=33189;if(H||b.useRenderToTexture){const ie=b.depthTexture;ie&&ie.isDepthTexture&&(ie.type===Tn?G=36012:ie.type===cs&&(G=33190));const J=me(b);b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,J,G,b.width,b.height):i.renderbufferStorageMultisample(36161,J,G,b.width,b.height)}else i.renderbufferStorage(36161,G,b.width,b.height);i.framebufferRenderbuffer(36160,36096,36161,E)}else if(b.depthBuffer&&b.stencilBuffer){const G=me(b);H&&b.useRenderbuffer?i.renderbufferStorageMultisample(36161,G,35056,b.width,b.height):b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,G,35056,b.width,b.height):i.renderbufferStorage(36161,34041,b.width,b.height),i.framebufferRenderbuffer(36160,33306,36161,E)}else{const G=b.isWebGLMultipleRenderTargets===!0?b.texture[0]:b.texture,ie=s.convert(G.format),J=s.convert(G.type),L=w(G.internalFormat,ie,J,G.encoding),$=me(b);H&&b.useRenderbuffer?i.renderbufferStorageMultisample(36161,$,L,b.width,b.height):b.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,$,L,b.width,b.height):i.renderbufferStorage(36161,L,b.width,b.height)}i.bindRenderbuffer(36161,null)}function fe(E,b){if(b&&b.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,E),!(b.depthTexture&&b.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(b.depthTexture).__webglTexture||b.depthTexture.image.width!==b.width||b.depthTexture.image.height!==b.height)&&(b.depthTexture.image.width=b.width,b.depthTexture.image.height=b.height,b.depthTexture.needsUpdate=!0),U(b.depthTexture,0);const G=n.get(b.depthTexture).__webglTexture,ie=me(b);if(b.depthTexture.format===Yn)b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,G,0,ie):i.framebufferTexture2D(36160,36096,3553,G,0);else if(b.depthTexture.format===Ri)b.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,G,0,ie):i.framebufferTexture2D(36160,33306,3553,G,0);else throw new Error("Unknown depthTexture format")}function pe(E){const b=n.get(E),H=E.isWebGLCubeRenderTarget===!0;if(E.depthTexture&&!b.__autoAllocateDepthBuffer){if(H)throw new Error("target.depthTexture not supported in Cube render targets");fe(b.__webglFramebuffer,E)}else if(H){b.__webglDepthbuffer=[];for(let G=0;G<6;G++)t.bindFramebuffer(36160,b.__webglFramebuffer[G]),b.__webglDepthbuffer[G]=i.createRenderbuffer(),xe(b.__webglDepthbuffer[G],E,!1)}else t.bindFramebuffer(36160,b.__webglFramebuffer),b.__webglDepthbuffer=i.createRenderbuffer(),xe(b.__webglDepthbuffer,E,!1);t.bindFramebuffer(36160,null)}function Pe(E,b,H){const G=n.get(E);b!==void 0&&ve(G.__webglFramebuffer,E,E.texture,36064,3553),H!==void 0&&pe(E)}function Z(E){const b=E.texture,H=n.get(E),G=n.get(b);E.addEventListener("dispose",T),E.isWebGLMultipleRenderTargets!==!0&&(G.__webglTexture===void 0&&(G.__webglTexture=i.createTexture()),G.__version=b.version,o.memory.textures++);const ie=E.isWebGLCubeRenderTarget===!0,J=E.isWebGLMultipleRenderTargets===!0,L=b.isDataTexture3D||b.isDataTexture2DArray,$=_(E)||a;if(a&&b.format===Zn&&(b.type===Tn||b.type===Ei)&&(b.format=St,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ie){H.__webglFramebuffer=[];for(let te=0;te<6;te++)H.__webglFramebuffer[te]=i.createFramebuffer()}else if(H.__webglFramebuffer=i.createFramebuffer(),J)if(r.drawBuffers){const te=E.texture;for(let ue=0,ce=te.length;ue<ce;ue++){const ye=n.get(te[ue]);ye.__webglTexture===void 0&&(ye.__webglTexture=i.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(E.useRenderbuffer)if(a){H.__webglMultisampledFramebuffer=i.createFramebuffer(),H.__webglColorRenderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(36161,H.__webglColorRenderbuffer);const te=s.convert(b.format),ue=s.convert(b.type),ce=w(b.internalFormat,te,ue,b.encoding),ye=me(E);i.renderbufferStorageMultisample(36161,ye,ce,E.width,E.height),t.bindFramebuffer(36160,H.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064,36161,H.__webglColorRenderbuffer),i.bindRenderbuffer(36161,null),E.depthBuffer&&(H.__webglDepthRenderbuffer=i.createRenderbuffer(),xe(H.__webglDepthRenderbuffer,E,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ie){t.bindTexture(34067,G.__webglTexture),se(34067,b,$);for(let te=0;te<6;te++)ve(H.__webglFramebuffer[te],E,b,36064,34069+te);M(b,$)&&S(34067),t.unbindTexture()}else if(J){const te=E.texture;for(let ue=0,ce=te.length;ue<ce;ue++){const ye=te[ue],we=n.get(ye);t.bindTexture(3553,we.__webglTexture),se(3553,ye,$),ve(H.__webglFramebuffer,E,ye,36064+ue,3553),M(ye,$)&&S(3553)}t.unbindTexture()}else{let te=3553;L&&(a?te=b.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(te,G.__webglTexture),se(te,b,$),ve(H.__webglFramebuffer,E,b,36064,te),M(b,$)&&S(te),t.unbindTexture()}E.depthBuffer&&pe(E)}function K(E){const b=_(E)||a,H=E.isWebGLMultipleRenderTargets===!0?E.texture:[E.texture];for(let G=0,ie=H.length;G<ie;G++){const J=H[G];if(M(J,b)){const L=E.isWebGLCubeRenderTarget?34067:3553,$=n.get(J).__webglTexture;t.bindTexture(L,$),S(L),t.unbindTexture()}}}function oe(E){if(E.useRenderbuffer)if(a){const b=E.width,H=E.height;let G=16384;const ie=[36064],J=E.stencilBuffer?33306:36096;E.depthBuffer&&ie.push(J),E.ignoreDepthForMultisampleCopy||(E.depthBuffer&&(G|=256),E.stencilBuffer&&(G|=1024));const L=n.get(E);t.bindFramebuffer(36008,L.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,L.__webglFramebuffer),E.ignoreDepthForMultisampleCopy&&(i.invalidateFramebuffer(36008,[J]),i.invalidateFramebuffer(36009,[J])),i.blitFramebuffer(0,0,b,H,0,0,b,H,G,9728),i.invalidateFramebuffer(36008,ie),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,L.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function me(E){return a&&(E.useRenderbuffer||E.useRenderToTexture)?Math.min(l,E.samples):0}function he(E){const b=o.render.frame;v.get(E)!==b&&(v.set(E,b),E.update())}let Te=!1,Le=!1;function R(E,b){E&&E.isWebGLRenderTarget&&(Te===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Te=!0),E=E.texture),U(E,b)}function V(E,b){E&&E.isWebGLCubeRenderTarget&&(Le===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Le=!0),E=E.texture),k(E,b)}this.allocateTextureUnit=N,this.resetTextureUnits=z,this.setTexture2D=U,this.setTexture2DArray=Y,this.setTexture3D=ee,this.setTextureCube=k,this.rebindTextures=Pe,this.setupRenderTarget=Z,this.updateRenderTargetMipmap=K,this.updateMultisampleRenderTarget=oe,this.setupDepthRenderbuffer=pe,this.setupFrameBufferTexture=ve,this.safeSetTexture2D=R,this.safeSetTextureCube=V}function _v(i,e,t){const n=t.isWebGL2;function r(s){let o;if(s===Nn)return 5121;if(s===kh)return 32819;if(s===Wh)return 32820;if(s===qh)return 33635;if(s===Hh)return 5120;if(s===Vh)return 5122;if(s===fr)return 5123;if(s===Gh)return 5124;if(s===cs)return 5125;if(s===Tn)return 5126;if(s===Ei)return n?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===Xh)return 6406;if(s===Zn)return 6407;if(s===St)return 6408;if(s===Zh)return 6409;if(s===Yh)return 6410;if(s===Yn)return 6402;if(s===Ri)return 34041;if(s===Jh)return 6403;if(s===$h)return 36244;if(s===Qh)return 33319;if(s===Kh)return 33320;if(s===ef)return 36248;if(s===tf)return 36249;if(s===Za||s===Ya||s===ja||s===Ja)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===Za)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Ya)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===ja)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Ja)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===$a||s===Qa||s===Ka||s===el)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===$a)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Qa)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Ka)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===el)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===nf)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===tl||s===nl)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(s===tl)return o.COMPRESSED_RGB8_ETC2;if(s===nl)return o.COMPRESSED_RGBA8_ETC2_EAC}if(s===rf||s===sf||s===of||s===af||s===lf||s===cf||s===uf||s===hf||s===ff||s===df||s===pf||s===mf||s===gf||s===vf||s===_f||s===xf||s===wf||s===Mf||s===bf||s===Sf||s===Ef||s===Tf||s===Af||s===Cf||s===Lf||s===Rf||s===Pf||s===Nf)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?s:null;if(s===yf)return o=e.get("EXT_texture_compression_bptc"),o!==null?s:null;if(s===Ti)return n?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class $c extends Ct{constructor(e=[]){super();this.cameras=e}}$c.prototype.isArrayCamera=!0;class or extends Ge{constructor(){super();this.type="Group"}}or.prototype.isGroup=!0;const xv={type:"move"};class To{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new or,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new or,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new P,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new P),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new or,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new P,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new P),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let r=null,s=null,o=null;const a=this._targetRay,u=this._grip,h=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(r=t.getPose(e.targetRaySpace,n),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(xv))),h&&e.hand){o=!0;for(const m of e.hand.values()){const y=t.getJointPose(m,n);if(h.joints[m.jointName]===void 0){const g=new or;g.matrixAutoUpdate=!1,g.visible=!1,h.joints[m.jointName]=g,h.add(g)}const p=h.joints[m.jointName];y!==null&&(p.matrix.fromArray(y.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),p.jointRadius=y.radius),p.visible=y!==null}const c=h.joints["index-finger-tip"],l=h.joints["thumb-tip"],f=c.position.distanceTo(l.position),d=.02,v=.005;h.inputState.pinching&&f>d+v?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!h.inputState.pinching&&f<=d-v&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else u!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));return a!==null&&(a.visible=r!==null),u!==null&&(u.visible=s!==null),h!==null&&(h.visible=o!==null),this}}class qo extends yt{constructor(e,t,n,r,s,o,a,u,h,c){if(c=c!==void 0?c:Yn,c!==Yn&&c!==Ri)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&c===Yn&&(n=fr),n===void 0&&c===Ri&&(n=Ti);super(null,r,s,o,a,u,c,n,h);this.image={width:e,height:t},this.magFilter=a!==void 0?a:ht,this.minFilter=u!==void 0?u:ht,this.flipY=!1,this.generateMipmaps=!1}}qo.prototype.isDepthTexture=!0;class wv extends Qn{constructor(e,t){super();const n=this;let r=null,s=1,o=null,a="local-floor";const u=e.extensions.has("WEBGL_multisampled_render_to_texture");let h=null,c=null,l=null,f=null,d=!1,v=null;const m=t.getContextAttributes();let y=null,p=null;const g=[],_=new Map,x=new Ct;x.layers.enable(1),x.viewport=new We;const M=new Ct;M.layers.enable(2),M.viewport=new We;const S=[x,M],w=new $c;w.layers.enable(1),w.layers.enable(2);let C=null,D=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(k){let q=g[k];return q===void 0&&(q=new To,g[k]=q),q.getTargetRaySpace()},this.getControllerGrip=function(k){let q=g[k];return q===void 0&&(q=new To,g[k]=q),q.getGripSpace()},this.getHand=function(k){let q=g[k];return q===void 0&&(q=new To,g[k]=q),q.getHandSpace()};function I(k){const q=_.get(k.inputSource);q&&q.dispatchEvent({type:k.type,data:k.inputSource})}function T(){_.forEach(function(k,q){k.disconnect(q)}),_.clear(),C=null,D=null,e.setRenderTarget(y),f=null,l=null,c=null,r=null,p=null,ee.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(k){s=k,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(k){a=k,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getBaseLayer=function(){return l!==null?l:f},this.getBinding=function(){return c},this.getFrame=function(){return v},this.getSession=function(){return r},this.setSession=async function(k){if(r=k,r!==null){if(y=e.getRenderTarget(),r.addEventListener("select",I),r.addEventListener("selectstart",I),r.addEventListener("selectend",I),r.addEventListener("squeeze",I),r.addEventListener("squeezestart",I),r.addEventListener("squeezeend",I),r.addEventListener("end",T),r.addEventListener("inputsourceschange",B),m.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const q={antialias:r.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:s};f=new XRWebGLLayer(r,t,q),r.updateRenderState({baseLayer:f}),p=new Vt(f.framebufferWidth,f.framebufferHeight)}else{d=m.antialias;let q=null,ae=null,se=null;m.depth&&(se=m.stencil?35056:33189,q=m.stencil?Ri:Yn,ae=m.stencil?Ti:fr);const de={colorFormat:m.alpha||d?32856:32849,depthFormat:se,scaleFactor:s};c=new XRWebGLBinding(r,t),l=c.createProjectionLayer(de),r.updateRenderState({layers:[l]}),d?p=new ua(l.textureWidth,l.textureHeight,{format:St,type:Nn,depthTexture:new qo(l.textureWidth,l.textureHeight,ae,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:m.stencil,ignoreDepth:l.ignoreDepthValues,useRenderToTexture:u}):p=new Vt(l.textureWidth,l.textureHeight,{format:m.alpha?St:Zn,type:Nn,depthTexture:new qo(l.textureWidth,l.textureHeight,ae,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:m.stencil,ignoreDepth:l.ignoreDepthValues})}this.setFoveation(0),o=await r.requestReferenceSpace(a),ee.setContext(r),ee.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function B(k){const q=r.inputSources;for(let ae=0;ae<g.length;ae++)_.set(q[ae],g[ae]);for(let ae=0;ae<k.removed.length;ae++){const se=k.removed[ae],de=_.get(se);de&&(de.dispatchEvent({type:"disconnected",data:se}),_.delete(se))}for(let ae=0;ae<k.added.length;ae++){const se=k.added[ae],de=_.get(se);de&&de.dispatchEvent({type:"connected",data:se})}}const O=new P,F=new P;function z(k,q,ae){O.setFromMatrixPosition(q.matrixWorld),F.setFromMatrixPosition(ae.matrixWorld);const se=O.distanceTo(F),de=q.projectionMatrix.elements,Se=ae.projectionMatrix.elements,Q=de[14]/(de[10]-1),ve=de[14]/(de[10]+1),xe=(de[9]+1)/de[5],fe=(de[9]-1)/de[5],pe=(de[8]-1)/de[0],Pe=(Se[8]+1)/Se[0],Z=Q*pe,K=Q*Pe,oe=se/(-pe+Pe),me=oe*-pe;q.matrixWorld.decompose(k.position,k.quaternion,k.scale),k.translateX(me),k.translateZ(oe),k.matrixWorld.compose(k.position,k.quaternion,k.scale),k.matrixWorldInverse.copy(k.matrixWorld).invert();const he=Q+oe,Te=ve+oe,Le=Z-me,R=K+(se-me),V=xe*ve/Te*he,E=fe*ve/Te*he;k.projectionMatrix.makePerspective(Le,R,V,E,he,Te)}function N(k,q){q===null?k.matrixWorld.copy(k.matrix):k.matrixWorld.multiplyMatrices(q.matrixWorld,k.matrix),k.matrixWorldInverse.copy(k.matrixWorld).invert()}this.updateCamera=function(k){if(r===null)return;w.near=M.near=x.near=k.near,w.far=M.far=x.far=k.far,(C!==w.near||D!==w.far)&&(r.updateRenderState({depthNear:w.near,depthFar:w.far}),C=w.near,D=w.far);const q=k.parent,ae=w.cameras;N(w,q);for(let de=0;de<ae.length;de++)N(ae[de],q);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),k.position.copy(w.position),k.quaternion.copy(w.quaternion),k.scale.copy(w.scale),k.matrix.copy(w.matrix),k.matrixWorld.copy(w.matrixWorld);const se=k.children;for(let de=0,Se=se.length;de<Se;de++)se[de].updateMatrixWorld(!0);ae.length===2?z(w,x,M):w.projectionMatrix.copy(x.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){if(l!==null)return l.fixedFoveation;if(f!==null)return f.fixedFoveation},this.setFoveation=function(k){l!==null&&(l.fixedFoveation=k),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=k)};let U=null;function Y(k,q){if(h=q.getViewerPose(o),v=q,h!==null){const se=h.views;f!==null&&(e.setRenderTargetFramebuffer(p,f.framebuffer),e.setRenderTarget(p));let de=!1;se.length!==w.cameras.length&&(w.cameras.length=0,de=!0);for(let Se=0;Se<se.length;Se++){const Q=se[Se];let ve=null;if(f!==null)ve=f.getViewport(Q);else{const fe=c.getViewSubImage(l,Q);ve=fe.viewport,Se===0&&(e.setRenderTargetTextures(p,fe.colorTexture,l.ignoreDepthValues?void 0:fe.depthStencilTexture),e.setRenderTarget(p))}const xe=S[Se];xe.matrix.fromArray(Q.transform.matrix),xe.projectionMatrix.fromArray(Q.projectionMatrix),xe.viewport.set(ve.x,ve.y,ve.width,ve.height),Se===0&&w.matrix.copy(xe.matrix),de===!0&&w.cameras.push(xe)}}const ae=r.inputSources;for(let se=0;se<g.length;se++){const de=g[se],Se=ae[se];de.update(Se,q,o)}U&&U(k,q),v=null}const ee=new zc;ee.setAnimationLoop(Y),this.setAnimationLoop=function(k){U=k},this.dispose=function(){}}}function Mv(i){function e(p,g){p.fogColor.value.copy(g.color),g.isFog?(p.fogNear.value=g.near,p.fogFar.value=g.far):g.isFogExp2&&(p.fogDensity.value=g.density)}function t(p,g,_,x,M){g.isMeshBasicMaterial?n(p,g):g.isMeshLambertMaterial?(n(p,g),u(p,g)):g.isMeshToonMaterial?(n(p,g),c(p,g)):g.isMeshPhongMaterial?(n(p,g),h(p,g)):g.isMeshStandardMaterial?(n(p,g),g.isMeshPhysicalMaterial?f(p,g,M):l(p,g)):g.isMeshMatcapMaterial?(n(p,g),d(p,g)):g.isMeshDepthMaterial?(n(p,g),v(p,g)):g.isMeshDistanceMaterial?(n(p,g),m(p,g)):g.isMeshNormalMaterial?(n(p,g),y(p,g)):g.isLineBasicMaterial?(r(p,g),g.isLineDashedMaterial&&s(p,g)):g.isPointsMaterial?o(p,g,_,x):g.isSpriteMaterial?a(p,g):g.isShadowMaterial?(p.color.value.copy(g.color),p.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function n(p,g){p.opacity.value=g.opacity,g.color&&p.diffuse.value.copy(g.color),g.emissive&&p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.specularMap&&(p.specularMap.value=g.specularMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);const _=i.get(g).envMap;_&&(p.envMap.value=_,p.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=g.reflectivity,p.ior.value=g.ior,p.refractionRatio.value=g.refractionRatio),g.lightMap&&(p.lightMap.value=g.lightMap,p.lightMapIntensity.value=g.lightMapIntensity),g.aoMap&&(p.aoMap.value=g.aoMap,p.aoMapIntensity.value=g.aoMapIntensity);let x;g.map?x=g.map:g.specularMap?x=g.specularMap:g.displacementMap?x=g.displacementMap:g.normalMap?x=g.normalMap:g.bumpMap?x=g.bumpMap:g.roughnessMap?x=g.roughnessMap:g.metalnessMap?x=g.metalnessMap:g.alphaMap?x=g.alphaMap:g.emissiveMap?x=g.emissiveMap:g.clearcoatMap?x=g.clearcoatMap:g.clearcoatNormalMap?x=g.clearcoatNormalMap:g.clearcoatRoughnessMap?x=g.clearcoatRoughnessMap:g.specularIntensityMap?x=g.specularIntensityMap:g.specularColorMap?x=g.specularColorMap:g.transmissionMap?x=g.transmissionMap:g.thicknessMap?x=g.thicknessMap:g.sheenColorMap?x=g.sheenColorMap:g.sheenRoughnessMap&&(x=g.sheenRoughnessMap),x!==void 0&&(x.isWebGLRenderTarget&&(x=x.texture),x.matrixAutoUpdate===!0&&x.updateMatrix(),p.uvTransform.value.copy(x.matrix));let M;g.aoMap?M=g.aoMap:g.lightMap&&(M=g.lightMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uv2Transform.value.copy(M.matrix))}function r(p,g){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity}function s(p,g){p.dashSize.value=g.dashSize,p.totalSize.value=g.dashSize+g.gapSize,p.scale.value=g.scale}function o(p,g,_,x){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity,p.size.value=g.size*_,p.scale.value=x*.5,g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);let M;g.map?M=g.map:g.alphaMap&&(M=g.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uvTransform.value.copy(M.matrix))}function a(p,g){p.diffuse.value.copy(g.color),p.opacity.value=g.opacity,p.rotation.value=g.rotation,g.map&&(p.map.value=g.map),g.alphaMap&&(p.alphaMap.value=g.alphaMap),g.alphaTest>0&&(p.alphaTest.value=g.alphaTest);let _;g.map?_=g.map:g.alphaMap&&(_=g.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),p.uvTransform.value.copy(_.matrix))}function u(p,g){g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap)}function h(p,g){p.specular.value.copy(g.specular),p.shininess.value=Math.max(g.shininess,1e-4),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===at&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===at&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function c(p,g){g.gradientMap&&(p.gradientMap.value=g.gradientMap),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===at&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===at&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function l(p,g){p.roughness.value=g.roughness,p.metalness.value=g.metalness,g.roughnessMap&&(p.roughnessMap.value=g.roughnessMap),g.metalnessMap&&(p.metalnessMap.value=g.metalnessMap),g.emissiveMap&&(p.emissiveMap.value=g.emissiveMap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===at&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===at&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias),i.get(g).envMap&&(p.envMapIntensity.value=g.envMapIntensity)}function f(p,g,_){l(p,g),p.ior.value=g.ior,g.sheen>0&&(p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),p.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(p.sheenColorMap.value=g.sheenColorMap),g.sheenRoughnessMap&&(p.sheenRoughnessMap.value=g.sheenRoughnessMap)),g.clearcoat>0&&(p.clearcoat.value=g.clearcoat,p.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(p.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),p.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===at&&p.clearcoatNormalScale.value.negate())),g.transmission>0&&(p.transmission.value=g.transmission,p.transmissionSamplerMap.value=_.texture,p.transmissionSamplerSize.value.set(_.width,_.height),g.transmissionMap&&(p.transmissionMap.value=g.transmissionMap),p.thickness.value=g.thickness,g.thicknessMap&&(p.thicknessMap.value=g.thicknessMap),p.attenuationDistance.value=g.attenuationDistance,p.attenuationColor.value.copy(g.attenuationColor)),p.specularIntensity.value=g.specularIntensity,p.specularColor.value.copy(g.specularColor),g.specularIntensityMap&&(p.specularIntensityMap.value=g.specularIntensityMap),g.specularColorMap&&(p.specularColorMap.value=g.specularColorMap)}function d(p,g){g.matcap&&(p.matcap.value=g.matcap),g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===at&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===at&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function v(p,g){g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}function m(p,g){g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias),p.referencePosition.value.copy(g.referencePosition),p.nearDistance.value=g.nearDistance,p.farDistance.value=g.farDistance}function y(p,g){g.bumpMap&&(p.bumpMap.value=g.bumpMap,p.bumpScale.value=g.bumpScale,g.side===at&&(p.bumpScale.value*=-1)),g.normalMap&&(p.normalMap.value=g.normalMap,p.normalScale.value.copy(g.normalScale),g.side===at&&p.normalScale.value.negate()),g.displacementMap&&(p.displacementMap.value=g.displacementMap,p.displacementScale.value=g.displacementScale,p.displacementBias.value=g.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function bv(){const i=Cs("canvas");return i.style.display="block",i}function ke(i={}){const e=i.canvas!==void 0?i.canvas:bv(),t=i.context!==void 0?i.context:null,n=i.alpha!==void 0?i.alpha:!1,r=i.depth!==void 0?i.depth:!0,s=i.stencil!==void 0?i.stencil:!0,o=i.antialias!==void 0?i.antialias:!1,a=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,u=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,h=i.powerPreference!==void 0?i.powerPreference:"default",c=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let l=null,f=null;const d=[],v=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Pt,this.physicallyCorrectLights=!1,this.toneMapping=Xn,this.toneMappingExposure=1;const m=this;let y=!1,p=0,g=0,_=null,x=-1,M=null;const S=new We,w=new We;let C=null,D=e.width,I=e.height,T=1,B=null,O=null;const F=new We(0,0,D,I),z=new We(0,0,D,I);let N=!1;const U=[],Y=new Rs;let ee=!1,k=!1,q=null;const ae=new Re,se=new P,de={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Se(){return _===null?T:1}let Q=t;function ve(A,W){for(let j=0;j<A.length;j++){const X=A[j],ne=e.getContext(X,W);if(ne!==null)return ne}return null}try{const A={alpha:n,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:u,powerPreference:h,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${sa}`),e.addEventListener("webglcontextlost",we,!1),e.addEventListener("webglcontextrestored",Fe,!1),Q===null){const W=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&W.shift(),Q=ve(W,A),Q===null)throw ve(W)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Q.getShaderPrecisionFormat===void 0&&(Q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(A){throw console.error("THREE.WebGLRenderer: "+A.message),A}let xe,fe,pe,Pe,Z,K,oe,me,he,Te,Le,R,V,E,b,H,G,ie,J,L,$,te,ue;function ce(){xe=new Xm(Q),fe=new Bm(Q,xe,i),xe.init(fe),te=new _v(Q,xe,fe),pe=new vv(Q,xe,fe),U[0]=1029,Pe=new jm(Q),Z=new ov,K=new yv(Q,xe,pe,Z,fe,te,Pe),oe=new Hm(m),me=new qm(m),he=new ld(Q,fe),ue=new zm(Q,xe,he,fe),Te=new Zm(Q,he,Pe,ue),Le=new Km(Q,Te,he,Pe),J=new Qm(Q,fe,K),H=new Um(Z),R=new sv(m,oe,me,xe,fe,ue,H),V=new Mv(Z),E=new lv(Z),b=new pv(xe,fe),ie=new Fm(m,oe,pe,Le,a),G=new Jc(m,Le,fe),L=new Om(Q,xe,Pe,fe),$=new Ym(Q,xe,Pe,fe),Pe.programs=R.programs,m.capabilities=fe,m.extensions=xe,m.properties=Z,m.renderLists=E,m.shadowMap=G,m.state=pe,m.info=Pe}ce();const ye=new wv(m,Q);this.xr=ye,this.getContext=function(){return Q},this.getContextAttributes=function(){return Q.getContextAttributes()},this.forceContextLoss=function(){const A=xe.get("WEBGL_lose_context");A&&A.loseContext()},this.forceContextRestore=function(){const A=xe.get("WEBGL_lose_context");A&&A.restoreContext()},this.getPixelRatio=function(){return T},this.setPixelRatio=function(A){A!==void 0&&(T=A,this.setSize(D,I,!1))},this.getSize=function(A){return A.set(D,I)},this.setSize=function(A,W,j){if(ye.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}D=A,I=W,e.width=Math.floor(A*T),e.height=Math.floor(W*T),j!==!1&&(e.style.width=A+"px",e.style.height=W+"px"),this.setViewport(0,0,A,W)},this.getDrawingBufferSize=function(A){return A.set(D*T,I*T).floor()},this.setDrawingBufferSize=function(A,W,j){D=A,I=W,T=j,e.width=Math.floor(A*j),e.height=Math.floor(W*j),this.setViewport(0,0,A,W)},this.getCurrentViewport=function(A){return A.copy(S)},this.getViewport=function(A){return A.copy(F)},this.setViewport=function(A,W,j,X){A.isVector4?F.set(A.x,A.y,A.z,A.w):F.set(A,W,j,X),pe.viewport(S.copy(F).multiplyScalar(T).floor())},this.getScissor=function(A){return A.copy(z)},this.setScissor=function(A,W,j,X){A.isVector4?z.set(A.x,A.y,A.z,A.w):z.set(A,W,j,X),pe.scissor(w.copy(z).multiplyScalar(T).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(A){pe.setScissorTest(N=A)},this.setOpaqueSort=function(A){B=A},this.setTransparentSort=function(A){O=A},this.getClearColor=function(A){return A.copy(ie.getClearColor())},this.setClearColor=function(){ie.setClearColor.apply(ie,arguments)},this.getClearAlpha=function(){return ie.getClearAlpha()},this.setClearAlpha=function(){ie.setClearAlpha.apply(ie,arguments)},this.clear=function(A,W,j){let X=0;(A===void 0||A)&&(X|=16384),(W===void 0||W)&&(X|=256),(j===void 0||j)&&(X|=1024),Q.clear(X)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",we,!1),e.removeEventListener("webglcontextrestored",Fe,!1),E.dispose(),b.dispose(),Z.dispose(),oe.dispose(),me.dispose(),Le.dispose(),ue.dispose(),ye.dispose(),ye.removeEventListener("sessionstart",Ar),ye.removeEventListener("sessionend",Cr),q&&(q.dispose(),q=null),sn.stop()};function we(A){A.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Fe(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const A=Pe.autoReset,W=G.enabled,j=G.autoUpdate,X=G.needsUpdate,ne=G.type;ce(),Pe.autoReset=A,G.enabled=W,G.autoUpdate=j,G.needsUpdate=X,G.type=ne}function Je(A){const W=A.target;W.removeEventListener("dispose",Je),Ue(W)}function Ue(A){Dt(A),Z.remove(A)}function Dt(A){const W=Z.get(A).programs;W!==void 0&&W.forEach(function(j){R.releaseProgram(j)})}this.renderBufferDirect=function(A,W,j,X,ne,Ne){W===null&&(W=de);const Ae=ne.isMesh&&ne.matrixWorld.determinant()<0,_e=Xs(A,W,j,X,ne);pe.setMaterial(X,Ae);let Me=j.index;const Ie=j.attributes.position;if(Me===null){if(Ie===void 0||Ie.count===0)return}else if(Me.count===0)return;let ze=1;X.wireframe===!0&&(Me=Te.getWireframeAttribute(j),ze=2),ue.setup(ne,X,_e,j,Me);let Be,tt=L;Me!==null&&(Be=he.get(Me),tt=$,tt.setIndex(Be));const Bn=Me!==null?Me.count:Ie.count,He=j.drawRange.start*ze,Xi=j.drawRange.count*ze,Ze=Ne!==null?Ne.start*ze:0,Un=Ne!==null?Ne.count*ze:1/0,Hn=Math.max(He,Ze),Vn=Math.min(Bn,He+Xi,Ze+Un)-1,gn=Math.max(0,Vn-Hn+1);if(gn!==0){if(ne.isMesh)X.wireframe===!0?(pe.setLineWidth(X.wireframeLinewidth*Se()),tt.setMode(1)):tt.setMode(4);else if(ne.isLine){let nt=X.linewidth;nt===void 0&&(nt=1),pe.setLineWidth(nt*Se()),ne.isLineSegments?tt.setMode(1):ne.isLineLoop?tt.setMode(2):tt.setMode(3)}else ne.isPoints?tt.setMode(0):ne.isSprite&&tt.setMode(4);if(ne.isInstancedMesh)tt.renderInstances(Hn,gn,ne.count);else if(j.isInstancedBufferGeometry){const nt=Math.min(j.instanceCount,j._maxInstanceCount);tt.renderInstances(Hn,gn,nt)}else tt.render(Hn,gn)}},this.compile=function(A,W){f=b.get(A),f.init(),v.push(f),A.traverseVisible(function(j){j.isLight&&j.layers.test(W.layers)&&(f.pushLight(j),j.castShadow&&f.pushShadow(j))}),f.setupLights(m.physicallyCorrectLights),A.traverse(function(j){const X=j.material;if(X)if(Array.isArray(X))for(let ne=0;ne<X.length;ne++){const Ne=X[ne];qi(Ne,A,j)}else qi(X,A,j)}),v.pop(),f=null};let It=null;function ks(A){It&&It(A)}function Ar(){sn.stop()}function Cr(){sn.start()}const sn=new zc;sn.setAnimationLoop(ks),typeof window!="undefined"&&sn.setContext(window),this.setAnimationLoop=function(A){It=A,ye.setAnimationLoop(A),A===null?sn.stop():sn.start()},ye.addEventListener("sessionstart",Ar),ye.addEventListener("sessionend",Cr),this.render=function(A,W){if(W!==void 0&&W.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;A.autoUpdate===!0&&A.updateMatrixWorld(),W.parent===null&&W.updateMatrixWorld(),ye.enabled===!0&&ye.isPresenting===!0&&(ye.cameraAutoUpdate===!0&&ye.updateCamera(W),W=ye.getCamera()),A.isScene===!0&&A.onBeforeRender(m,A,W,_),f=b.get(A,v.length),f.init(),v.push(f),ae.multiplyMatrices(W.projectionMatrix,W.matrixWorldInverse),Y.setFromProjectionMatrix(ae),k=this.localClippingEnabled,ee=H.init(this.clippingPlanes,k,W),l=E.get(A,d.length),l.init(),d.push(l),$t(A,W,0,m.sortObjects),l.finish(),m.sortObjects===!0&&l.sort(B,O),ee===!0&&H.beginShadows();const j=f.state.shadowsArray;if(G.render(j,A,W),ee===!0&&H.endShadows(),this.info.autoReset===!0&&this.info.reset(),ie.render(l,A),f.setupLights(m.physicallyCorrectLights),W.isArrayCamera){const X=W.cameras;for(let ne=0,Ne=X.length;ne<Ne;ne++){const Ae=X[ne];Lr(l,A,Ae,Ae.viewport)}}else Lr(l,A,W);_!==null&&(K.updateMultisampleRenderTarget(_),K.updateRenderTargetMipmap(_)),A.isScene===!0&&A.onAfterRender(m,A,W),pe.buffers.depth.setTest(!0),pe.buffers.depth.setMask(!0),pe.buffers.color.setMask(!0),pe.setPolygonOffset(!1),ue.resetDefaultState(),x=-1,M=null,v.pop(),v.length>0?f=v[v.length-1]:f=null,d.pop(),d.length>0?l=d[d.length-1]:l=null};function $t(A,W,j,X){if(A.visible===!1)return;if(A.layers.test(W.layers)){if(A.isGroup)j=A.renderOrder;else if(A.isLOD)A.autoUpdate===!0&&A.update(W);else if(A.isLight)f.pushLight(A),A.castShadow&&f.pushShadow(A);else if(A.isSprite){if(!A.frustumCulled||Y.intersectsSprite(A)){X&&se.setFromMatrixPosition(A.matrixWorld).applyMatrix4(ae);const Ae=Le.update(A),_e=A.material;_e.visible&&l.push(A,Ae,_e,j,se.z,null)}}else if((A.isMesh||A.isLine||A.isPoints)&&(A.isSkinnedMesh&&A.skeleton.frame!==Pe.render.frame&&(A.skeleton.update(),A.skeleton.frame=Pe.render.frame),!A.frustumCulled||Y.intersectsObject(A))){X&&se.setFromMatrixPosition(A.matrixWorld).applyMatrix4(ae);const Ae=Le.update(A),_e=A.material;if(Array.isArray(_e)){const Me=Ae.groups;for(let Ie=0,ze=Me.length;Ie<ze;Ie++){const Be=Me[Ie],tt=_e[Be.materialIndex];tt&&tt.visible&&l.push(A,Ae,tt,j,se.z,Be)}}else _e.visible&&l.push(A,Ae,_e,j,se.z,null)}}const Ne=A.children;for(let Ae=0,_e=Ne.length;Ae<_e;Ae++)$t(Ne[Ae],W,j,X)}function Lr(A,W,j,X){const ne=A.opaque,Ne=A.transmissive,Ae=A.transparent;f.setupLightsView(j),Ne.length>0&&Ws(ne,W,j),X&&pe.viewport(S.copy(X)),ne.length>0&&Kn(ne,W,j),Ne.length>0&&Kn(Ne,W,j),Ae.length>0&&Kn(Ae,W,j)}function Ws(A,W,j){if(q===null){const Ae=o===!0&&fe.isWebGL2===!0?ua:Vt;q=new Ae(1024,1024,{generateMipmaps:!0,type:te.convert(Ei)!==null?Ei:Nn,minFilter:Ts,magFilter:ht,wrapS:Bt,wrapT:Bt,useRenderToTexture:xe.has("WEBGL_multisampled_render_to_texture")})}const X=m.getRenderTarget();m.setRenderTarget(q),m.clear();const ne=m.toneMapping;m.toneMapping=Xn,Kn(A,W,j),m.toneMapping=ne,K.updateMultisampleRenderTarget(q),K.updateRenderTargetMipmap(q),m.setRenderTarget(X)}function Kn(A,W,j){const X=W.isScene===!0?W.overrideMaterial:null;for(let ne=0,Ne=A.length;ne<Ne;ne++){const Ae=A[ne],_e=Ae.object,Me=Ae.geometry,Ie=X===null?Ae.material:X,ze=Ae.group;_e.layers.test(j.layers)&&qs(_e,W,j,Me,Ie,ze)}}function qs(A,W,j,X,ne,Ne){A.onBeforeRender(m,W,j,X,ne,Ne),A.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse,A.matrixWorld),A.normalMatrix.getNormalMatrix(A.modelViewMatrix),ne.onBeforeRender(m,W,j,X,A,Ne),ne.transparent===!0&&ne.side===Li?(ne.side=at,ne.needsUpdate=!0,m.renderBufferDirect(j,W,X,ne,A,Ne),ne.side=hr,ne.needsUpdate=!0,m.renderBufferDirect(j,W,X,ne,A,Ne),ne.side=Li):m.renderBufferDirect(j,W,X,ne,A,Ne),A.onAfterRender(m,W,j,X,ne,Ne)}function qi(A,W,j){W.isScene!==!0&&(W=de);const X=Z.get(A),ne=f.state.lights,Ne=f.state.shadowsArray,Ae=ne.state.version,_e=R.getParameters(A,ne.state,Ne,W,j),Me=R.getProgramCacheKey(_e);let Ie=X.programs;X.environment=A.isMeshStandardMaterial?W.environment:null,X.fog=W.fog,X.envMap=(A.isMeshStandardMaterial?me:oe).get(A.envMap||X.environment),Ie===void 0&&(A.addEventListener("dispose",Je),Ie=new Map,X.programs=Ie);let ze=Ie.get(Me);if(ze!==void 0){if(X.currentProgram===ze&&X.lightsStateVersion===Ae)return Rr(A,_e),ze}else _e.uniforms=R.getUniforms(A),A.onBuild(j,_e,m),A.onBeforeCompile(_e,m),ze=R.acquireProgram(_e,Me),Ie.set(Me,ze),X.uniforms=_e.uniforms;const Be=X.uniforms;(!A.isShaderMaterial&&!A.isRawShaderMaterial||A.clipping===!0)&&(Be.clippingPlanes=H.uniform),Rr(A,_e),X.needsLights=Ys(A),X.lightsStateVersion=Ae,X.needsLights&&(Be.ambientLightColor.value=ne.state.ambient,Be.lightProbe.value=ne.state.probe,Be.directionalLights.value=ne.state.directional,Be.directionalLightShadows.value=ne.state.directionalShadow,Be.spotLights.value=ne.state.spot,Be.spotLightShadows.value=ne.state.spotShadow,Be.rectAreaLights.value=ne.state.rectArea,Be.ltc_1.value=ne.state.rectAreaLTC1,Be.ltc_2.value=ne.state.rectAreaLTC2,Be.pointLights.value=ne.state.point,Be.pointLightShadows.value=ne.state.pointShadow,Be.hemisphereLights.value=ne.state.hemi,Be.directionalShadowMap.value=ne.state.directionalShadowMap,Be.directionalShadowMatrix.value=ne.state.directionalShadowMatrix,Be.spotShadowMap.value=ne.state.spotShadowMap,Be.spotShadowMatrix.value=ne.state.spotShadowMatrix,Be.pointShadowMap.value=ne.state.pointShadowMap,Be.pointShadowMatrix.value=ne.state.pointShadowMatrix);const tt=ze.getUniforms(),Bn=Rn.seqWithValue(tt.seq,Be);return X.currentProgram=ze,X.uniformsList=Bn,ze}function Rr(A,W){const j=Z.get(A);j.outputEncoding=W.outputEncoding,j.instancing=W.instancing,j.skinning=W.skinning,j.morphTargets=W.morphTargets,j.morphNormals=W.morphNormals,j.morphTargetsCount=W.morphTargetsCount,j.numClippingPlanes=W.numClippingPlanes,j.numIntersection=W.numClipIntersection,j.vertexAlphas=W.vertexAlphas,j.vertexTangents=W.vertexTangents}function Xs(A,W,j,X,ne){W.isScene!==!0&&(W=de),K.resetTextureUnits();const Ne=W.fog,Ae=X.isMeshStandardMaterial?W.environment:null,_e=_===null?m.outputEncoding:_.texture.encoding,Me=(X.isMeshStandardMaterial?me:oe).get(X.envMap||Ae),Ie=X.vertexColors===!0&&!!j.attributes.color&&j.attributes.color.itemSize===4,ze=!!X.normalMap&&!!j.attributes.tangent,Be=!!j.morphAttributes.position,tt=!!j.morphAttributes.normal,Bn=j.morphAttributes.position?j.morphAttributes.position.length:0,He=Z.get(X),Xi=f.state.lights;if(ee===!0&&(k===!0||A!==M)){const kt=A===M&&X.id===x;H.setState(X,A,kt)}let Ze=!1;X.version===He.__version?(He.needsLights&&He.lightsStateVersion!==Xi.state.version||He.outputEncoding!==_e||ne.isInstancedMesh&&He.instancing===!1||!ne.isInstancedMesh&&He.instancing===!0||ne.isSkinnedMesh&&He.skinning===!1||!ne.isSkinnedMesh&&He.skinning===!0||He.envMap!==Me||X.fog&&He.fog!==Ne||He.numClippingPlanes!==void 0&&(He.numClippingPlanes!==H.numPlanes||He.numIntersection!==H.numIntersection)||He.vertexAlphas!==Ie||He.vertexTangents!==ze||He.morphTargets!==Be||He.morphNormals!==tt||fe.isWebGL2===!0&&He.morphTargetsCount!==Bn)&&(Ze=!0):(Ze=!0,He.__version=X.version);let Un=He.currentProgram;Ze===!0&&(Un=qi(X,W,ne));let Hn=!1,Vn=!1,gn=!1;const nt=Un.getUniforms(),Zi=He.uniforms;if(pe.useProgram(Un.program)&&(Hn=!0,Vn=!0,gn=!0),X.id!==x&&(x=X.id,Vn=!0),Hn||M!==A){if(nt.setValue(Q,"projectionMatrix",A.projectionMatrix),fe.logarithmicDepthBuffer&&nt.setValue(Q,"logDepthBufFC",2/(Math.log(A.far+1)/Math.LN2)),M!==A&&(M=A,Vn=!0,gn=!0),X.isShaderMaterial||X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshStandardMaterial||X.envMap){const kt=nt.map.cameraPosition;kt!==void 0&&kt.setValue(Q,se.setFromMatrixPosition(A.matrixWorld))}(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial)&&nt.setValue(Q,"isOrthographic",A.isOrthographicCamera===!0),(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial||X.isShadowMaterial||ne.isSkinnedMesh)&&nt.setValue(Q,"viewMatrix",A.matrixWorldInverse)}if(ne.isSkinnedMesh){nt.setOptional(Q,ne,"bindMatrix"),nt.setOptional(Q,ne,"bindMatrixInverse");const kt=ne.skeleton;kt&&(fe.floatVertexTextures?(kt.boneTexture===null&&kt.computeBoneTexture(),nt.setValue(Q,"boneTexture",kt.boneTexture,K),nt.setValue(Q,"boneTextureSize",kt.boneTextureSize)):nt.setOptional(Q,kt,"boneMatrices"))}return!!j&&(j.morphAttributes.position!==void 0||j.morphAttributes.normal!==void 0)&&J.update(ne,j,X,Un),(Vn||He.receiveShadow!==ne.receiveShadow)&&(He.receiveShadow=ne.receiveShadow,nt.setValue(Q,"receiveShadow",ne.receiveShadow)),Vn&&(nt.setValue(Q,"toneMappingExposure",m.toneMappingExposure),He.needsLights&&Zs(Zi,gn),Ne&&X.fog&&V.refreshFogUniforms(Zi,Ne),V.refreshMaterialUniforms(Zi,X,T,I,q),Rn.upload(Q,He.uniformsList,Zi,K)),X.isShaderMaterial&&X.uniformsNeedUpdate===!0&&(Rn.upload(Q,He.uniformsList,Zi,K),X.uniformsNeedUpdate=!1),X.isSpriteMaterial&&nt.setValue(Q,"center",ne.center),nt.setValue(Q,"modelViewMatrix",ne.modelViewMatrix),nt.setValue(Q,"normalMatrix",ne.normalMatrix),nt.setValue(Q,"modelMatrix",ne.matrixWorld),Un}function Zs(A,W){A.ambientLightColor.needsUpdate=W,A.lightProbe.needsUpdate=W,A.directionalLights.needsUpdate=W,A.directionalLightShadows.needsUpdate=W,A.pointLights.needsUpdate=W,A.pointLightShadows.needsUpdate=W,A.spotLights.needsUpdate=W,A.spotLightShadows.needsUpdate=W,A.rectAreaLights.needsUpdate=W,A.hemisphereLights.needsUpdate=W}function Ys(A){return A.isMeshLambertMaterial||A.isMeshToonMaterial||A.isMeshPhongMaterial||A.isMeshStandardMaterial||A.isShadowMaterial||A.isShaderMaterial&&A.lights===!0}this.getActiveCubeFace=function(){return p},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return _},this.setRenderTargetTextures=function(A,W,j){Z.get(A.texture).__webglTexture=W,Z.get(A.depthTexture).__webglTexture=j;const X=Z.get(A);X.__hasExternalTextures=!0,X.__hasExternalTextures&&(X.__autoAllocateDepthBuffer=j===void 0,X.__autoAllocateDepthBuffer||A.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),A.useRenderToTexture=!1,A.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(A,W){const j=Z.get(A);j.__webglFramebuffer=W,j.__useDefaultFramebuffer=W===void 0},this.setRenderTarget=function(A,W=0,j=0){_=A,p=W,g=j;let X=!0;if(A){const Me=Z.get(A);Me.__useDefaultFramebuffer!==void 0?(pe.bindFramebuffer(36160,null),X=!1):Me.__webglFramebuffer===void 0?K.setupRenderTarget(A):Me.__hasExternalTextures&&K.rebindTextures(A,Z.get(A.texture).__webglTexture,Z.get(A.depthTexture).__webglTexture)}let ne=null,Ne=!1,Ae=!1;if(A){const Me=A.texture;(Me.isDataTexture3D||Me.isDataTexture2DArray)&&(Ae=!0);const Ie=Z.get(A).__webglFramebuffer;A.isWebGLCubeRenderTarget?(ne=Ie[W],Ne=!0):A.useRenderbuffer?ne=Z.get(A).__webglMultisampledFramebuffer:ne=Ie,S.copy(A.viewport),w.copy(A.scissor),C=A.scissorTest}else S.copy(F).multiplyScalar(T).floor(),w.copy(z).multiplyScalar(T).floor(),C=N;if(pe.bindFramebuffer(36160,ne)&&fe.drawBuffers&&X){let Me=!1;if(A)if(A.isWebGLMultipleRenderTargets){const Ie=A.texture;if(U.length!==Ie.length||U[0]!==36064){for(let ze=0,Be=Ie.length;ze<Be;ze++)U[ze]=36064+ze;U.length=Ie.length,Me=!0}}else(U.length!==1||U[0]!==36064)&&(U[0]=36064,U.length=1,Me=!0);else(U.length!==1||U[0]!==1029)&&(U[0]=1029,U.length=1,Me=!0);Me&&(fe.isWebGL2?Q.drawBuffers(U):xe.get("WEBGL_draw_buffers").drawBuffersWEBGL(U))}if(pe.viewport(S),pe.scissor(w),pe.setScissorTest(C),Ne){const Me=Z.get(A.texture);Q.framebufferTexture2D(36160,36064,34069+W,Me.__webglTexture,j)}else if(Ae){const Me=Z.get(A.texture),Ie=W||0;Q.framebufferTextureLayer(36160,36064,Me.__webglTexture,j||0,Ie)}x=-1},this.readRenderTargetPixels=function(A,W,j,X,ne,Ne,Ae){if(!(A&&A.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let _e=Z.get(A).__webglFramebuffer;if(A.isWebGLCubeRenderTarget&&Ae!==void 0&&(_e=_e[Ae]),_e){pe.bindFramebuffer(36160,_e);try{const Me=A.texture,Ie=Me.format,ze=Me.type;if(Ie!==St&&te.convert(Ie)!==Q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Be=ze===Ei&&(xe.has("EXT_color_buffer_half_float")||fe.isWebGL2&&xe.has("EXT_color_buffer_float"));if(ze!==Nn&&te.convert(ze)!==Q.getParameter(35738)&&!(ze===Tn&&(fe.isWebGL2||xe.has("OES_texture_float")||xe.has("WEBGL_color_buffer_float")))&&!Be){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Q.checkFramebufferStatus(36160)===36053?W>=0&&W<=A.width-X&&j>=0&&j<=A.height-ne&&Q.readPixels(W,j,X,ne,te.convert(Ie),te.convert(ze),Ne):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Me=_!==null?Z.get(_).__webglFramebuffer:null;pe.bindFramebuffer(36160,Me)}}},this.copyFramebufferToTexture=function(A,W,j=0){const X=Math.pow(2,-j),ne=Math.floor(W.image.width*X),Ne=Math.floor(W.image.height*X);let Ae=te.convert(W.format);fe.isWebGL2&&(Ae===6407&&(Ae=32849),Ae===6408&&(Ae=32856)),K.setTexture2D(W,0),Q.copyTexImage2D(3553,j,Ae,A.x,A.y,ne,Ne,0),pe.unbindTexture()},this.copyTextureToTexture=function(A,W,j,X=0){const ne=W.image.width,Ne=W.image.height,Ae=te.convert(j.format),_e=te.convert(j.type);K.setTexture2D(j,0),Q.pixelStorei(37440,j.flipY),Q.pixelStorei(37441,j.premultiplyAlpha),Q.pixelStorei(3317,j.unpackAlignment),W.isDataTexture?Q.texSubImage2D(3553,X,A.x,A.y,ne,Ne,Ae,_e,W.image.data):W.isCompressedTexture?Q.compressedTexSubImage2D(3553,X,A.x,A.y,W.mipmaps[0].width,W.mipmaps[0].height,Ae,W.mipmaps[0].data):Q.texSubImage2D(3553,X,A.x,A.y,Ae,_e,W.image),X===0&&j.generateMipmaps&&Q.generateMipmap(3553),pe.unbindTexture()},this.copyTextureToTexture3D=function(A,W,j,X,ne=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ne=A.max.x-A.min.x+1,Ae=A.max.y-A.min.y+1,_e=A.max.z-A.min.z+1,Me=te.convert(X.format),Ie=te.convert(X.type);let ze;if(X.isDataTexture3D)K.setTexture3D(X,0),ze=32879;else if(X.isDataTexture2DArray)K.setTexture2DArray(X,0),ze=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Q.pixelStorei(37440,X.flipY),Q.pixelStorei(37441,X.premultiplyAlpha),Q.pixelStorei(3317,X.unpackAlignment);const Be=Q.getParameter(3314),tt=Q.getParameter(32878),Bn=Q.getParameter(3316),He=Q.getParameter(3315),Xi=Q.getParameter(32877),Ze=j.isCompressedTexture?j.mipmaps[0]:j.image;Q.pixelStorei(3314,Ze.width),Q.pixelStorei(32878,Ze.height),Q.pixelStorei(3316,A.min.x),Q.pixelStorei(3315,A.min.y),Q.pixelStorei(32877,A.min.z),j.isDataTexture||j.isDataTexture3D?Q.texSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,_e,Me,Ie,Ze.data):j.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Q.compressedTexSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,_e,Me,Ze.data)):Q.texSubImage3D(ze,ne,W.x,W.y,W.z,Ne,Ae,_e,Me,Ie,Ze),Q.pixelStorei(3314,Be),Q.pixelStorei(32878,tt),Q.pixelStorei(3316,Bn),Q.pixelStorei(3315,He),Q.pixelStorei(32877,Xi),ne===0&&X.generateMipmaps&&Q.generateMipmap(ze),pe.unbindTexture()},this.initTexture=function(A){K.setTexture2D(A,0),pe.unbindTexture()},this.resetState=function(){p=0,g=0,_=null,pe.reset(),ue.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}ke.prototype.isWebGLRenderer=!0;class Sv extends ke{}Sv.prototype.isWebGL1Renderer=!0;class Qc extends Ge{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}Qc.prototype.isScene=!0;class br{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=dr,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=en()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let r=0,s=this.stride;r<s;r++)this.array[e+r]=t.array[n+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=en()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=en()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}br.prototype.isInterleavedBuffer=!0;const rt=new P;class pr{constructor(e,t,n,r=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.applyMatrix4(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.applyNormalMatrix(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)rt.x=this.getX(t),rt.y=this.getY(t),rt.z=this.getZ(t),rt.transformDirection(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this}setXYZW(e,t,n,r,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return new ct(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new pr(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}pr.prototype.isInterleavedBufferAttribute=!0;class Kc extends Mt{constructor(e){super();this.type="SpriteMaterial",this.color=new Ee(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}Kc.prototype.isSpriteMaterial=!0;let mi;const Ki=new P,gi=new P,vi=new P,yi=new le,er=new le,eu=new Re,Jr=new P,tr=new P,$r=new P,Ul=new le,Ao=new le,Hl=new le;class Ev extends Ge{constructor(e){super();if(this.type="Sprite",mi===void 0){mi=new Ye;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new br(t,5);mi.setIndex([0,1,2,0,2,3]),mi.setAttribute("position",new pr(n,3,0,!1)),mi.setAttribute("uv",new pr(n,2,3,!1))}this.geometry=mi,this.material=e!==void 0?e:new Kc,this.center=new le(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),gi.setFromMatrixScale(this.matrixWorld),eu.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),vi.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&gi.multiplyScalar(-vi.z);const n=this.material.rotation;let r,s;n!==0&&(s=Math.cos(n),r=Math.sin(n));const o=this.center;Qr(Jr.set(-.5,-.5,0),vi,o,gi,r,s),Qr(tr.set(.5,-.5,0),vi,o,gi,r,s),Qr($r.set(.5,.5,0),vi,o,gi,r,s),Ul.set(0,0),Ao.set(1,0),Hl.set(1,1);let a=e.ray.intersectTriangle(Jr,tr,$r,!1,Ki);if(a===null&&(Qr(tr.set(-.5,.5,0),vi,o,gi,r,s),Ao.set(0,1),a=e.ray.intersectTriangle(Jr,$r,tr,!1,Ki),a===null))return;const u=e.ray.origin.distanceTo(Ki);u<e.near||u>e.far||t.push({distance:u,point:Ki.clone(),uv:ot.getUV(Ki,Jr,tr,$r,Ul,Ao,Hl,new le),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}Ev.prototype.isSprite=!0;function Qr(i,e,t,n,r,s){yi.subVectors(i,t).addScalar(.5).multiply(n),r!==void 0?(er.x=s*yi.x-r*yi.y,er.y=r*yi.x+s*yi.y):er.copy(yi),i.copy(e),i.x+=er.x,i.y+=er.y,i.applyMatrix4(eu)}const Vl=new P,Gl=new We,kl=new We,Tv=new P,Wl=new Re;class tu extends Lt{constructor(e,t){super(e,t);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Re,this.bindMatrixInverse=new Re}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new We,t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,r=this.geometry;Gl.fromBufferAttribute(r.attributes.skinIndex,e),kl.fromBufferAttribute(r.attributes.skinWeight,e),Vl.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=kl.getComponent(s);if(o!==0){const a=Gl.getComponent(s);Wl.multiplyMatrices(n.bones[a].matrixWorld,n.boneInverses[a]),t.addScaledVector(Tv.copy(Vl).applyMatrix4(Wl),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}tu.prototype.isSkinnedMesh=!0;class Av extends Ge{constructor(){super();this.type="Bone"}}Av.prototype.isBone=!0;class Cv extends yt{constructor(e=null,t=1,n=1,r,s,o,a,u,h=ht,c=ht,l,f){super(null,o,a,u,h,c,r,s,l,f);this.image={data:e,width:t,height:n},this.magFilter=h,this.minFilter=c,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Cv.prototype.isDataTexture=!0;class Xo extends ct{constructor(e,t,n,r=1){typeof n=="number"&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(e,t,n);this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}Xo.prototype.isInstancedBufferAttribute=!0;const ql=new Re,Xl=new Re,Kr=[],nr=new Lt;class Lv extends Lt{constructor(e,t,n){super(e,t);this.instanceMatrix=new Xo(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,r=this.count;if(nr.geometry=this.geometry,nr.material=this.material,nr.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,ql),Xl.multiplyMatrices(n,ql),nr.matrixWorld=Xl,nr.raycast(e,Kr);for(let o=0,a=Kr.length;o<a;o++){const u=Kr[o];u.instanceId=s,u.object=this,t.push(u)}Kr.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Xo(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Lv.prototype.isInstancedMesh=!0;class Sr extends Mt{constructor(e){super();this.type="LineBasicMaterial",this.color=new Ee(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}Sr.prototype.isLineBasicMaterial=!0;const Zl=new P,Yl=new P,jl=new Re,Co=new Bi,es=new Oi;class _a extends Ge{constructor(e=new Ye,t=new Sr){super();this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let r=1,s=t.count;r<s;r++)Zl.fromBufferAttribute(t,r-1),Yl.fromBufferAttribute(t,r),n[r]=n[r-1],n[r]+=Zl.distanceTo(Yl);e.setAttribute("lineDistance",new st(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,s=e.params.Line.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),es.copy(n.boundingSphere),es.applyMatrix4(r),es.radius+=s,e.ray.intersectsSphere(es)===!1)return;jl.copy(r).invert(),Co.copy(e.ray).applyMatrix4(jl);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=a*a,h=new P,c=new P,l=new P,f=new P,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const v=n.index,y=n.attributes.position;if(v!==null){const p=Math.max(0,o.start),g=Math.min(v.count,o.start+o.count);for(let _=p,x=g-1;_<x;_+=d){const M=v.getX(_),S=v.getX(_+1);if(h.fromBufferAttribute(y,M),c.fromBufferAttribute(y,S),Co.distanceSqToSegment(h,c,f,l)>u)continue;f.applyMatrix4(this.matrixWorld);const C=e.ray.origin.distanceTo(f);C<e.near||C>e.far||t.push({distance:C,point:l.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}else{const p=Math.max(0,o.start),g=Math.min(y.count,o.start+o.count);for(let _=p,x=g-1;_<x;_+=d){if(h.fromBufferAttribute(y,_),c.fromBufferAttribute(y,_+1),Co.distanceSqToSegment(h,c,f,l)>u)continue;f.applyMatrix4(this.matrixWorld);const S=e.ray.origin.distanceTo(f);S<e.near||S>e.far||t.push({distance:S,point:l.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}_a.prototype.isLine=!0;const Jl=new P,$l=new P;class xa extends _a{constructor(e,t){super(e,t);this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let r=0,s=t.count;r<s;r+=2)Jl.fromBufferAttribute(t,r),$l.fromBufferAttribute(t,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+Jl.distanceTo($l);e.setAttribute("lineDistance",new st(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}xa.prototype.isLineSegments=!0;class Rv extends _a{constructor(e,t){super(e,t);this.type="LineLoop"}}Rv.prototype.isLineLoop=!0;class nu extends Mt{constructor(e){super();this.type="PointsMaterial",this.color=new Ee(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}nu.prototype.isPointsMaterial=!0;const Ql=new Re,Zo=new Bi,ts=new Oi,ns=new P;class Pv extends Ge{constructor(e=new Ye,t=new nu){super();this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,s=e.params.Points.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),ts.copy(n.boundingSphere),ts.applyMatrix4(r),ts.radius+=s,e.ray.intersectsSphere(ts)===!1)return;Ql.copy(r).invert(),Zo.copy(e.ray).applyMatrix4(Ql);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=a*a;if(n.isBufferGeometry){const h=n.index,l=n.attributes.position;if(h!==null){const f=Math.max(0,o.start),d=Math.min(h.count,o.start+o.count);for(let v=f,m=d;v<m;v++){const y=h.getX(v);ns.fromBufferAttribute(l,y),Kl(ns,y,u,r,e,t,this)}}else{const f=Math.max(0,o.start),d=Math.min(l.count,o.start+o.count);for(let v=f,m=d;v<m;v++)ns.fromBufferAttribute(l,v),Kl(ns,v,u,r,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Pv.prototype.isPoints=!0;function Kl(i,e,t,n,r,s,o){const a=Zo.distanceSqToPoint(i);if(a<t){const u=new P;Zo.closestPointToPoint(i,u),u.applyMatrix4(n);const h=r.ray.origin.distanceTo(u);if(h<r.near||h>r.far)return;s.push({distance:h,distanceToRay:Math.sqrt(a),point:u,index:e,face:null,object:o})}}class Nv extends yt{constructor(e,t,n,r,s,o,a,u,h){super(e,t,n,r,s,o,a,u,h);this.format=a!==void 0?a:Zn,this.minFilter=o!==void 0?o:Ht,this.magFilter=s!==void 0?s:Ht,this.generateMipmaps=!1;const c=this;function l(){c.needsUpdate=!0,e.requestVideoFrameCallback(l)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(l)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Nv.prototype.isVideoTexture=!0;class Dv extends yt{constructor(e,t,n,r,s,o,a,u,h,c,l,f){super(null,o,a,u,h,c,r,s,l,f);this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}Dv.prototype.isCompressedTexture=!0;class Iv extends yt{constructor(e,t,n,r,s,o,a,u,h){super(e,t,n,r,s,o,a,u,h);this.needsUpdate=!0}}Iv.prototype.isCanvasTexture=!0;new P;new P;new P;new ot;class Gt{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,r=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)n=this.getPoint(o/e),s+=n.distanceTo(r),t.push(s),r=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let r=0;const s=n.length;let o;t?o=t:o=e*n[s-1];let a=0,u=s-1,h;for(;a<=u;)if(r=Math.floor(a+(u-a)/2),h=n[r]-o,h<0)a=r+1;else if(h>0)u=r-1;else{u=r;break}if(r=u,n[r]===o)return r/(s-1);const c=n[r],f=n[r+1]-c,d=(o-c)/f;return(r+d)/(s-1)}getTangent(e,t){let r=e-1e-4,s=e+1e-4;r<0&&(r=0),s>1&&(s=1);const o=this.getPoint(r),a=this.getPoint(s),u=t||(o.isVector2?new le:new P);return u.copy(a).sub(o).normalize(),u}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new P,r=[],s=[],o=[],a=new P,u=new Re;for(let d=0;d<=e;d++){const v=d/e;r[d]=this.getTangentAt(v,new P)}s[0]=new P,o[0]=new P;let h=Number.MAX_VALUE;const c=Math.abs(r[0].x),l=Math.abs(r[0].y),f=Math.abs(r[0].z);c<=h&&(h=c,n.set(1,0,0)),l<=h&&(h=l,n.set(0,1,0)),f<=h&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),s[0].crossVectors(r[0],a),o[0].crossVectors(r[0],s[0]);for(let d=1;d<=e;d++){if(s[d]=s[d-1].clone(),o[d]=o[d-1].clone(),a.crossVectors(r[d-1],r[d]),a.length()>Number.EPSILON){a.normalize();const v=Math.acos(Ot(r[d-1].dot(r[d]),-1,1));s[d].applyMatrix4(u.makeRotationAxis(a,v))}o[d].crossVectors(r[d],s[d])}if(t===!0){let d=Math.acos(Ot(s[0].dot(s[e]),-1,1));d/=e,r[0].dot(a.crossVectors(s[0],s[e]))>0&&(d=-d);for(let v=1;v<=e;v++)s[v].applyMatrix4(u.makeRotationAxis(r[v],d*v)),o[v].crossVectors(r[v],s[v])}return{tangents:r,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Ds extends Gt{constructor(e=0,t=0,n=1,r=1,s=0,o=Math.PI*2,a=!1,u=0){super();this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=u}getPoint(e,t){const n=t||new le,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(o?s=0:s=r),this.aClockwise===!0&&!o&&(s===r?s=-r:s=s-r);const a=this.aStartAngle+e*s;let u=this.aX+this.xRadius*Math.cos(a),h=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const c=Math.cos(this.aRotation),l=Math.sin(this.aRotation),f=u-this.aX,d=h-this.aY;u=f*c-d*l+this.aX,h=f*l+d*c+this.aY}return n.set(u,h)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Ds.prototype.isEllipseCurve=!0;class iu extends Ds{constructor(e,t,n,r,s,o){super(e,t,n,n,r,s,o);this.type="ArcCurve"}}iu.prototype.isArcCurve=!0;function wa(){let i=0,e=0,t=0,n=0;function r(s,o,a,u){i=s,e=a,t=-3*s+3*o-2*a-u,n=2*s-2*o+a+u}return{initCatmullRom:function(s,o,a,u,h){r(o,a,h*(a-s),h*(u-o))},initNonuniformCatmullRom:function(s,o,a,u,h,c,l){let f=(o-s)/h-(a-s)/(h+c)+(a-o)/c,d=(a-o)/c-(u-o)/(c+l)+(u-a)/l;f*=c,d*=c,r(o,a,f,d)},calc:function(s){const o=s*s,a=o*s;return i+e*s+t*o+n*a}}}const is=new P,Lo=new wa,Ro=new wa,Po=new wa;class ru extends Gt{constructor(e=[],t=!1,n="centripetal",r=.5){super();this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=r}getPoint(e,t=new P){const n=t,r=this.points,s=r.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),u=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:u===0&&a===s-1&&(a=s-2,u=1);let h,c;this.closed||a>0?h=r[(a-1)%s]:(is.subVectors(r[0],r[1]).add(r[0]),h=is);const l=r[a%s],f=r[(a+1)%s];if(this.closed||a+2<s?c=r[(a+2)%s]:(is.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=is),this.curveType==="centripetal"||this.curveType==="chordal"){const d=this.curveType==="chordal"?.5:.25;let v=Math.pow(h.distanceToSquared(l),d),m=Math.pow(l.distanceToSquared(f),d),y=Math.pow(f.distanceToSquared(c),d);m<1e-4&&(m=1),v<1e-4&&(v=m),y<1e-4&&(y=m),Lo.initNonuniformCatmullRom(h.x,l.x,f.x,c.x,v,m,y),Ro.initNonuniformCatmullRom(h.y,l.y,f.y,c.y,v,m,y),Po.initNonuniformCatmullRom(h.z,l.z,f.z,c.z,v,m,y)}else this.curveType==="catmullrom"&&(Lo.initCatmullRom(h.x,l.x,f.x,c.x,this.tension),Ro.initCatmullRom(h.y,l.y,f.y,c.y,this.tension),Po.initCatmullRom(h.z,l.z,f.z,c.z,this.tension));return n.set(Lo.calc(u),Ro.calc(u),Po.calc(u)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new P().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}ru.prototype.isCatmullRomCurve3=!0;function ec(i,e,t,n,r){const s=(n-e)*.5,o=(r-t)*.5,a=i*i,u=i*a;return(2*t-2*n+s+o)*u+(-3*t+3*n-2*s-o)*a+s*i+t}function Fv(i,e){const t=1-i;return t*t*e}function zv(i,e){return 2*(1-i)*i*e}function Ov(i,e){return i*i*e}function lr(i,e,t,n){return Fv(i,e)+zv(i,t)+Ov(i,n)}function Bv(i,e){const t=1-i;return t*t*t*e}function Uv(i,e){const t=1-i;return 3*t*t*i*e}function Hv(i,e){return 3*(1-i)*i*i*e}function Vv(i,e){return i*i*i*e}function cr(i,e,t,n,r){return Bv(i,e)+Uv(i,t)+Hv(i,n)+Vv(i,r)}class Ma extends Gt{constructor(e=new le,t=new le,n=new le,r=new le){super();this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new le){const n=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set(cr(e,r.x,s.x,o.x,a.x),cr(e,r.y,s.y,o.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Ma.prototype.isCubicBezierCurve=!0;class su extends Gt{constructor(e=new P,t=new P,n=new P,r=new P){super();this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new P){const n=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set(cr(e,r.x,s.x,o.x,a.x),cr(e,r.y,s.y,o.y,a.y),cr(e,r.z,s.z,o.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}su.prototype.isCubicBezierCurve3=!0;class Is extends Gt{constructor(e=new le,t=new le){super();this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new le){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new le;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Is.prototype.isLineCurve=!0;class Gv extends Gt{constructor(e=new P,t=new P){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new P){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class ba extends Gt{constructor(e=new le,t=new le,n=new le){super();this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new le){const n=t,r=this.v0,s=this.v1,o=this.v2;return n.set(lr(e,r.x,s.x,o.x),lr(e,r.y,s.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ba.prototype.isQuadraticBezierCurve=!0;class ou extends Gt{constructor(e=new P,t=new P,n=new P){super();this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new P){const n=t,r=this.v0,s=this.v1,o=this.v2;return n.set(lr(e,r.x,s.x,o.x),lr(e,r.y,s.y,o.y),lr(e,r.z,s.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ou.prototype.isQuadraticBezierCurve3=!0;class Sa extends Gt{constructor(e=[]){super();this.type="SplineCurve",this.points=e}getPoint(e,t=new le){const n=t,r=this.points,s=(r.length-1)*e,o=Math.floor(s),a=s-o,u=r[o===0?o:o-1],h=r[o],c=r[o>r.length-2?r.length-1:o+1],l=r[o>r.length-3?r.length-1:o+2];return n.set(ec(a,u.x,h.x,c.x,l.x),ec(a,u.y,h.y,c.y,l.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new le().fromArray(r))}return this}}Sa.prototype.isSplineCurve=!0;var au=Object.freeze({__proto__:null,ArcCurve:iu,CatmullRomCurve3:ru,CubicBezierCurve:Ma,CubicBezierCurve3:su,EllipseCurve:Ds,LineCurve:Is,LineCurve3:Gv,QuadraticBezierCurve:ba,QuadraticBezierCurve3:ou,SplineCurve:Sa});class kv extends Gt{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Is(t,e))}getPoint(e,t){const n=e*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=n){const o=r[s]-n,a=this.curves[s],u=a.getLength(),h=u===0?0:1-o/u;return a.getPointAt(h,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const o=s[r],a=o&&o.isEllipseCurve?e*2:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?e*o.points.length:e,u=o.getPoints(a);for(let h=0;h<u.length;h++){const c=u[h];n&&n.equals(c)||(t.push(c),n=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(new au[r.type]().fromJSON(r))}return this}}class Yo extends kv{constructor(e){super();this.type="Path",this.currentPoint=new le,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Is(this.currentPoint.clone(),new le(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,r){const s=new ba(this.currentPoint.clone(),new le(e,t),new le(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(e,t,n,r,s,o){const a=new Ma(this.currentPoint.clone(),new le(e,t),new le(n,r),new le(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new Sa(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,r,s,o){const a=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(e+a,t+u,n,r,s,o),this}absarc(e,t,n,r,s,o){return this.absellipse(e,t,n,n,r,s,o),this}ellipse(e,t,n,r,s,o,a,u){const h=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+h,t+c,n,r,s,o,a,u),this}absellipse(e,t,n,r,s,o,a,u){const h=new Ds(e,t,n,r,s,o,a,u);if(this.curves.length>0){const l=h.getPoint(0);l.equals(this.currentPoint)||this.lineTo(l.x,l.y)}this.curves.push(h);const c=h.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Er extends Yo{constructor(e){super(e);this.uuid=en(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(new Yo().fromJSON(r))}return this}}const Wv={triangulate:function(i,e,t=2){const n=e&&e.length,r=n?e[0]*t:i.length;let s=lu(i,0,r,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,u,h,c,l,f,d;if(n&&(s=jv(i,e,s,t)),i.length>80*t){a=h=i[0],u=c=i[1];for(let v=t;v<r;v+=t)l=i[v],f=i[v+1],l<a&&(a=l),f<u&&(u=f),l>h&&(h=l),f>c&&(c=f);d=Math.max(h-a,c-u),d=d!==0?1/d:0}return mr(s,o,t,a,u,d),o}};function lu(i,e,t,n,r){let s,o;if(r===o0(i,e,t,n)>0)for(s=e;s<t;s+=n)o=tc(s,i[s],i[s+1],o);else for(s=t-n;s>=e;s-=n)o=tc(s,i[s],i[s+1],o);return o&&Fs(o,o.next)&&(vr(o),o=o.next),o}function Dn(i,e){if(!i)return i;e||(e=i);let t=i,n;do if(n=!1,!t.steiner&&(Fs(t,t.next)||Ke(t.prev,t,t.next)===0)){if(vr(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function mr(i,e,t,n,r,s,o){if(!i)return;!o&&s&&e0(i,n,r,s);let a=i,u,h;for(;i.prev!==i.next;){if(u=i.prev,h=i.next,s?Xv(i,n,r,s):qv(i)){e.push(u.i/t),e.push(i.i/t),e.push(h.i/t),vr(i),i=h.next,a=h.next;continue}if(i=h,i===a){o?o===1?(i=Zv(Dn(i),e,t),mr(i,e,t,n,r,s,2)):o===2&&Yv(i,e,t,n,r,s):mr(Dn(i),e,t,n,r,s,1);break}}}function qv(i){const e=i.prev,t=i,n=i.next;if(Ke(e,t,n)>=0)return!1;let r=i.next.next;for(;r!==i.prev;){if(bi(e.x,e.y,t.x,t.y,n.x,n.y,r.x,r.y)&&Ke(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Xv(i,e,t,n){const r=i.prev,s=i,o=i.next;if(Ke(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,u=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,h=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,c=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,l=jo(a,u,e,t,n),f=jo(h,c,e,t,n);let d=i.prevZ,v=i.nextZ;for(;d&&d.z>=l&&v&&v.z<=f;){if(d!==i.prev&&d!==i.next&&bi(r.x,r.y,s.x,s.y,o.x,o.y,d.x,d.y)&&Ke(d.prev,d,d.next)>=0||(d=d.prevZ,v!==i.prev&&v!==i.next&&bi(r.x,r.y,s.x,s.y,o.x,o.y,v.x,v.y)&&Ke(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;d&&d.z>=l;){if(d!==i.prev&&d!==i.next&&bi(r.x,r.y,s.x,s.y,o.x,o.y,d.x,d.y)&&Ke(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;v&&v.z<=f;){if(v!==i.prev&&v!==i.next&&bi(r.x,r.y,s.x,s.y,o.x,o.y,v.x,v.y)&&Ke(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Zv(i,e,t){let n=i;do{const r=n.prev,s=n.next.next;!Fs(r,s)&&cu(r,n,n.next,s)&&gr(r,s)&&gr(s,r)&&(e.push(r.i/t),e.push(n.i/t),e.push(s.i/t),vr(n),vr(n.next),n=i=s),n=n.next}while(n!==i);return Dn(n)}function Yv(i,e,t,n,r,s){let o=i;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&i0(o,a)){let u=uu(o,a);o=Dn(o,o.next),u=Dn(u,u.next),mr(o,e,t,n,r,s),mr(u,e,t,n,r,s);return}a=a.next}o=o.next}while(o!==i)}function jv(i,e,t,n){const r=[];let s,o,a,u,h;for(s=0,o=e.length;s<o;s++)a=e[s]*n,u=s<o-1?e[s+1]*n:i.length,h=lu(i,a,u,n,!1),h===h.next&&(h.steiner=!0),r.push(n0(h));for(r.sort(Jv),s=0;s<r.length;s++)$v(r[s],t),t=Dn(t,t.next);return t}function Jv(i,e){return i.x-e.x}function $v(i,e){if(e=Qv(i,e),e){const t=uu(e,i);Dn(e,e.next),Dn(t,t.next)}}function Qv(i,e){let t=e;const n=i.x,r=i.y;let s=-1/0,o;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const f=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=n&&f>s){if(s=f,f===n){if(r===t.y)return t;if(r===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(n===s)return o;const a=o,u=o.x,h=o.y;let c=1/0,l;t=o;do n>=t.x&&t.x>=u&&n!==t.x&&bi(r<h?n:s,r,u,h,r<h?s:n,r,t.x,t.y)&&(l=Math.abs(r-t.y)/(n-t.x),gr(t,i)&&(l<c||l===c&&(t.x>o.x||t.x===o.x&&Kv(o,t)))&&(o=t,c=l)),t=t.next;while(t!==a);return o}function Kv(i,e){return Ke(i.prev,i,e.prev)<0&&Ke(e.next,i,i.next)<0}function e0(i,e,t,n){let r=i;do r.z===null&&(r.z=jo(r.x,r.y,e,t,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==i);r.prevZ.nextZ=null,r.prevZ=null,t0(r)}function t0(i){let e,t,n,r,s,o,a,u,h=1;do{for(t=i,i=null,s=null,o=0;t;){for(o++,n=t,a=0,e=0;e<h&&(a++,n=n.nextZ,!!n);e++);for(u=h;a>0||u>0&&n;)a!==0&&(u===0||!n||t.z<=n.z)?(r=t,t=t.nextZ,a--):(r=n,n=n.nextZ,u--),s?s.nextZ=r:i=r,r.prevZ=s,s=r;t=n}s.nextZ=null,h*=2}while(o>1);return i}function jo(i,e,t,n,r){return i=32767*(i-t)*r,e=32767*(e-n)*r,i=(i|i<<8)&16711935,i=(i|i<<4)&252645135,i=(i|i<<2)&858993459,i=(i|i<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,i|e<<1}function n0(i){let e=i,t=i;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==i);return t}function bi(i,e,t,n,r,s,o,a){return(r-o)*(e-a)-(i-o)*(s-a)>=0&&(i-o)*(n-a)-(t-o)*(e-a)>=0&&(t-o)*(s-a)-(r-o)*(n-a)>=0}function i0(i,e){return i.next.i!==e.i&&i.prev.i!==e.i&&!r0(i,e)&&(gr(i,e)&&gr(e,i)&&s0(i,e)&&(Ke(i.prev,i,e.prev)||Ke(i,e.prev,e))||Fs(i,e)&&Ke(i.prev,i,i.next)>0&&Ke(e.prev,e,e.next)>0)}function Ke(i,e,t){return(e.y-i.y)*(t.x-e.x)-(e.x-i.x)*(t.y-e.y)}function Fs(i,e){return i.x===e.x&&i.y===e.y}function cu(i,e,t,n){const r=ss(Ke(i,e,t)),s=ss(Ke(i,e,n)),o=ss(Ke(t,n,i)),a=ss(Ke(t,n,e));return!!(r!==s&&o!==a||r===0&&rs(i,t,e)||s===0&&rs(i,n,e)||o===0&&rs(t,i,n)||a===0&&rs(t,e,n))}function rs(i,e,t){return e.x<=Math.max(i.x,t.x)&&e.x>=Math.min(i.x,t.x)&&e.y<=Math.max(i.y,t.y)&&e.y>=Math.min(i.y,t.y)}function ss(i){return i>0?1:i<0?-1:0}function r0(i,e){let t=i;do{if(t.i!==i.i&&t.next.i!==i.i&&t.i!==e.i&&t.next.i!==e.i&&cu(t,t.next,i,e))return!0;t=t.next}while(t!==i);return!1}function gr(i,e){return Ke(i.prev,i,i.next)<0?Ke(i,e,i.next)>=0&&Ke(i,i.prev,e)>=0:Ke(i,e,i.prev)<0||Ke(i,i.next,e)<0}function s0(i,e){let t=i,n=!1;const r=(i.x+e.x)/2,s=(i.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==i);return n}function uu(i,e){const t=new Jo(i.i,i.x,i.y),n=new Jo(e.i,e.x,e.y),r=i.next,s=e.prev;return i.next=e,e.prev=i,t.next=r,r.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function tc(i,e,t,n){const r=new Jo(i,e,t);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function vr(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function Jo(i,e,t){this.i=i,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function o0(i,e,t,n){let r=0;for(let s=e,o=t-n;s<t;s+=n)r+=(i[o]-i[s])*(i[s+1]+i[o+1]),o=s;return r}class Pn{static area(e){const t=e.length;let n=0;for(let r=t-1,s=0;s<t;r=s++)n+=e[r].x*e[s].y-e[s].x*e[r].y;return n*.5}static isClockWise(e){return Pn.area(e)<0}static triangulateShape(e,t){const n=[],r=[],s=[];nc(e),ic(n,e);let o=e.length;t.forEach(nc);for(let u=0;u<t.length;u++)r.push(o),o+=t[u].length,ic(n,t[u]);const a=Wv.triangulate(n,r);for(let u=0;u<a.length;u+=3)s.push(a.slice(u,u+3));return s}}function nc(i){const e=i.length;e>2&&i[e-1].equals(i[0])&&i.pop()}function ic(i,e){for(let t=0;t<e.length;t++)i.push(e[t].x),i.push(e[t].y)}class Vi extends Ye{constructor(e=new Er([new le(.5,.5),new le(-.5,.5),new le(-.5,-.5),new le(.5,-.5)]),t={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,r=[],s=[];for(let a=0,u=e.length;a<u;a++){const h=e[a];o(h)}this.setAttribute("position",new st(r,3)),this.setAttribute("uv",new st(s,2)),this.computeVertexNormals();function o(a){const u=[],h=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1;let l=t.depth!==void 0?t.depth:1,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:.2,v=t.bevelSize!==void 0?t.bevelSize:d-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const p=t.extrudePath,g=t.UVGenerator!==void 0?t.UVGenerator:a0;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=t.amount);let _,x=!1,M,S,w,C;p&&(_=p.getSpacedPoints(c),x=!0,f=!1,M=p.computeFrenetFrames(c,!1),S=new P,w=new P,C=new P),f||(y=0,d=0,v=0,m=0);const D=a.extractPoints(h);let I=D.shape;const T=D.holes;if(!Pn.isClockWise(I)){I=I.reverse();for(let Z=0,K=T.length;Z<K;Z++){const oe=T[Z];Pn.isClockWise(oe)&&(T[Z]=oe.reverse())}}const O=Pn.triangulateShape(I,T),F=I;for(let Z=0,K=T.length;Z<K;Z++){const oe=T[Z];I=I.concat(oe)}function z(Z,K,oe){return K||console.error("THREE.ExtrudeGeometry: vec does not exist"),K.clone().multiplyScalar(oe).add(Z)}const N=I.length,U=O.length;function Y(Z,K,oe){let me,he,Te;const Le=Z.x-K.x,R=Z.y-K.y,V=oe.x-Z.x,E=oe.y-Z.y,b=Le*Le+R*R,H=Le*E-R*V;if(Math.abs(H)>Number.EPSILON){const G=Math.sqrt(b),ie=Math.sqrt(V*V+E*E),J=K.x-R/G,L=K.y+Le/G,$=oe.x-E/ie,te=oe.y+V/ie,ue=(($-J)*E-(te-L)*V)/(Le*E-R*V);me=J+Le*ue-Z.x,he=L+R*ue-Z.y;const ce=me*me+he*he;if(ce<=2)return new le(me,he);Te=Math.sqrt(ce/2)}else{let G=!1;Le>Number.EPSILON?V>Number.EPSILON&&(G=!0):Le<-Number.EPSILON?V<-Number.EPSILON&&(G=!0):Math.sign(R)===Math.sign(E)&&(G=!0),G?(me=-R,he=Le,Te=Math.sqrt(b)):(me=Le,he=R,Te=Math.sqrt(b/2))}return new le(me/Te,he/Te)}const ee=[];for(let Z=0,K=F.length,oe=K-1,me=Z+1;Z<K;Z++,oe++,me++)oe===K&&(oe=0),me===K&&(me=0),ee[Z]=Y(F[Z],F[oe],F[me]);const k=[];let q,ae=ee.concat();for(let Z=0,K=T.length;Z<K;Z++){const oe=T[Z];q=[];for(let me=0,he=oe.length,Te=he-1,Le=me+1;me<he;me++,Te++,Le++)Te===he&&(Te=0),Le===he&&(Le=0),q[me]=Y(oe[me],oe[Te],oe[Le]);k.push(q),ae=ae.concat(q)}for(let Z=0;Z<y;Z++){const K=Z/y,oe=d*Math.cos(K*Math.PI/2),me=v*Math.sin(K*Math.PI/2)+m;for(let he=0,Te=F.length;he<Te;he++){const Le=z(F[he],ee[he],me);ve(Le.x,Le.y,-oe)}for(let he=0,Te=T.length;he<Te;he++){const Le=T[he];q=k[he];for(let R=0,V=Le.length;R<V;R++){const E=z(Le[R],q[R],me);ve(E.x,E.y,-oe)}}}const se=v+m;for(let Z=0;Z<N;Z++){const K=f?z(I[Z],ae[Z],se):I[Z];x?(w.copy(M.normals[0]).multiplyScalar(K.x),S.copy(M.binormals[0]).multiplyScalar(K.y),C.copy(_[0]).add(w).add(S),ve(C.x,C.y,C.z)):ve(K.x,K.y,0)}for(let Z=1;Z<=c;Z++)for(let K=0;K<N;K++){const oe=f?z(I[K],ae[K],se):I[K];x?(w.copy(M.normals[Z]).multiplyScalar(oe.x),S.copy(M.binormals[Z]).multiplyScalar(oe.y),C.copy(_[Z]).add(w).add(S),ve(C.x,C.y,C.z)):ve(oe.x,oe.y,l/c*Z)}for(let Z=y-1;Z>=0;Z--){const K=Z/y,oe=d*Math.cos(K*Math.PI/2),me=v*Math.sin(K*Math.PI/2)+m;for(let he=0,Te=F.length;he<Te;he++){const Le=z(F[he],ee[he],me);ve(Le.x,Le.y,l+oe)}for(let he=0,Te=T.length;he<Te;he++){const Le=T[he];q=k[he];for(let R=0,V=Le.length;R<V;R++){const E=z(Le[R],q[R],me);x?ve(E.x,E.y+_[c-1].y,_[c-1].x+oe):ve(E.x,E.y,l+oe)}}}de(),Se();function de(){const Z=r.length/3;if(f){let K=0,oe=N*K;for(let me=0;me<U;me++){const he=O[me];xe(he[2]+oe,he[1]+oe,he[0]+oe)}K=c+y*2,oe=N*K;for(let me=0;me<U;me++){const he=O[me];xe(he[0]+oe,he[1]+oe,he[2]+oe)}}else{for(let K=0;K<U;K++){const oe=O[K];xe(oe[2],oe[1],oe[0])}for(let K=0;K<U;K++){const oe=O[K];xe(oe[0]+N*c,oe[1]+N*c,oe[2]+N*c)}}n.addGroup(Z,r.length/3-Z,0)}function Se(){const Z=r.length/3;let K=0;Q(F,K),K+=F.length;for(let oe=0,me=T.length;oe<me;oe++){const he=T[oe];Q(he,K),K+=he.length}n.addGroup(Z,r.length/3-Z,1)}function Q(Z,K){let oe=Z.length;for(;--oe>=0;){const me=oe;let he=oe-1;he<0&&(he=Z.length-1);for(let Te=0,Le=c+y*2;Te<Le;Te++){const R=N*Te,V=N*(Te+1),E=K+me+R,b=K+he+R,H=K+he+V,G=K+me+V;fe(E,b,H,G)}}}function ve(Z,K,oe){u.push(Z),u.push(K),u.push(oe)}function xe(Z,K,oe){pe(Z),pe(K),pe(oe);const me=r.length/3,he=g.generateTopUV(n,r,me-3,me-2,me-1);Pe(he[0]),Pe(he[1]),Pe(he[2])}function fe(Z,K,oe,me){pe(Z),pe(K),pe(me),pe(K),pe(oe),pe(me);const he=r.length/3,Te=g.generateSideWallUV(n,r,he-6,he-3,he-2,he-1);Pe(Te[0]),Pe(Te[1]),Pe(Te[3]),Pe(Te[1]),Pe(Te[2]),Pe(Te[3])}function pe(Z){r.push(u[Z*3+0]),r.push(u[Z*3+1]),r.push(u[Z*3+2])}function Pe(Z){s.push(Z.x),s.push(Z.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return l0(t,n,e)}static fromJSON(e,t){const n=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];n.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new au[r.type]().fromJSON(r)),new Vi(n,e.options)}}const a0={generateTopUV:function(i,e,t,n,r){const s=e[t*3],o=e[t*3+1],a=e[n*3],u=e[n*3+1],h=e[r*3],c=e[r*3+1];return[new le(s,o),new le(a,u),new le(h,c)]},generateSideWallUV:function(i,e,t,n,r,s){const o=e[t*3],a=e[t*3+1],u=e[t*3+2],h=e[n*3],c=e[n*3+1],l=e[n*3+2],f=e[r*3],d=e[r*3+1],v=e[r*3+2],m=e[s*3],y=e[s*3+1],p=e[s*3+2];return Math.abs(a-c)<Math.abs(o-h)?[new le(o,1-u),new le(h,1-l),new le(f,1-v),new le(m,1-p)]:[new le(a,1-u),new le(c,1-l),new le(d,1-v),new le(y,1-p)]}};function l0(i,e,t){if(t.shapes=[],Array.isArray(i))for(let n=0,r=i.length;n<r;n++){const s=i[n];t.shapes.push(s.uuid)}else t.shapes.push(i.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Ea extends Ye{constructor(e=new Er([new le(0,.5),new le(-.5,-.5),new le(.5,-.5)]),t=12){super();this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],r=[],s=[],o=[];let a=0,u=0;if(Array.isArray(e)===!1)h(e);else for(let c=0;c<e.length;c++)h(e[c]),this.addGroup(a,u,c),a+=u,u=0;this.setIndex(n),this.setAttribute("position",new st(r,3)),this.setAttribute("normal",new st(s,3)),this.setAttribute("uv",new st(o,2));function h(c){const l=r.length/3,f=c.extractPoints(t);let d=f.shape;const v=f.holes;Pn.isClockWise(d)===!1&&(d=d.reverse());for(let y=0,p=v.length;y<p;y++){const g=v[y];Pn.isClockWise(g)===!0&&(v[y]=g.reverse())}const m=Pn.triangulateShape(d,v);for(let y=0,p=v.length;y<p;y++){const g=v[y];d=d.concat(g)}for(let y=0,p=d.length;y<p;y++){const g=d[y];r.push(g.x,g.y,0),s.push(0,0,1),o.push(g.x,g.y)}for(let y=0,p=m.length;y<p;y++){const g=m[y],_=g[0]+l,x=g[1]+l,M=g[2]+l;n.push(_,x,M),u+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return c0(t,e)}static fromJSON(e,t){const n=[];for(let r=0,s=e.shapes.length;r<s;r++){const o=t[e.shapes[r]];n.push(o)}return new Ea(n,e.curveSegments)}}function c0(i,e){if(e.shapes=[],Array.isArray(i))for(let t=0,n=i.length;t<n;t++){const r=i[t];e.shapes.push(r.uuid)}else e.shapes.push(i.uuid);return e}class hu extends Ye{constructor(e=1,t=32,n=16,r=0,s=Math.PI*2,o=0,a=Math.PI){super();this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const u=Math.min(o+a,Math.PI);let h=0;const c=[],l=new P,f=new P,d=[],v=[],m=[],y=[];for(let p=0;p<=n;p++){const g=[],_=p/n;let x=0;p==0&&o==0?x=.5/t:p==n&&u==Math.PI&&(x=-.5/t);for(let M=0;M<=t;M++){const S=M/t;l.x=-e*Math.cos(r+S*s)*Math.sin(o+_*a),l.y=e*Math.cos(o+_*a),l.z=e*Math.sin(r+S*s)*Math.sin(o+_*a),v.push(l.x,l.y,l.z),f.copy(l).normalize(),m.push(f.x,f.y,f.z),y.push(S+x,1-_),g.push(h++)}c.push(g)}for(let p=0;p<n;p++)for(let g=0;g<t;g++){const _=c[p][g+1],x=c[p][g],M=c[p+1][g],S=c[p+1][g+1];(p!==0||o>0)&&d.push(_,x,S),(p!==n-1||u<Math.PI)&&d.push(x,M,S)}this.setIndex(d),this.setAttribute("position",new st(v,3)),this.setAttribute("normal",new st(m,3)),this.setAttribute("uv",new st(y,2))}static fromJSON(e){return new hu(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class u0 extends Mt{constructor(e){super();this.type="ShadowMaterial",this.color=new Ee(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}u0.prototype.isShadowMaterial=!0;class fu extends Mt{constructor(e){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ee(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Fi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}fu.prototype.isMeshStandardMaterial=!0;class h0 extends fu{constructor(e){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new le(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ot(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Ee(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Ee(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ee(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}h0.prototype.isMeshPhysicalMaterial=!0;class f0 extends Mt{constructor(e){super();this.type="MeshPhongMaterial",this.color=new Ee(16777215),this.specular=new Ee(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Fi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ss,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}f0.prototype.isMeshPhongMaterial=!0;class d0 extends Mt{constructor(e){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ee(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Fi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}d0.prototype.isMeshToonMaterial=!0;class p0 extends Mt{constructor(e){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Fi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}p0.prototype.isMeshNormalMaterial=!0;class m0 extends Mt{constructor(e){super();this.type="MeshLambertMaterial",this.color=new Ee(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ee(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ss,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}m0.prototype.isMeshLambertMaterial=!0;class g0 extends Mt{constructor(e){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ee(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Fi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}g0.prototype.isMeshMatcapMaterial=!0;class v0 extends Sr{constructor(e){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}v0.prototype.isLineDashedMaterial=!0;const je={arraySlice:function(i,e,t){return je.isTypedArray(i)?new i.constructor(i.subarray(e,t!==void 0?t:i.length)):i.slice(e,t)},convertArray:function(i,e,t){return!i||!t&&i.constructor===e?i:typeof e.BYTES_PER_ELEMENT=="number"?new e(i):Array.prototype.slice.call(i)},isTypedArray:function(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)},getKeyframeOrder:function(i){function e(r,s){return i[r]-i[s]}const t=i.length,n=new Array(t);for(let r=0;r!==t;++r)n[r]=r;return n.sort(e),n},sortedArray:function(i,e,t){const n=i.length,r=new i.constructor(n);for(let s=0,o=0;o!==n;++s){const a=t[s]*e;for(let u=0;u!==e;++u)r[o++]=i[a+u]}return r},flattenJSON:function(i,e,t,n){let r=1,s=i[0];for(;s!==void 0&&s[n]===void 0;)s=i[r++];if(s===void 0)return;let o=s[n];if(o!==void 0)if(Array.isArray(o))do o=s[n],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=i[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[n],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=i[r++];while(s!==void 0);else do o=s[n],o!==void 0&&(e.push(s.time),t.push(o)),s=i[r++];while(s!==void 0)},subclip:function(i,e,t,n,r=30){const s=i.clone();s.name=e;const o=[];for(let u=0;u<s.tracks.length;++u){const h=s.tracks[u],c=h.getValueSize(),l=[],f=[];for(let d=0;d<h.times.length;++d){const v=h.times[d]*r;if(!(v<t||v>=n)){l.push(h.times[d]);for(let m=0;m<c;++m)f.push(h.values[d*c+m])}}l.length!==0&&(h.times=je.convertArray(l,h.times.constructor),h.values=je.convertArray(f,h.values.constructor),o.push(h))}s.tracks=o;let a=1/0;for(let u=0;u<s.tracks.length;++u)a>s.tracks[u].times[0]&&(a=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(i,e=0,t=i,n=30){n<=0&&(n=30);const r=t.tracks.length,s=e/n;for(let o=0;o<r;++o){const a=t.tracks[o],u=a.ValueTypeName;if(u==="bool"||u==="string")continue;const h=i.tracks.find(function(p){return p.name===a.name&&p.ValueTypeName===u});if(h===void 0)continue;let c=0;const l=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=l/3);let f=0;const d=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const v=a.times.length-1;let m;if(s<=a.times[0]){const p=c,g=l-c;m=je.arraySlice(a.values,p,g)}else if(s>=a.times[v]){const p=v*l+c,g=p+l-c;m=je.arraySlice(a.values,p,g)}else{const p=a.createInterpolant(),g=c,_=l-c;p.evaluate(s),m=je.arraySlice(p.resultBuffer,g,_)}u==="quaternion"&&new Rt().fromArray(m).normalize().conjugate().toArray(m);const y=h.times.length;for(let p=0;p<y;++p){const g=p*d+f;if(u==="quaternion")Rt.multiplyQuaternionsFlat(h.values,g,m,0,h.values,g);else{const _=d-f*2;for(let x=0;x<_;++x)h.values[g+x]-=m[x]}}}return i.blendMode=Ac,i}};class In{constructor(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],s=t[n-1];e:{t:{let o;n:{i:if(!(e<r)){for(let a=n+2;;){if(r===void 0){if(e<s)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,s)}if(n===a)break;if(s=r,r=t[++n],e<r)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(n=2,s=a);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(n===u)break;if(r=s,s=t[--n-1],e>=s)break t}o=n,n=0;break n}break e}for(;n<o;){const a=n+o>>>1;e<t[a]?o=a:n=a+1}if(r=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(r===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,s,e)}this._cachedIndex=n,this.intervalChanged_(n,s,r)}return this.interpolate_(n,s,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,s=e*r;for(let o=0;o!==r;++o)t[o]=n[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}In.prototype.beforeStart_=In.prototype.copySampleValue_;In.prototype.afterEnd_=In.prototype.copySampleValue_;class y0 extends In{constructor(e,t,n,r){super(e,t,n,r);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:wi,endingEnd:wi}}intervalChanged_(e,t,n){const r=this.parameterPositions;let s=e-2,o=e+1,a=r[s],u=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case Mi:s=e,a=2*t-n;break;case ds:s=r.length-2,a=t+r[s]-r[s+1];break;default:s=e,a=n}if(u===void 0)switch(this.getSettings_().endingEnd){case Mi:o=e,u=2*n-t;break;case ds:o=1,u=n+r[1]-r[0];break;default:o=e-1,u=t}const h=(n-t)*.5,c=this.valueSize;this._weightPrev=h/(t-a),this._weightNext=h/(u-n),this._offsetPrev=s*c,this._offsetNext=o*c}interpolate_(e,t,n,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,u=e*a,h=u-a,c=this._offsetPrev,l=this._offsetNext,f=this._weightPrev,d=this._weightNext,v=(n-t)/(r-t),m=v*v,y=m*v,p=-f*y+2*f*m-f*v,g=(1+f)*y+(-1.5-2*f)*m+(-.5+f)*v+1,_=(-1-d)*y+(1.5+d)*m+.5*v,x=d*y-d*m;for(let M=0;M!==a;++M)s[M]=p*o[c+M]+g*o[h+M]+_*o[u+M]+x*o[l+M];return s}}class du extends In{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,u=e*a,h=u-a,c=(n-t)/(r-t),l=1-c;for(let f=0;f!==a;++f)s[f]=o[h+f]*l+o[u+f]*c;return s}}class _0 extends In{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class rn{constructor(e,t,n,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=je.convertArray(t,this.TimeBufferType),this.values=je.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:je.convertArray(e.times,Array),values:je.convertArray(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(n.interpolation=r)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new _0(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new du(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new y0(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case hs:t=this.InterpolantFactoryMethodDiscrete;break;case fs:t=this.InterpolantFactoryMethodLinear;break;case js:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return hs;case this.InterpolantFactoryMethodLinear:return fs;case this.InterpolantFactoryMethodSmooth:return js}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let s=0,o=r-1;for(;s!==r&&n[s]<e;)++s;for(;o!==-1&&n[o]>t;)--o;if(++o,s!==0||o!==r){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=je.arraySlice(n,s,o),this.values=je.arraySlice(this.values,s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const u=n[a];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,u),e=!1;break}if(o!==null&&o>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,u,o),e=!1;break}o=u}if(r!==void 0&&je.isTypedArray(r))for(let a=0,u=r.length;a!==u;++a){const h=r[a];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,h),e=!1;break}}return e}optimize(){const e=je.arraySlice(this.times),t=je.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===js,s=e.length-1;let o=1;for(let a=1;a<s;++a){let u=!1;const h=e[a],c=e[a+1];if(h!==c&&(a!==1||h!==e[0]))if(r)u=!0;else{const l=a*n,f=l-n,d=l+n;for(let v=0;v!==n;++v){const m=t[l+v];if(m!==t[f+v]||m!==t[d+v]){u=!0;break}}}if(u){if(a!==o){e[o]=e[a];const l=a*n,f=o*n;for(let d=0;d!==n;++d)t[f+d]=t[l+d]}++o}}if(s>0){e[o]=e[s];for(let a=s*n,u=o*n,h=0;h!==n;++h)t[u+h]=t[a+h];++o}return o!==e.length?(this.times=je.arraySlice(e,0,o),this.values=je.arraySlice(t,0,o*n)):(this.times=e,this.values=t),this}clone(){const e=je.arraySlice(this.times,0),t=je.arraySlice(this.values,0),n=this.constructor,r=new n(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}rn.prototype.TimeBufferType=Float32Array;rn.prototype.ValueBufferType=Float32Array;rn.prototype.DefaultInterpolation=fs;class Gi extends rn{}Gi.prototype.ValueTypeName="bool";Gi.prototype.ValueBufferType=Array;Gi.prototype.DefaultInterpolation=hs;Gi.prototype.InterpolantFactoryMethodLinear=void 0;Gi.prototype.InterpolantFactoryMethodSmooth=void 0;class pu extends rn{}pu.prototype.ValueTypeName="color";class ms extends rn{}ms.prototype.ValueTypeName="number";class x0 extends In{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,u=(n-t)/(r-t);let h=e*a;for(let c=h+a;h!==c;h+=4)Rt.slerpFlat(s,0,o,h-a,o,h,u);return s}}class Tr extends rn{InterpolantFactoryMethodLinear(e){return new x0(this.times,this.values,this.getValueSize(),e)}}Tr.prototype.ValueTypeName="quaternion";Tr.prototype.DefaultInterpolation=fs;Tr.prototype.InterpolantFactoryMethodSmooth=void 0;class ki extends rn{}ki.prototype.ValueTypeName="string";ki.prototype.ValueBufferType=Array;ki.prototype.DefaultInterpolation=hs;ki.prototype.InterpolantFactoryMethodLinear=void 0;ki.prototype.InterpolantFactoryMethodSmooth=void 0;class gs extends rn{}gs.prototype.ValueTypeName="vector";class rc{constructor(e,t=-1,n,r=aa){this.name=e,this.tracks=n,this.duration=t,this.blendMode=r,this.uuid=en(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let o=0,a=n.length;o!==a;++o)t.push(M0(n[o]).scale(r));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=n.length;s!==o;++s)t.push(rn.toJSON(n[s]));return r}static CreateFromMorphTargetSequence(e,t,n,r){const s=t.length,o=[];for(let a=0;a<s;a++){let u=[],h=[];u.push((a+s-1)%s,a,(a+1)%s),h.push(0,1,0);const c=je.getKeyframeOrder(u);u=je.sortedArray(u,1,c),h=je.sortedArray(h,1,c),!r&&u[0]===0&&(u.push(s),h.push(h[0])),o.push(new ms(".morphTargetInfluences["+t[a].name+"]",u,h).scale(1/n))}return new this(e,-1,o)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const r=e;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===t)return n[r];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,u=e.length;a<u;a++){const h=e[a],c=h.name.match(s);if(c&&c.length>1){const l=c[1];let f=r[l];f||(r[l]=f=[]),f.push(h)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,n));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(l,f,d,v,m){if(d.length!==0){const y=[],p=[];je.flattenJSON(d,y,p,v),y.length!==0&&m.push(new l(f,y,p))}},r=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let u=e.length||-1;const h=e.hierarchy||[];for(let l=0;l<h.length;l++){const f=h[l].keys;if(!(!f||f.length===0))if(f[0].morphTargets){const d={};let v;for(v=0;v<f.length;v++)if(f[v].morphTargets)for(let m=0;m<f[v].morphTargets.length;m++)d[f[v].morphTargets[m]]=-1;for(const m in d){const y=[],p=[];for(let g=0;g!==f[v].morphTargets.length;++g){const _=f[v];y.push(_.time),p.push(_.morphTarget===m?1:0)}r.push(new ms(".morphTargetInfluence["+m+"]",y,p))}u=d.length*(o||1)}else{const d=".bones["+t[l].name+"]";n(gs,d+".position",f,"pos",r),n(Tr,d+".quaternion",f,"rot",r),n(gs,d+".scale",f,"scl",r)}}return r.length===0?null:new this(s,u,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,r=e.length;n!==r;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function w0(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ms;case"vector":case"vector2":case"vector3":case"vector4":return gs;case"color":return pu;case"quaternion":return Tr;case"bool":case"boolean":return Gi;case"string":return ki}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function M0(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=w0(i.type);if(i.times===void 0){const t=[],n=[];je.flattenJSON(i.keys,t,n,"value"),i.times=t,i.values=n}return e.parse!==void 0?e.parse(i):new e(i.name,i.times,i.values,i.interpolation)}const Ni={enabled:!1,files:{},add:function(i,e){this.enabled!==!1&&(this.files[i]=e)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class b0{constructor(e,t,n){const r=this;let s=!1,o=0,a=0,u;const h=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){a++,s===!1&&r.onStart!==void 0&&r.onStart(c,o,a),s=!0},this.itemEnd=function(c){o++,r.onProgress!==void 0&&r.onProgress(c,o,a),o===a&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return u?u(c):c},this.setURLModifier=function(c){return u=c,this},this.addHandler=function(c,l){return h.push(c,l),this},this.removeHandler=function(c){const l=h.indexOf(c);return l!==-1&&h.splice(l,2),this},this.getHandler=function(c){for(let l=0,f=h.length;l<f;l+=2){const d=h[l],v=h[l+1];if(d.global&&(d.lastIndex=0),d.test(c))return v}return null}}}const S0=new b0;class zn{constructor(e){this.manager=e!==void 0?e:S0,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(r,s){n.load(e,r,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const hn={};class E0 extends zn{constructor(e){super(e)}load(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Ni.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(hn[e]!==void 0){hn[e].push({onLoad:t,onProgress:n,onError:r});return}hn[e]=[],hn[e].push({onLoad:t,onProgress:n,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(o).then(a=>{if(a.status===200||a.status===0){a.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const u=hn[e],h=a.body.getReader(),c=a.headers.get("Content-Length"),l=c?parseInt(c):0,f=l!==0;let d=0;return new ReadableStream({start(v){m();function m(){h.read().then(({done:y,value:p})=>{if(y)v.close();else{d+=p.byteLength;const g=new ProgressEvent("progress",{lengthComputable:f,loaded:d,total:l});for(let _=0,x=u.length;_<x;_++){const M=u[_];M.onProgress&&M.onProgress(g)}v.enqueue(p),m()}})}}})}else throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`)}).then(a=>{const u=new Response(a);switch(this.responseType){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(h=>new DOMParser().parseFromString(h,this.mimeType));case"json":return u.json();default:return u.text()}}).then(a=>{Ni.add(e,a);const u=hn[e];delete hn[e];for(let h=0,c=u.length;h<c;h++){const l=u[h];l.onLoad&&l.onLoad(a)}this.manager.itemEnd(e)}).catch(a=>{const u=hn[e];delete hn[e];for(let h=0,c=u.length;h<c;h++){const l=u[h];l.onError&&l.onError(a)}this.manager.itemError(e),this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class mu extends zn{constructor(e){super(e)}load(e,t,n,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Ni.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=Cs("img");function u(){c(),Ni.add(e,this),t&&t(this),s.manager.itemEnd(e)}function h(l){c(),r&&r(l),s.manager.itemError(e),s.manager.itemEnd(e)}function c(){a.removeEventListener("load",u,!1),a.removeEventListener("error",h,!1)}return a.addEventListener("load",u,!1),a.addEventListener("error",h,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class T0 extends zn{constructor(e){super(e)}load(e,t,n,r){const s=new Ls,o=new mu(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function u(h){o.load(e[h],function(c){s.images[h]=c,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,r)}for(let h=0;h<e.length;++h)u(h);return s}}class A0 extends zn{constructor(e){super(e)}load(e,t,n,r){const s=new yt,o=new mu(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},n,r),s}}class tn extends Ge{constructor(e,t=1){super();this.type="Light",this.color=new Ee(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}tn.prototype.isLight=!0;class C0 extends tn{constructor(e,t,n){super(e,n);this.type="HemisphereLight",this.position.copy(Ge.DefaultUp),this.updateMatrix(),this.groundColor=new Ee(t)}copy(e){return tn.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}C0.prototype.isHemisphereLight=!0;const sc=new Re,oc=new P,ac=new P;class Ta{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new le(512,512),this.map=null,this.mapPass=null,this.matrix=new Re,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Rs,this._frameExtents=new le(1,1),this._viewportCount=1,this._viewports=[new We(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;oc.setFromMatrixPosition(e.matrixWorld),t.position.copy(oc),ac.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(ac),t.updateMatrixWorld(),sc.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(sc),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class gu extends Ta{constructor(){super(new Ct(50,1,.5,500));this.focus=1}updateMatrices(e){const t=this.camera,n=ko*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||r!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=r,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}gu.prototype.isSpotLightShadow=!0;class L0 extends tn{constructor(e,t,n=0,r=Math.PI/3,s=0,o=1){super(e,t);this.type="SpotLight",this.position.copy(Ge.DefaultUp),this.updateMatrix(),this.target=new Ge,this.distance=n,this.angle=r,this.penumbra=s,this.decay=o,this.shadow=new gu}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}L0.prototype.isSpotLight=!0;const lc=new Re,ir=new P,No=new P;class vu extends Ta{constructor(){super(new Ct(90,1,.5,500));this._frameExtents=new le(4,2),this._viewportCount=6,this._viewports=[new We(2,1,1,1),new We(0,1,1,1),new We(3,1,1,1),new We(1,1,1,1),new We(3,0,1,1),new We(1,0,1,1)],this._cubeDirections=[new P(1,0,0),new P(-1,0,0),new P(0,0,1),new P(0,0,-1),new P(0,1,0),new P(0,-1,0)],this._cubeUps=[new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,0,1),new P(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,r=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),ir.setFromMatrixPosition(e.matrixWorld),n.position.copy(ir),No.copy(n.position),No.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(No),n.updateMatrixWorld(),r.makeTranslation(-ir.x,-ir.y,-ir.z),lc.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(lc)}}vu.prototype.isPointLightShadow=!0;class R0 extends tn{constructor(e,t,n=0,r=1){super(e,t);this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new vu}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}R0.prototype.isPointLight=!0;class yu extends Ta{constructor(){super(new ma(-5,5,5,-5,.5,500))}}yu.prototype.isDirectionalLightShadow=!0;class P0 extends tn{constructor(e,t){super(e,t);this.type="DirectionalLight",this.position.copy(Ge.DefaultUp),this.updateMatrix(),this.target=new Ge,this.shadow=new yu}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}P0.prototype.isDirectionalLight=!0;class N0 extends tn{constructor(e,t){super(e,t);this.type="AmbientLight"}}N0.prototype.isAmbientLight=!0;class D0 extends tn{constructor(e,t,n=10,r=10){super(e,t);this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}D0.prototype.isRectAreaLight=!0;class _u{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new P)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*n),t.addScaledVector(o[4],1.092548*(n*r)),t.addScaledVector(o[5],1.092548*(r*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(n*s)),t.addScaledVector(o[8],.546274*(n*n-r*r)),t}getIrradianceAt(e,t){const n=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*n),t.addScaledVector(o[4],2*.429043*n*r),t.addScaledVector(o[5],2*.429043*r*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*n*s),t.addScaledVector(o[8],.429043*(n*n-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const n=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-r*r)}}_u.prototype.isSphericalHarmonics3=!0;class Aa extends tn{constructor(e=new _u,t=1){super(void 0,t);this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}Aa.prototype.isLightProbe=!0;class I0{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class F0 extends Ye{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}F0.prototype.isInstancedBufferGeometry=!0;class z0 extends zn{constructor(e){super(e);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Ni.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){Ni.add(e,u),t&&t(u),s.manager.itemEnd(e)}).catch(function(u){r&&r(u),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}z0.prototype.isImageBitmapLoader=!0;let os;const O0={getContext:function(){return os===void 0&&(os=new(window.AudioContext||window.webkitAudioContext)),os},setContext:function(i){os=i}};class B0 extends zn{constructor(e){super(e)}load(e,t,n,r){const s=this,o=new E0(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{const u=a.slice(0);O0.getContext().decodeAudioData(u,function(c){t(c)})}catch(u){r?r(u):console.error(u),s.manager.itemError(e)}},n,r)}}class U0 extends Aa{constructor(e,t,n=1){super(void 0,n);const r=new Ee().set(e),s=new Ee().set(t),o=new P(r.r,r.g,r.b),a=new P(s.r,s.g,s.b),u=Math.sqrt(Math.PI),h=u*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(u),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(h)}}U0.prototype.isHemisphereLightProbe=!0;class H0 extends Aa{constructor(e,t=1){super(void 0,t);const n=new Ee().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}H0.prototype.isAmbientLightProbe=!0;class V0 extends Ge{constructor(e){super();this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class G0{constructor(e,t,n){this.binding=e,this.valueSize=n;let r,s,o;switch(t){case"quaternion":r=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:r=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,r=this.valueSize,s=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)n[s+a]=n[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(n,s,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,r=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=t*this._origIndex;this._mixBufferRegion(n,r,u,1-s,t)}o>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let u=t,h=t+t;u!==h;++u)if(n[u]!==n[u+t]){a.setValue(n,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let s=n,o=r;s!==o;++s)t[s]=t[r+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,r,s){if(r>=.5)for(let o=0;o!==s;++o)e[t+o]=e[n+o]}_slerp(e,t,n,r){Rt.slerpFlat(e,t,e,t,e,n,r)}_slerpAdditive(e,t,n,r,s){const o=this._workIndex*s;Rt.multiplyQuaternionsFlat(e,o,e,t,e,n),Rt.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,n,r,s){const o=1-r;for(let a=0;a!==s;++a){const u=t+a;e[u]=e[u]*o+e[n+a]*r}}_lerpAdditive(e,t,n,r,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[n+o]*r}}}const Ca="\\[\\]\\.:\\/",k0=new RegExp("["+Ca+"]","g"),La="[^"+Ca+"]",W0="[^"+Ca.replace("\\.","")+"]",q0=/((?:WC+[\/:])*)/.source.replace("WC",La),X0=/(WCOD+)?/.source.replace("WCOD",W0),Z0=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",La),Y0=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",La),j0=new RegExp("^"+q0+X0+Z0+Y0+"$"),J0=["material","materials","bones"];class $0{constructor(e,t,n){const r=n||Ve.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];r!==void 0&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=n.length;r!==s;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class Ve{constructor(e,t,n){this.path=t,this.parsedPath=n||Ve.parseTrackName(t),this.node=Ve.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new Ve.Composite(e,t,n):new Ve(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(k0,"")}static parseTrackName(e){const t=j0.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=n.nodeName.substring(r+1);J0.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const u=n(a.children);if(u)return u}return null},r=n(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let s=t.propertyIndex;if(e||(e=Ve.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let h=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===h){h=c;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(h!==void 0){if(e[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[h]}}const o=e[r];if(o===void 0){const h=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(u=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ve.Composite=$0;Ve.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ve.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ve.prototype.GetterByBindingType=[Ve.prototype._getValue_direct,Ve.prototype._getValue_array,Ve.prototype._getValue_arrayElement,Ve.prototype._getValue_toArray];Ve.prototype.SetterByBindingTypeAndVersioning=[[Ve.prototype._setValue_direct,Ve.prototype._setValue_direct_setNeedsUpdate,Ve.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ve.prototype._setValue_array,Ve.prototype._setValue_array_setNeedsUpdate,Ve.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ve.prototype._setValue_arrayElement,Ve.prototype._setValue_arrayElement_setNeedsUpdate,Ve.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ve.prototype._setValue_fromArray,Ve.prototype._setValue_fromArray_setNeedsUpdate,Ve.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Q0{constructor(e,t,n=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=r;const s=t.tracks,o=s.length,a=new Array(o),u={endingStart:wi,endingEnd:wi};for(let h=0;h!==o;++h){const c=s[h].createInterpolant(null);a[h]=c,c.settings=u}this._interpolantSettings=u,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=If,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const r=this._clip.duration,s=e._clip.duration,o=s/r,a=r/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const u=a.parameterPositions,h=a.sampleValues;return u[0]=s,u[1]=s+n,h[0]=e/o,h[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const u=(e-s)*n;if(u<0||n===0)return;this._startTime=null,t=n*u}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const u=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case Ac:for(let c=0,l=u.length;c!==l;++c)u[c].evaluate(o),h[c].accumulateAdditive(a);break;case aa:default:for(let c=0,l=u.length;c!==l;++c)u[c].evaluate(o),h[c].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(e)[0];t*=r,e>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let r=this.time+e,s=this._loopCount;const o=n===Ff;if(e===0)return s===-1?r:o&&(s&1)===1?t-r:r;if(n===Df){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,s+=Math.abs(a);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(u===1){const h=e<0;this._setEndings(h,!h,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;n?(r.endingStart=Mi,r.endingEnd=Mi):(e?r.endingStart=this.zeroSlopeAtStart?Mi:wi:r.endingStart=ds,t?r.endingEnd=this.zeroSlopeAtEnd?Mi:wi:r.endingEnd=ds)}_scheduleFading(e,t,n){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,u=o.sampleValues;return a[0]=s,u[0]=t,a[1]=s+e,u[1]=n,this}}class K0 extends Qn{constructor(e){super();this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,s=r.length,o=e._propertyBindings,a=e._interpolants,u=n.uuid,h=this._bindingsByRootAndName;let c=h[u];c===void 0&&(c={},h[u]=c);for(let l=0;l!==s;++l){const f=r[l],d=f.name;let v=c[d];if(v!==void 0)o[l]=v;else{if(v=o[l],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,u,d));continue}const m=t&&t._propertyBindings[l].binding.parsedPath;v=new G0(Ve.create(n,d,m),f.ValueTypeName,f.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,u,d),o[l]=v}a[l].resultBuffer=v.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,r=e._clip.uuid,s=this._actionsByClip[r];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,r,n)}const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const r=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r,t[r]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],u=a.knownActions,h=u[u.length-1],c=e._byClipCacheIndex;h._byClipCacheIndex=c,u[c]=h,u.pop(),e._byClipCacheIndex=null;const l=a.actionByRoot,f=(e._localRoot||this._root).uuid;delete l[f],u.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const s=t[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const r=this._bindingsByRootAndName,s=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,s=n.path,o=this._bindingsByRootAndName,a=o[r],u=t[t.length-1],h=e._cacheIndex;u._cacheIndex=h,t[h]=u,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new du(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,s=t[r];e.__cacheIndex=r,t[r]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const r=t||this._root,s=r.uuid;let o=typeof e=="string"?rc.findByName(r,e):e;const a=o!==null?o.uuid:e,u=this._actionsByClip[a];let h=null;if(n===void 0&&(o!==null?n=o.blendMode:n=aa),u!==void 0){const l=u.actionByRoot[s];if(l!==void 0&&l.blendMode===n)return l;h=u.knownActions[0],o===null&&(o=h._clip)}if(o===null)return null;const c=new Q0(this,o,t,n);return this._bindAction(c,h),this._addInactiveAction(c,a,s),c}existingAction(e,t){const n=t||this._root,r=n.uuid,s=typeof e=="string"?rc.findByName(n,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let h=0;h!==n;++h)t[h]._update(r,e,s,o);const a=this._bindings,u=this._nActiveBindings;for(let h=0;h!==u;++h)a[h].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,s=r[n];if(s!==void 0){const o=s.knownActions;for(let a=0,u=o.length;a!==u;++a){const h=o[a];this._deactivateAction(h);const c=h._cacheIndex,l=t[t.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,l._cacheIndex=c,t[c]=l,t.pop(),this._removeInactiveBindingsForAction(h)}delete r[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const o in n){const a=n[o].actionByRoot,u=a[t];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const r=this._bindingsByRootAndName,s=r[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}K0.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class ey extends br{constructor(e,t,n=1){super(e,t);this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}ey.prototype.isInstancedInterleavedBuffer=!0;const Sn=new P,as=new Re,Do=new Re;class ty extends xa{constructor(e){const t=xu(e),n=new Ye,r=[],s=[],o=new Ee(0,0,1),a=new Ee(0,1,0);for(let h=0;h<t.length;h++){const c=t[h];c.parent&&c.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}n.setAttribute("position",new st(r,3)),n.setAttribute("color",new st(s,3));const u=new Sr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,r=n.getAttribute("position");Do.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(as.multiplyMatrices(Do,a.matrixWorld),Sn.setFromMatrixPosition(as),r.setXYZ(o,Sn.x,Sn.y,Sn.z),as.multiplyMatrices(Do,a.parent.matrixWorld),Sn.setFromMatrixPosition(as),r.setXYZ(o+1,Sn.x,Sn.y,Sn.z),o+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function xu(i){const e=[];i&&i.isBone&&e.push(i);for(let t=0;t<i.children.length;t++)e.push.apply(e,xu(i.children[t]));return e}class ny extends xa{constructor(e=10,t=10,n=4473924,r=8947848){n=new Ee(n),r=new Ee(r);const s=t/2,o=e/t,a=e/2,u=[],h=[];for(let f=0,d=0,v=-a;f<=t;f++,v+=o){u.push(-a,0,v,a,0,v),u.push(v,0,-a,v,0,a);const m=f===s?n:r;m.toArray(h,d),d+=3,m.toArray(h,d),d+=3,m.toArray(h,d),d+=3,m.toArray(h,d),d+=3}const c=new Ye;c.setAttribute("position",new st(u,3)),c.setAttribute("color",new st(h,3));const l=new Sr({vertexColors:!0,toneMapped:!1});super(c,l);this.type="GridHelper"}}const iy=new Float32Array(1);new Int32Array(iy.buffer);Gt.create=function(i,e){return console.log("THREE.Curve.create() has been deprecated"),i.prototype=Object.create(Gt.prototype),i.prototype.constructor=i,i.prototype.getPoint=e,i};Yo.prototype.fromPoints=function(i){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(i)};ny.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};ty.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};zn.prototype.extractUrlBase=function(i){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),I0.extractUrlBase(i)};zn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Jt.prototype.center=function(i){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(i)};Jt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Jt.prototype.isIntersectionBox=function(i){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};Jt.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};Jt.prototype.size=function(i){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(i)};Oi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Rs.prototype.setFromMatrix=function(i){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(i)};gt.prototype.flattenToArrayOffset=function(i,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,e)};gt.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};gt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};gt.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};gt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};gt.prototype.getInverse=function(i){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};Re.prototype.extractPosition=function(i){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(i)};Re.prototype.flattenToArrayOffset=function(i,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,e)};Re.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new P().setFromMatrixColumn(this,3)};Re.prototype.setRotationFromQuaternion=function(i){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(i)};Re.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Re.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.multiplyVector4=function(i){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Re.prototype.rotateAxis=function(i){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),i.transformDirection(this)};Re.prototype.crossVector=function(i){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Re.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Re.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Re.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Re.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Re.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};Re.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Re.prototype.makeFrustum=function(i,e,t,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(i,e,n,t,r,s)};Re.prototype.getInverse=function(i){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};fn.prototype.isIntersectionLine=function(i){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(i)};Rt.prototype.multiplyVector3=function(i){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),i.applyQuaternion(this)};Rt.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Bi.prototype.isIntersectionBox=function(i){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};Bi.prototype.isIntersectionPlane=function(i){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(i)};Bi.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};ot.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};ot.prototype.barycoordFromPoint=function(i,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(i,e)};ot.prototype.midpoint=function(i){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(i)};ot.prototypenormal=function(i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(i)};ot.prototype.plane=function(i){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(i)};ot.barycoordFromPoint=function(i,e,t,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ot.getBarycoord(i,e,t,n,r)};ot.normal=function(i,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ot.getNormal(i,e,t,n)};Er.prototype.extractAllPoints=function(i){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(i)};Er.prototype.extrude=function(i){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Vi(this,i)};Er.prototype.makeGeometry=function(i){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Ea(this,i)};le.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};le.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};le.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};P.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};P.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};P.prototype.getPositionFromMatrix=function(i){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(i)};P.prototype.getScaleFromMatrix=function(i){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(i)};P.prototype.getColumnFromMatrix=function(i,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,i)};P.prototype.applyProjection=function(i){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(i)};P.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};P.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};P.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};We.prototype.fromAttribute=function(i,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,e,t)};We.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Ge.prototype.getChildByName=function(i){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(i)};Ge.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Ge.prototype.translate=function(i,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,i)};Ge.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Ge.prototype.applyMatrix=function(i){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(Ge.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(i){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=i}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Lt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Lt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),zf},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});tu.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Ct.prototype.setLens=function(i,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(i)};Object.defineProperties(tn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(i){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=i}},shadowCameraLeft:{set:function(i){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=i}},shadowCameraRight:{set:function(i){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=i}},shadowCameraTop:{set:function(i){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=i}},shadowCameraBottom:{set:function(i){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=i}},shadowCameraNear:{set:function(i){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=i}},shadowCameraFar:{set:function(i){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=i}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(i){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=i}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(i){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=i}},shadowMapHeight:{set:function(i){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=i}}});Object.defineProperties(ct.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===ps},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(ps)}}});ct.prototype.setDynamic=function(i){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?ps:dr),this};ct.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ct.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Ye.prototype.addIndex=function(i){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(i)};Ye.prototype.addAttribute=function(i,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(i,new ct(arguments[1],arguments[2]))):i==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(i,e)};Ye.prototype.addDrawCall=function(i,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(i,e)};Ye.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Ye.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Ye.prototype.removeAttribute=function(i){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(i)};Ye.prototype.applyMatrix=function(i){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(Ye.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});br.prototype.setDynamic=function(i){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?ps:dr),this};br.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Vi.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Vi.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Vi.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Qc.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Mt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ee}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(i){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===bc}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(i){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=i}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(jn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(i){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=i}}});ke.prototype.clearTarget=function(i,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(i),this.clear(e,t,n)};ke.prototype.animate=function(i){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(i)};ke.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};ke.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};ke.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};ke.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};ke.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};ke.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};ke.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};ke.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};ke.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};ke.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};ke.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};ke.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};ke.prototype.enableScissorTest=function(i){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(i)};ke.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};ke.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};ke.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};ke.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};ke.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};ke.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};ke.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};ke.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};ke.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};ke.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(ke.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=i}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=i}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(i){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=i===!0?As:Pt}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(Jc.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Vt.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=i}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=i}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=i}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=i}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(i){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=i}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(i){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=i}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(i){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=i}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(i){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=i}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(i){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=i}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(i){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=i}}});V0.prototype.load=function(i){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new B0().load(i,function(n){e.setBuffer(n)}),this};da.prototype.updateCubeMap=function(i,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(i,e)};da.prototype.clear=function(i,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(i,e,t,n)};zi.crossOrigin=void 0;zi.loadTexture=function(i,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new A0;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,t,void 0,n);return e&&(s.mapping=e),s};zi.loadTextureCube=function(i,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new T0;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,t,void 0,n);return e&&(s.mapping=e),s};zi.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};zi.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:sa}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=sa);function $o(){return $o=Object.assign||function(i){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(i[n]=t[n])}return i},$o.apply(this,arguments)}var wu={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null};function it(i){return typeof i=="number"}function Zt(i){return!i||typeof i!="object"||typeof i.constructor!="function"?!1:i.isBigNumber===!0&&typeof i.constructor.prototype=="object"&&i.constructor.prototype.isBigNumber===!0||typeof i.constructor.isDecimal=="function"&&i.constructor.isDecimal(i)===!0}function Ra(i){return i&&typeof i=="object"&&Object.getPrototypeOf(i).isComplex===!0||!1}function Pa(i){return i&&typeof i=="object"&&Object.getPrototypeOf(i).isFraction===!0||!1}function Na(i){return i&&i.constructor.prototype.isUnit===!0||!1}function dn(i){return typeof i=="string"}var $e=Array.isArray;function bt(i){return i&&i.constructor.prototype.isMatrix===!0||!1}function Mu(i){return Array.isArray(i)||bt(i)}function ry(i){return i&&i.isDenseMatrix&&i.constructor.prototype.isMatrix===!0||!1}function sy(i){return i&&i.isSparseMatrix&&i.constructor.prototype.isMatrix===!0||!1}function bu(i){return i&&i.constructor.prototype.isRange===!0||!1}function zs(i){return i&&i.constructor.prototype.isIndex===!0||!1}function oy(i){return typeof i=="boolean"}function Su(i){return i&&i.constructor.prototype.isResultSet===!0||!1}function Eu(i){return i&&i.constructor.prototype.isHelp===!0||!1}function ay(i){return typeof i=="function"}function ly(i){return i instanceof Date}function cy(i){return i instanceof RegExp}function uy(i){return!!(i&&typeof i=="object"&&i.constructor===Object&&!Ra(i)&&!Pa(i))}function hy(i){return i===null}function fy(i){return i===void 0}function dy(i){return i&&i.isAccessorNode===!0&&i.constructor.prototype.isNode===!0||!1}function py(i){return i&&i.isArrayNode===!0&&i.constructor.prototype.isNode===!0||!1}function my(i){return i&&i.isAssignmentNode===!0&&i.constructor.prototype.isNode===!0||!1}function gy(i){return i&&i.isBlockNode===!0&&i.constructor.prototype.isNode===!0||!1}function vy(i){return i&&i.isConditionalNode===!0&&i.constructor.prototype.isNode===!0||!1}function yy(i){return i&&i.isConstantNode===!0&&i.constructor.prototype.isNode===!0||!1}function _y(i){return i&&i.isFunctionAssignmentNode===!0&&i.constructor.prototype.isNode===!0||!1}function xy(i){return i&&i.isFunctionNode===!0&&i.constructor.prototype.isNode===!0||!1}function wy(i){return i&&i.isIndexNode===!0&&i.constructor.prototype.isNode===!0||!1}function Tu(i){return i&&i.isNode===!0&&i.constructor.prototype.isNode===!0||!1}function My(i){return i&&i.isObjectNode===!0&&i.constructor.prototype.isNode===!0||!1}function by(i){return i&&i.isOperatorNode===!0&&i.constructor.prototype.isNode===!0||!1}function Sy(i){return i&&i.isParenthesisNode===!0&&i.constructor.prototype.isNode===!0||!1}function Ey(i){return i&&i.isRangeNode===!0&&i.constructor.prototype.isNode===!0||!1}function Ty(i){return i&&i.isSymbolNode===!0&&i.constructor.prototype.isNode===!0||!1}function Au(i){return i&&i.constructor.prototype.isChain===!0||!1}function ur(i){var e=typeof i;return e==="object"?i===null?"null":Array.isArray(i)?"Array":i instanceof Date?"Date":i instanceof RegExp?"RegExp":Zt(i)?"BigNumber":Ra(i)?"Complex":Pa(i)?"Fraction":bt(i)?"Matrix":Na(i)?"Unit":zs(i)?"Index":bu(i)?"Range":Su(i)?"ResultSet":Tu(i)?i.type:Au(i)?"Chain":Eu(i)?"Help":"Object":e==="function"?"Function":e}function pt(i){var e=typeof i;if(e==="number"||e==="string"||e==="boolean"||i===null||i===void 0)return i;if(typeof i.clone=="function")return i.clone();if(Array.isArray(i))return i.map(function(t){return pt(t)});if(i instanceof Date)return new Date(i.valueOf());if(Zt(i))return i;if(i instanceof RegExp)throw new TypeError("Cannot clone "+i);return Ay(i,pt)}function Ay(i,e){var t={};for(var n in i)yr(i,n)&&(t[n]=e(i[n]));return t}function Cy(i,e){for(var t in e)yr(e,t)&&(i[t]=e[t]);return i}function vs(i,e){var t,n,r;if(Array.isArray(i)){if(!Array.isArray(e)||i.length!==e.length)return!1;for(n=0,r=i.length;n<r;n++)if(!vs(i[n],e[n]))return!1;return!0}else{if(typeof i=="function")return i===e;if(i instanceof Object){if(Array.isArray(e)||!(e instanceof Object))return!1;for(t in i)if(!(t in e)||!vs(i[t],e[t]))return!1;for(t in e)if(!(t in i))return!1;return!0}else return i===e}}function yr(i,e){return i&&Object.hasOwnProperty.call(i,e)}function Ly(i,e){for(var t={},n=0;n<e.length;n++){var r=e[n],s=i[r];s!==void 0&&(t[r]=s)}return t}var Ry=["Matrix","Array"],Py=["number","BigNumber","Fraction"],Os=function(e){if(e)throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);return Object.freeze(wu)};$o(Os,wu,{MATRIX_OPTIONS:Ry,NUMBER_OPTIONS:Py});var Ny=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function Cu(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Lu={exports:{}};(function(i,e){(function(t,n){i.exports=n()})(Ny,function(){function t(){return!0}function n(){return!1}function r(){}function s(){var o=[{name:"number",test:function(R){return typeof R=="number"}},{name:"string",test:function(R){return typeof R=="string"}},{name:"boolean",test:function(R){return typeof R=="boolean"}},{name:"Function",test:function(R){return typeof R=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(R){return R instanceof Date}},{name:"RegExp",test:function(R){return R instanceof RegExp}},{name:"Object",test:function(R){return typeof R=="object"&&R!==null&&R.constructor===Object}},{name:"null",test:function(R){return R===null}},{name:"undefined",test:function(R){return R===void 0}}],a={name:"any",test:t},u=[],h=[],c={types:o,conversions:h,ignore:u};function l(R){var V=oe(c.types,function(b){return b.name===R});if(V)return V;if(R==="any")return a;var E=oe(c.types,function(b){return b.name.toLowerCase()===R.toLowerCase()});throw new TypeError('Unknown type "'+R+'"'+(E?'. Did you mean "'+E.name+'"?':""))}function f(R){return R===a?999:c.types.indexOf(R)}function d(R){var V=oe(c.types,function(E){return E.test(R)});if(V)return V.name;throw new TypeError("Value has unknown type. Value: "+R)}function v(R,V){if(!R.signatures)throw new TypeError("Function is no typed-function");var E;if(typeof V=="string"){E=V.split(",");for(var b=0;b<E.length;b++)E[b]=E[b].trim()}else if(Array.isArray(V))E=V;else throw new TypeError("String array or a comma separated string expected");var H=E.join(","),G=R.signatures[H];if(G)return G;throw new TypeError("Signature not found (signature: "+(R.name||"unnamed")+"("+E.join(", ")+"))")}function m(R,V){var E=d(R);if(V===E)return R;for(var b=0;b<c.conversions.length;b++){var H=c.conversions[b];if(H.from===E&&H.to===V)return H.convert(R)}throw new Error("Cannot convert from "+E+" to "+V)}function y(R){return R.map(function(V){var E=V.types.map(D);return(V.restParam?"...":"")+E.join("|")}).join(",")}function p(R,V){var E=R.indexOf("...")===0,b=E?R.length>3?R.slice(3):"any":R,H=b.split("|").map(Se).filter(Q).filter(de),G=U(V,H),ie=H.map(function(L){var $=l(L);return{name:L,typeIndex:f($),test:$.test,conversion:null,conversionIndex:-1}}),J=G.map(function(L){var $=l(L.from);return{name:L.from,typeIndex:f($),test:$.test,conversion:L,conversionIndex:V.indexOf(L)}});return{types:ie.concat(J),restParam:E}}function g(R,V,E){var b=[];return R.trim()!==""&&(b=R.split(",").map(Se).map(function(H,G,ie){var J=p(H,E);if(J.restParam&&G!==ie.length-1)throw new SyntaxError('Unexpected rest parameter "'+H+'": only allowed for the last parameter');return J})),b.some(xe)?null:{params:b,fn:V}}function _(R){var V=pe(R);return V?V.restParam:!1}function x(R){return R.types.some(function(V){return V.conversion!=null})}function M(R){if(!R||R.types.length===0)return t;if(R.types.length===1)return l(R.types[0].name).test;if(R.types.length===2){var V=l(R.types[0].name).test,E=l(R.types[1].name).test;return function(G){return V(G)||E(G)}}else{var b=R.types.map(function(H){return l(H.name).test});return function(G){for(var ie=0;ie<b.length;ie++)if(b[ie](G))return!0;return!1}}}function S(R){var V,E,b;if(_(R)){V=fe(R).map(M);var H=V.length,G=M(pe(R)),ie=function(J){for(var L=H;L<J.length;L++)if(!G(J[L]))return!1;return!0};return function(L){for(var $=0;$<V.length;$++)if(!V[$](L[$]))return!1;return ie(L)&&L.length>=H+1}}else return R.length===0?function(L){return L.length===0}:R.length===1?(E=M(R[0]),function(L){return E(L[0])&&L.length===1}):R.length===2?(E=M(R[0]),b=M(R[1]),function(L){return E(L[0])&&b(L[1])&&L.length===2}):(V=R.map(M),function(L){for(var $=0;$<V.length;$++)if(!V[$](L[$]))return!1;return L.length===V.length})}function w(R,V){return V<R.params.length?R.params[V]:_(R.params)?pe(R.params):null}function C(R,V,E){var b=w(R,V),H=b?E?b.types.filter(I):b.types:[];return H.map(D)}function D(R){return R.name}function I(R){return R.conversion===null||R.conversion===void 0}function T(R,V){var E=me(he(R,function(b){return C(b,V,!1)}));return E.indexOf("any")!==-1?["any"]:E}function B(R,V,E){var b,H,G=R||"unnamed",ie=E,J;for(J=0;J<V.length;J++){var L=ie.filter(function(ce){var ye=M(w(ce,J));return(J<ce.params.length||_(ce.params))&&ye(V[J])});if(L.length===0){if(H=T(ie,J),H.length>0){var $=d(V[J]);return b=new TypeError("Unexpected type of argument in function "+G+" (expected: "+H.join(" or ")+", actual: "+$+", index: "+J+")"),b.data={category:"wrongType",fn:G,index:J,actual:$,expected:H},b}}else ie=L}var te=ie.map(function(ce){return _(ce.params)?1/0:ce.params.length});if(V.length<Math.min.apply(null,te))return H=T(ie,J),b=new TypeError("Too few arguments in function "+G+" (expected: "+H.join(" or ")+", index: "+V.length+")"),b.data={category:"tooFewArgs",fn:G,index:V.length,expected:H},b;var ue=Math.max.apply(null,te);return V.length>ue?(b=new TypeError("Too many arguments in function "+G+" (expected: "+ue+", actual: "+V.length+")"),b.data={category:"tooManyArgs",fn:G,index:V.length,expectedLength:ue},b):(b=new TypeError('Arguments of type "'+V.join(", ")+'" do not match any of the defined signatures of function '+G+"."),b.data={category:"mismatch",actual:V.map(d)},b)}function O(R){for(var V=999,E=0;E<R.types.length;E++)I(R.types[E])&&(V=Math.min(V,R.types[E].typeIndex));return V}function F(R){for(var V=999,E=0;E<R.types.length;E++)I(R.types[E])||(V=Math.min(V,R.types[E].conversionIndex));return V}function z(R,V){var E;return E=R.restParam-V.restParam,E!==0||(E=x(R)-x(V),E!==0)||(E=O(R)-O(V),E!==0)?E:F(R)-F(V)}function N(R,V){var E=Math.min(R.params.length,V.params.length),b,H;if(H=R.params.some(x)-V.params.some(x),H!==0)return H;for(b=0;b<E;b++)if(H=x(R.params[b])-x(V.params[b]),H!==0)return H;for(b=0;b<E;b++)if(H=z(R.params[b],V.params[b]),H!==0)return H;return R.params.length-V.params.length}function U(R,V){var E={};return R.forEach(function(b){V.indexOf(b.from)===-1&&V.indexOf(b.to)!==-1&&!E[b.from]&&(E[b.from]=b)}),Object.keys(E).map(function(b){return E[b]})}function Y(R,V){var E=V;if(R.some(x)){var b=_(R),H=R.map(ee);E=function(){for(var L=[],$=b?arguments.length-1:arguments.length,te=0;te<$;te++)L[te]=H[te](arguments[te]);return b&&(L[$]=arguments[$].map(H[$])),V.apply(this,L)}}var G=E;if(_(R)){var ie=R.length-1;G=function(){return E.apply(this,Pe(arguments,0,ie).concat([Pe(arguments,ie)]))}}return G}function ee(R){var V,E,b,H,G=[],ie=[];switch(R.types.forEach(function(J){J.conversion&&(G.push(l(J.conversion.from).test),ie.push(J.conversion.convert))}),ie.length){case 0:return function(L){return L};case 1:return V=G[0],b=ie[0],function(L){return V(L)?b(L):L};case 2:return V=G[0],E=G[1],b=ie[0],H=ie[1],function(L){return V(L)?b(L):E(L)?H(L):L};default:return function(L){for(var $=0;$<ie.length;$++)if(G[$](L))return ie[$](L);return L}}}function k(R){var V={};return R.forEach(function(E){E.params.some(x)||q(E.params,!0).forEach(function(b){V[y(b)]=E.fn})}),V}function q(R,V){function E(b,H,G){if(H<b.length){var ie=b[H],J=V?ie.types.filter(I):ie.types,L;if(ie.restParam){var $=J.filter(I);L=$.length<J.length?[$,J]:[J]}else L=J.map(function(ue){return[ue]});return he(L,function(ue){return E(b,H+1,G.concat([ue]))})}else{var te=G.map(function(ue,ce){return{types:ue,restParam:ce===b.length-1&&_(b)}});return[te]}}return E(R,0,[])}function ae(R,V){for(var E=Math.max(R.params.length,V.params.length),b=0;b<E;b++){var H=C(R,b,!0),G=C(V,b,!0);if(!K(H,G))return!1}var ie=R.params.length,J=V.params.length,L=_(R.params),$=_(V.params);return L?$?ie===J:J>=ie:$?ie>=J:ie===J}function se(R,V){if(Object.keys(V).length===0)throw new SyntaxError("No signatures provided");var E=[];Object.keys(V).map(function(_e){return g(_e,V[_e],c.conversions)}).filter(ve).forEach(function(_e){var Me=oe(E,function(Ie){return ae(Ie,_e)});if(Me)throw new TypeError('Conflicting signatures "'+y(Me.params)+'" and "'+y(_e.params)+'".');E.push(_e)});var b=he(E,function(_e){var Me=_e?q(_e.params,!1):[];return Me.map(function(Ie){return{params:Ie,fn:_e.fn}})}).filter(ve);b.sort(N);var H=b[0]&&b[0].params.length<=2&&!_(b[0].params),G=b[1]&&b[1].params.length<=2&&!_(b[1].params),ie=b[2]&&b[2].params.length<=2&&!_(b[2].params),J=b[3]&&b[3].params.length<=2&&!_(b[3].params),L=b[4]&&b[4].params.length<=2&&!_(b[4].params),$=b[5]&&b[5].params.length<=2&&!_(b[5].params),te=H&&G&&ie&&J&&L&&$,ue=b.map(function(_e){return S(_e.params)}),ce=H?M(b[0].params[0]):n,ye=G?M(b[1].params[0]):n,we=ie?M(b[2].params[0]):n,Fe=J?M(b[3].params[0]):n,Je=L?M(b[4].params[0]):n,Ue=$?M(b[5].params[0]):n,Dt=H?M(b[0].params[1]):n,It=G?M(b[1].params[1]):n,ks=ie?M(b[2].params[1]):n,Ar=J?M(b[3].params[1]):n,Cr=L?M(b[4].params[1]):n,sn=$?M(b[5].params[1]):n,$t=b.map(function(_e){return Y(_e.params,_e.fn)}),Lr=H?$t[0]:r,Ws=G?$t[1]:r,Kn=ie?$t[2]:r,qs=J?$t[3]:r,qi=L?$t[4]:r,Rr=$?$t[5]:r,Xs=H?b[0].params.length:-1,Zs=G?b[1].params.length:-1,Ys=ie?b[2].params.length:-1,A=J?b[3].params.length:-1,W=L?b[4].params.length:-1,j=$?b[5].params.length:-1,X=te?6:0,ne=b.length,Ne=function(){for(var Me=X;Me<ne;Me++)if(ue[Me](arguments))return $t[Me].apply(this,arguments);throw B(R,arguments,b)},Ae=function _e(Me,Ie){return arguments.length===Xs&&ce(Me)&&Dt(Ie)?Lr.apply(_e,arguments):arguments.length===Zs&&ye(Me)&&It(Ie)?Ws.apply(_e,arguments):arguments.length===Ys&&we(Me)&&ks(Ie)?Kn.apply(_e,arguments):arguments.length===A&&Fe(Me)&&Ar(Ie)?qs.apply(_e,arguments):arguments.length===W&&Je(Me)&&Cr(Ie)?qi.apply(_e,arguments):arguments.length===j&&Ue(Me)&&sn(Ie)?Rr.apply(_e,arguments):Ne.apply(_e,arguments)};try{Object.defineProperty(Ae,"name",{value:R})}catch{}return Ae.signatures=k(b),Ae}function de(R){return c.ignore.indexOf(R)===-1}function Se(R){return R.trim()}function Q(R){return!!R}function ve(R){return R!==null}function xe(R){return R.types.length===0}function fe(R){return R.slice(0,R.length-1)}function pe(R){return R[R.length-1]}function Pe(R,V,E){return Array.prototype.slice.call(R,V,E)}function Z(R,V){return R.indexOf(V)!==-1}function K(R,V){for(var E=0;E<R.length;E++)if(Z(V,R[E]))return!0;return!1}function oe(R,V){for(var E=0;E<R.length;E++)if(V(R[E]))return R[E]}function me(R){for(var V={},E=0;E<R.length;E++)V[R[E]]=!0;return Object.keys(V)}function he(R,V){return Array.prototype.concat.apply([],R.map(V))}function Te(R){for(var V="",E=0;E<R.length;E++){var b=R[E];if((typeof b.signatures=="object"||typeof b.signature=="string")&&b.name!==""){if(V==="")V=b.name;else if(V!==b.name){var H=new Error("Function names do not match (expected: "+V+", actual: "+b.name+")");throw H.data={actual:b.name,expected:V},H}}}return V}function Le(R){var V,E={};function b(J,L){if(E.hasOwnProperty(J)&&L!==E[J])throw V=new Error('Signature "'+J+'" is defined twice'),V.data={signature:J},V}for(var H=0;H<R.length;H++){var G=R[H];if(typeof G.signatures=="object")for(var ie in G.signatures)G.signatures.hasOwnProperty(ie)&&(b(ie,G.signatures[ie]),E[ie]=G.signatures[ie]);else if(typeof G.signature=="string")b(G.signature,G),E[G.signature]=G;else throw V=new TypeError("Function is no typed-function (index: "+H+")"),V.data={index:H},V}return E}return c=se("typed",{"string, Object":se,Object:function(R){var V=[];for(var E in R)R.hasOwnProperty(E)&&V.push(R[E]);var b=Te(V);return se(b,R)},"...Function":function(R){return se(Te(R),Le(R))},"string, ...Function":function(R,V){return se(R,Le(V))}}),c.create=s,c.types=o,c.conversions=h,c.ignore=u,c.convert=m,c.find=v,c.addType=function(R,V){if(!R||typeof R.name!="string"||typeof R.test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");if(V!==!1){for(var E=0;E<c.types.length;E++)if(c.types[E].name==="Object"){c.types.splice(E,0,R);return}}c.types.push(R)},c.addConversion=function(R){if(!R||typeof R.from!="string"||typeof R.to!="string"||typeof R.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");c.conversions.push(R)},c}return s()})})(Lu);var cc=Lu.exports;function mt(i){return typeof i=="boolean"?!0:isFinite(i)?i===Math.round(i):!1}function Io(i,e,t){var n={2:"0b",8:"0o",16:"0x"},r=n[e],s="";if(t){if(t<1)throw new Error("size must be in greater than 0");if(!mt(t))throw new Error("size must be an integer");if(i>2**(t-1)-1||i<-(2**(t-1)))throw new Error("Value must be in range [-2^".concat(t-1,", 2^").concat(t-1,"-1]"));if(!mt(i))throw new Error("Value must be an integer");i<0&&(i=i+2**t),s="i".concat(t)}var o="";return i<0&&(i=-i,o="-"),"".concat(o).concat(r).concat(i.toString(e)).concat(s)}function Qo(i,e){if(typeof e=="function")return e(i);if(i===1/0)return"Infinity";if(i===-1/0)return"-Infinity";if(isNaN(i))return"NaN";var t="auto",n,r;if(e&&(e.notation&&(t=e.notation),it(e)?n=e:it(e.precision)&&(n=e.precision),e.wordSize&&(r=e.wordSize,typeof r!="number")))throw new Error('Option "wordSize" must be a number');switch(t){case"fixed":return Iy(i,n);case"exponential":return Ru(i,n);case"engineering":return Dy(i,n);case"bin":return Io(i,2,r);case"oct":return Io(i,8,r);case"hex":return Io(i,16,r);case"auto":return Fy(i,n,e&&e).replace(/((\.\d*?)(0+))($|e)/,function(){var s=arguments[2],o=arguments[4];return s!=="."?s+o:o});default:throw new Error('Unknown notation "'+t+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function Bs(i){var e=String(i).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!e)throw new SyntaxError("Invalid number "+i);var t=e[1],n=e[2],r=parseFloat(e[4]||"0"),s=n.indexOf(".");r+=s!==-1?s-1:n.length-1;var o=n.replace(".","").replace(/^0*/,function(a){return r-=a.length,""}).replace(/0*$/,"").split("").map(function(a){return parseInt(a)});return o.length===0&&(o.push(0),r++),{sign:t,coefficients:o,exponent:r}}function Dy(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Bs(i),n=Us(t,e),r=n.exponent,s=n.coefficients,o=r%3===0?r:r<0?r-3-r%3:r-r%3;if(it(e))for(;e>s.length||r-o+1>s.length;)s.push(0);else for(var a=Math.abs(r-o)-(s.length-1),u=0;u<a;u++)s.push(0);for(var h=Math.abs(r-o),c=1;h>0;)c++,h--;var l=s.slice(c).join(""),f=it(e)&&l.length||l.match(/[1-9]/)?"."+l:"",d=s.slice(0,c).join("")+f+"e"+(r>=0?"+":"")+o.toString();return n.sign+d}function Iy(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Bs(i),n=typeof e=="number"?Us(t,t.exponent+1+e):t,r=n.coefficients,s=n.exponent+1,o=s+(e||0);return r.length<o&&(r=r.concat(Ci(o-r.length))),s<0&&(r=Ci(-s+1).concat(r),s=1),s<r.length&&r.splice(s,0,s===0?"0.":"."),n.sign+r.join("")}function Ru(i,e){if(isNaN(i)||!isFinite(i))return String(i);var t=Bs(i),n=e?Us(t,e):t,r=n.coefficients,s=n.exponent;r.length<e&&(r=r.concat(Ci(e-r.length)));var o=r.shift();return n.sign+o+(r.length>0?"."+r.join(""):"")+"e"+(s>=0?"+":"")+s}function Fy(i,e,t){if(isNaN(i)||!isFinite(i))return String(i);var n=t&&t.lowerExp!==void 0?t.lowerExp:-3,r=t&&t.upperExp!==void 0?t.upperExp:5,s=Bs(i),o=e?Us(s,e):s;if(o.exponent<n||o.exponent>=r)return Ru(i,e);var a=o.coefficients,u=o.exponent;a.length<e&&(a=a.concat(Ci(e-a.length))),a=a.concat(Ci(u-a.length+1+(a.length<e?e-a.length:0))),a=Ci(-u).concat(a);var h=u>0?u:0;return h<a.length-1&&a.splice(h+1,0,"."),o.sign+a.join("")}function Us(i,e){for(var t={sign:i.sign,coefficients:i.coefficients,exponent:i.exponent},n=t.coefficients;e<=0;)n.unshift(0),t.exponent++,e++;if(n.length>e){var r=n.splice(e,n.length-e);if(r[0]>=5){var s=e-1;for(n[s]++;n[s]===10;)n.pop(),s===0&&(n.unshift(0),t.exponent++,s++),s--,n[s]++}}return t}function Ci(i){for(var e=[],t=0;t<i;t++)e.push(0);return e}function zy(i){return i.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length}var Oy=Number.EPSILON||2220446049250313e-31;function ys(i,e,t){if(t==null)return i===e;if(i===e)return!0;if(isNaN(i)||isNaN(e))return!1;if(isFinite(i)&&isFinite(e)){var n=Math.abs(i-e);return n<Oy?!0:n<=Math.max(Math.abs(i),Math.abs(e))*t}return!1}function Fo(i,e,t){var n=i.constructor,r=new n(2),s="";if(t){if(t<1)throw new Error("size must be in greater than 0");if(!mt(t))throw new Error("size must be an integer");if(i.greaterThan(r.pow(t-1).sub(1))||i.lessThan(r.pow(t-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(t-1,", 2^").concat(t-1,"-1]"));if(!i.isInteger())throw new Error("Value must be an integer");i.lessThan(0)&&(i=i.add(r.pow(t))),s="i".concat(t)}switch(e){case 2:return"".concat(i.toBinary()).concat(s);case 8:return"".concat(i.toOctal()).concat(s);case 16:return"".concat(i.toHexadecimal()).concat(s);default:throw new Error("Base ".concat(e," not supported "))}}function By(i,e){if(typeof e=="function")return e(i);if(!i.isFinite())return i.isNaN()?"NaN":i.gt(0)?"Infinity":"-Infinity";var t="auto",n,r;if(e!==void 0&&(e.notation&&(t=e.notation),typeof e=="number"?n=e:e.precision&&(n=e.precision),e.wordSize&&(r=e.wordSize,typeof r!="number")))throw new Error('Option "wordSize" must be a number');switch(t){case"fixed":return Hy(i,n);case"exponential":return uc(i,n);case"engineering":return Uy(i,n);case"bin":return Fo(i,2,r);case"oct":return Fo(i,8,r);case"hex":return Fo(i,16,r);case"auto":{var s=e&&e.lowerExp!==void 0?e.lowerExp:-3,o=e&&e.upperExp!==void 0?e.upperExp:5;if(i.isZero())return"0";var a,u=i.toSignificantDigits(n),h=u.e;return h>=s&&h<o?a=u.toFixed():a=uc(i,n),a.replace(/((\.\d*?)(0+))($|e)/,function(){var c=arguments[2],l=arguments[4];return c!=="."?c+l:l})}default:throw new Error('Unknown notation "'+t+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function Uy(i,e){var t=i.e,n=t%3===0?t:t<0?t-3-t%3:t-t%3,r=i.mul(Math.pow(10,-n)),s=r.toPrecision(e);return s.indexOf("e")!==-1&&(s=r.toString()),s+"e"+(t>=0?"+":"")+n.toString()}function uc(i,e){return e!==void 0?i.toExponential(e-1):i.toExponential()}function Hy(i,e){return i.toFixed(e)}function At(i,e){if(typeof i=="number")return Qo(i,e);if(Zt(i))return By(i,e);if(Vy(i))return!e||e.fraction!=="decimal"?i.s*i.n+"/"+i.d:i.toString();if(Array.isArray(i))return Pu(i,e);if(dn(i))return'"'+i+'"';if(typeof i=="function")return i.syntax?String(i.syntax):"function";if(i&&typeof i=="object"){if(typeof i.format=="function")return i.format(e);if(i&&i.toString(e)!=={}.toString())return i.toString(e);var t=Object.keys(i).map(n=>'"'+n+'": '+At(i[n],e));return"{"+t.join(", ")+"}"}return String(i)}function Pu(i,e){if(Array.isArray(i)){for(var t="[",n=i.length,r=0;r<n;r++)r!==0&&(t+=", "),t+=Pu(i[r],e);return t+="]",t}else return At(i,e)}function Vy(i){return i&&typeof i=="object"&&typeof i.s=="number"&&typeof i.n=="number"&&typeof i.d=="number"||!1}function et(i,e,t){if(!(this instanceof et))throw new SyntaxError("Constructor must be called with the new operator");this.actual=i,this.expected=e,this.relation=t,this.message="Dimension mismatch ("+(Array.isArray(i)?"["+i.join(", ")+"]":i)+" "+(this.relation||"!=")+" "+(Array.isArray(e)?"["+e.join(", ")+"]":e)+")",this.stack=new Error().stack}et.prototype=new RangeError;et.prototype.constructor=RangeError;et.prototype.name="DimensionError";et.prototype.isDimensionError=!0;function Wi(i,e,t){if(!(this instanceof Wi))throw new SyntaxError("Constructor must be called with the new operator");this.index=i,arguments.length<3?(this.min=0,this.max=e):(this.min=e,this.max=t),this.min!==void 0&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":this.max!==void 0&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=new Error().stack}Wi.prototype=new RangeError;Wi.prototype.constructor=RangeError;Wi.prototype.name="IndexError";Wi.prototype.isIndexError=!0;function $n(i){for(var e=[];Array.isArray(i);)e.push(i.length),i=i[0];return e}function Nu(i,e,t){var n,r=i.length;if(r!==e[t])throw new et(r,e[t]);if(t<e.length-1){var s=t+1;for(n=0;n<r;n++){var o=i[n];if(!Array.isArray(o))throw new et(e.length-1,e.length,"<");Nu(i[n],e,s)}}else for(n=0;n<r;n++)if(Array.isArray(i[n]))throw new et(e.length+1,e.length,">")}function hc(i,e){var t=e.length===0;if(t){if(Array.isArray(i))throw new et(i.length,0)}else Nu(i,e,0)}function Qe(i,e){if(!it(i)||!mt(i))throw new TypeError("Index must be an integer (value: "+i+")");if(i<0||typeof e=="number"&&i>=e)throw new Wi(i,e)}function fc(i,e,t){if(!Array.isArray(i)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new Error("Resizing to scalar is not supported");e.forEach(function(r){if(!it(r)||!mt(r)||r<0)throw new TypeError("Invalid size, must contain positive integers (size: "+At(e)+")")});var n=t!==void 0?t:0;return Ko(i,e,0,n),i}function Ko(i,e,t,n){var r,s,o=i.length,a=e[t],u=Math.min(o,a);if(i.length=a,t<e.length-1){var h=t+1;for(r=0;r<u;r++)s=i[r],Array.isArray(s)||(s=[s],i[r]=s),Ko(s,e,h,n);for(r=u;r<a;r++)s=[],i[r]=s,Ko(s,e,h,n)}else{for(r=0;r<u;r++)for(;Array.isArray(i[r]);)i[r]=i[r][0];for(r=u;r<a;r++)i[r]=n}}function Gy(i,e){var t=Wy(i),n=t.length;if(!Array.isArray(i)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new et(0,n,"!=");e=Da(e,n);var r=Du(e);if(n!==r)throw new et(r,n,"!=");try{return ky(t,e)}catch(s){throw s instanceof et?new et(r,n,"!="):s}}function Da(i,e){var t=Du(i),n=i.slice(),r=-1,s=i.indexOf(r),o=i.indexOf(r,s+1)>=0;if(o)throw new Error("More than one wildcard in sizes");var a=s>=0,u=e%t===0;if(a)if(u)n[s]=-e/t;else throw new Error("Could not replace wildcard, since "+e+" is no multiple of "+-t);return n}function Du(i){return i.reduce((e,t)=>e*t,1)}function ky(i,e){for(var t=i,n,r=e.length-1;r>0;r--){var s=e[r];n=[];for(var o=t.length/s,a=0;a<o;a++)n.push(t.slice(a*s,(a+1)*s));t=n}return t}function Iu(i,e,t,n){var r=n||$n(i);if(t)for(var s=0;s<t;s++)i=[i],r.unshift(1);for(i=Fu(i,e,0);r.length<e;)r.push(1);return i}function Fu(i,e,t){var n,r;if(Array.isArray(i)){var s=t+1;for(n=0,r=i.length;n<r;n++)i[n]=Fu(i[n],e,s)}else for(var o=t;o<e;o++)i=[i];return i}function Wy(i){if(!Array.isArray(i))return i;var e=[];return i.forEach(function t(n){Array.isArray(n)?n.forEach(t):e.push(n)}),e}function _s(i,e){for(var t,n=0,r=0;r<i.length;r++){var s=i[r],o=Array.isArray(s);if(r===0&&o&&(n=s.length),o&&s.length!==n)return;var a=o?_s(s,e):e(s);if(t===void 0)t=a;else if(t!==a)return"mixed"}return t}function ft(i,e,t,n){function r(s){var o=Ly(s,e.map(Zy));return qy(i,e,s),t(o)}return r.isFactory=!0,r.fn=i,r.dependencies=e.slice().sort(),n&&(r.meta=n),r}function qy(i,e,t){var n=e.filter(s=>!Xy(s)).every(s=>t[s]!==void 0);if(!n){var r=e.filter(s=>t[s]===void 0);throw new Error('Cannot create function "'.concat(i,'", ')+"some dependencies are missing: ".concat(r.map(s=>'"'.concat(s,'"')).join(", "),"."))}}function Xy(i){return i&&i[0]==="?"}function Zy(i){return i&&i[0]==="?"?i.slice(1):i}function Yy(i,e){if(Ou(i)&&zu(i,e))return i[e];throw typeof i[e]=="function"&&$y(i,e)?new Error('Cannot access method "'+e+'" as a property'):new Error('No access to property "'+e+'"')}function jy(i,e,t){if(Ou(i)&&zu(i,e))return i[e]=t,t;throw new Error('No access to property "'+e+'"')}function Jy(i,e){return e in i}function zu(i,e){return!i||typeof i!="object"?!1:yr(Qy,e)?!0:!(e in Object.prototype||e in Function.prototype)}function $y(i,e){return i==null||typeof i[e]!="function"||yr(i,e)&&Object.getPrototypeOf&&e in Object.getPrototypeOf(i)?!1:yr(Ky,e)?!0:!(e in Object.prototype||e in Function.prototype)}function Ou(i){return typeof i=="object"&&i&&i.constructor===Object}var Qy={length:!0,name:!0},Ky={toString:!0,valueOf:!0,toLocaleString:!0};class e_{constructor(e){this.wrappedObject=e}keys(){return Object.keys(this.wrappedObject)}get(e){return Yy(this.wrappedObject,e)}set(e,t){return jy(this.wrappedObject,e,t),this}has(e){return Jy(this.wrappedObject,e)}}function t_(i){return i?i instanceof Map||i instanceof e_||typeof i.set=="function"&&typeof i.get=="function"&&typeof i.keys=="function"&&typeof i.has=="function":!1}var Bu=function(){return Bu=cc.create,cc},n_=["?BigNumber","?Complex","?DenseMatrix","?Fraction"],i_=ft("typed",n_,function(e){var{BigNumber:t,Complex:n,DenseMatrix:r,Fraction:s}=e,o=Bu();return o.types=[{name:"number",test:it},{name:"Complex",test:Ra},{name:"BigNumber",test:Zt},{name:"Fraction",test:Pa},{name:"Unit",test:Na},{name:"string",test:dn},{name:"Chain",test:Au},{name:"Array",test:$e},{name:"Matrix",test:bt},{name:"DenseMatrix",test:ry},{name:"SparseMatrix",test:sy},{name:"Range",test:bu},{name:"Index",test:zs},{name:"boolean",test:oy},{name:"ResultSet",test:Su},{name:"Help",test:Eu},{name:"function",test:ay},{name:"Date",test:ly},{name:"RegExp",test:cy},{name:"null",test:hy},{name:"undefined",test:fy},{name:"AccessorNode",test:dy},{name:"ArrayNode",test:py},{name:"AssignmentNode",test:my},{name:"BlockNode",test:gy},{name:"ConditionalNode",test:vy},{name:"ConstantNode",test:yy},{name:"FunctionNode",test:xy},{name:"FunctionAssignmentNode",test:_y},{name:"IndexNode",test:wy},{name:"Node",test:Tu},{name:"ObjectNode",test:My},{name:"OperatorNode",test:by},{name:"ParenthesisNode",test:Sy},{name:"RangeNode",test:Ey},{name:"SymbolNode",test:Ty},{name:"Map",test:t_},{name:"Object",test:uy}],o.conversions=[{from:"number",to:"BigNumber",convert:function(u){if(t||zo(u),zy(u)>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+u+"). Use function bignumber(x) to convert to BigNumber.");return new t(u)}},{from:"number",to:"Complex",convert:function(u){return n||ls(u),new n(u,0)}},{from:"number",to:"string",convert:function(u){return u+""}},{from:"BigNumber",to:"Complex",convert:function(u){return n||ls(u),new n(u.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(u){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(u){return n||ls(u),new n(u.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(u){s||Oo(u);var h=new s(u);if(h.valueOf()!==u)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+u+"). Use function fraction(x) to convert to Fraction.");return h}},{from:"string",to:"number",convert:function(u){var h=Number(u);if(isNaN(h))throw new Error('Cannot convert "'+u+'" to a number');return h}},{from:"string",to:"BigNumber",convert:function(u){t||zo(u);try{return new t(u)}catch{throw new Error('Cannot convert "'+u+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(u){s||Oo(u);try{return new s(u)}catch{throw new Error('Cannot convert "'+u+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(u){n||ls(u);try{return new n(u)}catch{throw new Error('Cannot convert "'+u+'" to Complex')}}},{from:"boolean",to:"number",convert:function(u){return+u}},{from:"boolean",to:"BigNumber",convert:function(u){return t||zo(u),new t(+u)}},{from:"boolean",to:"Fraction",convert:function(u){return s||Oo(u),new s(+u)}},{from:"boolean",to:"string",convert:function(u){return String(u)}},{from:"Array",to:"Matrix",convert:function(u){return r||r_(),new r(u)}},{from:"Matrix",to:"Array",convert:function(u){return u.valueOf()}}],o});function zo(i){throw new Error("Cannot convert value ".concat(i," into a BigNumber: no class 'BigNumber' provided"))}function ls(i){throw new Error("Cannot convert value ".concat(i," into a Complex number: no class 'Complex' provided"))}function r_(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}function Oo(i){throw new Error("Cannot convert value ".concat(i," into a Fraction, no class 'Fraction' provided."))}var Si=9e15,On=1e9,ea="0123456789abcdef",xs="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",ws="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",ta={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Si,maxE:Si,crypto:!1},Uu,pn,De=!0,Hs="[DecimalError] ",Fn=Hs+"Invalid argument: ",Hu=Hs+"Precision limit exceeded",Vu=Hs+"crypto unavailable",Gu="[object Decimal]",wt=Math.floor,lt=Math.pow,s_=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,o_=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,a_=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,ku=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,jt=1e7,Ce=7,l_=9007199254740991,c_=xs.length-1,na=ws.length-1,re={toStringTag:Gu};re.absoluteValue=re.abs=function(){var i=new this.constructor(this);return i.s<0&&(i.s=1),be(i)};re.ceil=function(){return be(new this.constructor(this),this.e+1,2)};re.clampedTo=re.clamp=function(i,e){var t,n=this,r=n.constructor;if(i=new r(i),e=new r(e),!i.s||!e.s)return new r(NaN);if(i.gt(e))throw Error(Fn+e);return t=n.cmp(i),t<0?i:n.cmp(e)>0?e:new r(n)};re.comparedTo=re.cmp=function(i){var e,t,n,r,s=this,o=s.d,a=(i=new s.constructor(i)).d,u=s.s,h=i.s;if(!o||!a)return!u||!h?NaN:u!==h?u:o===a?0:!o^u<0?1:-1;if(!o[0]||!a[0])return o[0]?u:a[0]?-h:0;if(u!==h)return u;if(s.e!==i.e)return s.e>i.e^u<0?1:-1;for(n=o.length,r=a.length,e=0,t=n<r?n:r;e<t;++e)if(o[e]!==a[e])return o[e]>a[e]^u<0?1:-1;return n===r?0:n>r^u<0?1:-1};re.cosine=re.cos=function(){var i,e,t=this,n=t.constructor;return t.d?t.d[0]?(i=n.precision,e=n.rounding,n.precision=i+Math.max(t.e,t.sd())+Ce,n.rounding=1,t=u_(n,Yu(n,t)),n.precision=i,n.rounding=e,be(pn==2||pn==3?t.neg():t,i,e,!0)):new n(1):new n(NaN)};re.cubeRoot=re.cbrt=function(){var i,e,t,n,r,s,o,a,u,h,c=this,l=c.constructor;if(!c.isFinite()||c.isZero())return new l(c);for(De=!1,s=c.s*lt(c.s*c,1/3),!s||Math.abs(s)==1/0?(t=vt(c.d),i=c.e,(s=(i-t.length+1)%3)&&(t+=s==1||s==-2?"0":"00"),s=lt(t,1/3),i=wt((i+1)/3)-(i%3==(i<0?-1:2)),s==1/0?t="5e"+i:(t=s.toExponential(),t=t.slice(0,t.indexOf("e")+1)+i),n=new l(t),n.s=c.s):n=new l(s.toString()),o=(i=l.precision)+3;;)if(a=n,u=a.times(a).times(a),h=u.plus(c),n=qe(h.plus(c).times(a),h.plus(u),o+2,1),vt(a.d).slice(0,o)===(t=vt(n.d)).slice(0,o))if(t=t.slice(o-3,o+1),t=="9999"||!r&&t=="4999"){if(!r&&(be(a,i+1,0),a.times(a).times(a).eq(c))){n=a;break}o+=4,r=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(be(n,i+1,1),e=!n.times(n).times(n).eq(c));break}return De=!0,be(n,i,l.rounding,e)};re.decimalPlaces=re.dp=function(){var i,e=this.d,t=NaN;if(e){if(i=e.length-1,t=(i-wt(this.e/Ce))*Ce,i=e[i],i)for(;i%10==0;i/=10)t--;t<0&&(t=0)}return t};re.dividedBy=re.div=function(i){return qe(this,new this.constructor(i))};re.dividedToIntegerBy=re.divToInt=function(i){var e=this,t=e.constructor;return be(qe(e,new t(i),0,1,1),t.precision,t.rounding)};re.equals=re.eq=function(i){return this.cmp(i)===0};re.floor=function(){return be(new this.constructor(this),this.e+1,3)};re.greaterThan=re.gt=function(i){return this.cmp(i)>0};re.greaterThanOrEqualTo=re.gte=function(i){var e=this.cmp(i);return e==1||e===0};re.hyperbolicCosine=re.cosh=function(){var i,e,t,n,r,s=this,o=s.constructor,a=new o(1);if(!s.isFinite())return new o(s.s?1/0:NaN);if(s.isZero())return a;t=o.precision,n=o.rounding,o.precision=t+Math.max(s.e,s.sd())+4,o.rounding=1,r=s.d.length,r<32?(i=Math.ceil(r/3),e=(1/Gs(4,i)).toString()):(i=16,e="2.3283064365386962890625e-10"),s=Di(o,1,s.times(e),new o(1),!0);for(var u,h=i,c=new o(8);h--;)u=s.times(s),s=a.minus(u.times(c.minus(u.times(c))));return be(s,o.precision=t,o.rounding=n,!0)};re.hyperbolicSine=re.sinh=function(){var i,e,t,n,r=this,s=r.constructor;if(!r.isFinite()||r.isZero())return new s(r);if(e=s.precision,t=s.rounding,s.precision=e+Math.max(r.e,r.sd())+4,s.rounding=1,n=r.d.length,n<3)r=Di(s,2,r,r,!0);else{i=1.4*Math.sqrt(n),i=i>16?16:i|0,r=r.times(1/Gs(5,i)),r=Di(s,2,r,r,!0);for(var o,a=new s(5),u=new s(16),h=new s(20);i--;)o=r.times(r),r=r.times(a.plus(o.times(u.times(o).plus(h))))}return s.precision=e,s.rounding=t,be(r,e,t,!0)};re.hyperbolicTangent=re.tanh=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+7,n.rounding=1,qe(t.sinh(),t.cosh(),n.precision=i,n.rounding=e)):new n(t.s)};re.inverseCosine=re.acos=function(){var i,e=this,t=e.constructor,n=e.abs().cmp(1),r=t.precision,s=t.rounding;return n!==-1?n===0?e.isNeg()?Yt(t,r,s):new t(0):new t(NaN):e.isZero()?Yt(t,r+4,s).times(.5):(t.precision=r+6,t.rounding=1,e=e.asin(),i=Yt(t,r+4,s).times(.5),t.precision=r,t.rounding=s,i.minus(e))};re.inverseHyperbolicCosine=re.acosh=function(){var i,e,t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(i=n.precision,e=n.rounding,n.precision=i+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,De=!1,t=t.times(t).minus(1).sqrt().plus(t),De=!0,n.precision=i,n.rounding=e,t.ln()):new n(t)};re.inverseHyperbolicSine=re.asinh=function(){var i,e,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,De=!1,t=t.times(t).plus(1).sqrt().plus(t),De=!0,n.precision=i,n.rounding=e,t.ln())};re.inverseHyperbolicTangent=re.atanh=function(){var i,e,t,n,r=this,s=r.constructor;return r.isFinite()?r.e>=0?new s(r.abs().eq(1)?r.s/0:r.isZero()?r:NaN):(i=s.precision,e=s.rounding,n=r.sd(),Math.max(n,i)<2*-r.e-1?be(new s(r),i,e,!0):(s.precision=t=n-r.e,r=qe(r.plus(1),new s(1).minus(r),t+i,1),s.precision=i+4,s.rounding=1,r=r.ln(),s.precision=i,s.rounding=e,r.times(.5))):new s(NaN)};re.inverseSine=re.asin=function(){var i,e,t,n,r=this,s=r.constructor;return r.isZero()?new s(r):(e=r.abs().cmp(1),t=s.precision,n=s.rounding,e!==-1?e===0?(i=Yt(s,t+4,n).times(.5),i.s=r.s,i):new s(NaN):(s.precision=t+6,s.rounding=1,r=r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(),s.precision=t,s.rounding=n,r.times(2)))};re.inverseTangent=re.atan=function(){var i,e,t,n,r,s,o,a,u,h=this,c=h.constructor,l=c.precision,f=c.rounding;if(h.isFinite()){if(h.isZero())return new c(h);if(h.abs().eq(1)&&l+4<=na)return o=Yt(c,l+4,f).times(.25),o.s=h.s,o}else{if(!h.s)return new c(NaN);if(l+4<=na)return o=Yt(c,l+4,f).times(.5),o.s=h.s,o}for(c.precision=a=l+10,c.rounding=1,t=Math.min(28,a/Ce+2|0),i=t;i;--i)h=h.div(h.times(h).plus(1).sqrt().plus(1));for(De=!1,e=Math.ceil(a/Ce),n=1,u=h.times(h),o=new c(h),r=h;i!==-1;)if(r=r.times(u),s=o.minus(r.div(n+=2)),r=r.times(u),o=s.plus(r.div(n+=2)),o.d[e]!==void 0)for(i=e;o.d[i]===s.d[i]&&i--;);return t&&(o=o.times(2<<t-1)),De=!0,be(o,c.precision=l,c.rounding=f,!0)};re.isFinite=function(){return!!this.d};re.isInteger=re.isInt=function(){return!!this.d&&wt(this.e/Ce)>this.d.length-2};re.isNaN=function(){return!this.s};re.isNegative=re.isNeg=function(){return this.s<0};re.isPositive=re.isPos=function(){return this.s>0};re.isZero=function(){return!!this.d&&this.d[0]===0};re.lessThan=re.lt=function(i){return this.cmp(i)<0};re.lessThanOrEqualTo=re.lte=function(i){return this.cmp(i)<1};re.logarithm=re.log=function(i){var e,t,n,r,s,o,a,u,h=this,c=h.constructor,l=c.precision,f=c.rounding,d=5;if(i==null)i=new c(10),e=!0;else{if(i=new c(i),t=i.d,i.s<0||!t||!t[0]||i.eq(1))return new c(NaN);e=i.eq(10)}if(t=h.d,h.s<0||!t||!t[0]||h.eq(1))return new c(t&&!t[0]?-1/0:h.s!=1?NaN:t?0:1/0);if(e)if(t.length>1)s=!0;else{for(r=t[0];r%10===0;)r/=10;s=r!==1}if(De=!1,a=l+d,o=An(h,a),n=e?Ms(c,a+10):An(i,a),u=qe(o,n,a,1),_r(u.d,r=l,f))do if(a+=10,o=An(h,a),n=e?Ms(c,a+10):An(i,a),u=qe(o,n,a,1),!s){+vt(u.d).slice(r+1,r+15)+1==1e14&&(u=be(u,l+1,0));break}while(_r(u.d,r+=10,f));return De=!0,be(u,l,f)};re.minus=re.sub=function(i){var e,t,n,r,s,o,a,u,h,c,l,f,d=this,v=d.constructor;if(i=new v(i),!d.d||!i.d)return!d.s||!i.s?i=new v(NaN):d.d?i.s=-i.s:i=new v(i.d||d.s!==i.s?d:NaN),i;if(d.s!=i.s)return i.s=-i.s,d.plus(i);if(h=d.d,f=i.d,a=v.precision,u=v.rounding,!h[0]||!f[0]){if(f[0])i.s=-i.s;else if(h[0])i=new v(d);else return new v(u===3?-0:0);return De?be(i,a,u):i}if(t=wt(i.e/Ce),c=wt(d.e/Ce),h=h.slice(),s=c-t,s){for(l=s<0,l?(e=h,s=-s,o=f.length):(e=f,t=c,o=h.length),n=Math.max(Math.ceil(a/Ce),o)+2,s>n&&(s=n,e.length=1),e.reverse(),n=s;n--;)e.push(0);e.reverse()}else{for(n=h.length,o=f.length,l=n<o,l&&(o=n),n=0;n<o;n++)if(h[n]!=f[n]){l=h[n]<f[n];break}s=0}for(l&&(e=h,h=f,f=e,i.s=-i.s),o=h.length,n=f.length-o;n>0;--n)h[o++]=0;for(n=f.length;n>s;){if(h[--n]<f[n]){for(r=n;r&&h[--r]===0;)h[r]=jt-1;--h[r],h[n]+=jt}h[n]-=f[n]}for(;h[--o]===0;)h.pop();for(;h[0]===0;h.shift())--t;return h[0]?(i.d=h,i.e=Vs(h,t),De?be(i,a,u):i):new v(u===3?-0:0)};re.modulo=re.mod=function(i){var e,t=this,n=t.constructor;return i=new n(i),!t.d||!i.s||i.d&&!i.d[0]?new n(NaN):!i.d||t.d&&!t.d[0]?be(new n(t),n.precision,n.rounding):(De=!1,n.modulo==9?(e=qe(t,i.abs(),0,3,1),e.s*=i.s):e=qe(t,i,0,n.modulo,1),e=e.times(i),De=!0,t.minus(e))};re.naturalExponential=re.exp=function(){return ia(this)};re.naturalLogarithm=re.ln=function(){return An(this)};re.negated=re.neg=function(){var i=new this.constructor(this);return i.s=-i.s,be(i)};re.plus=re.add=function(i){var e,t,n,r,s,o,a,u,h,c,l=this,f=l.constructor;if(i=new f(i),!l.d||!i.d)return!l.s||!i.s?i=new f(NaN):l.d||(i=new f(i.d||l.s===i.s?l:NaN)),i;if(l.s!=i.s)return i.s=-i.s,l.minus(i);if(h=l.d,c=i.d,a=f.precision,u=f.rounding,!h[0]||!c[0])return c[0]||(i=new f(l)),De?be(i,a,u):i;if(s=wt(l.e/Ce),n=wt(i.e/Ce),h=h.slice(),r=s-n,r){for(r<0?(t=h,r=-r,o=c.length):(t=c,n=s,o=h.length),s=Math.ceil(a/Ce),o=s>o?s+1:o+1,r>o&&(r=o,t.length=1),t.reverse();r--;)t.push(0);t.reverse()}for(o=h.length,r=c.length,o-r<0&&(r=o,t=c,c=h,h=t),e=0;r;)e=(h[--r]=h[r]+c[r]+e)/jt|0,h[r]%=jt;for(e&&(h.unshift(e),++n),o=h.length;h[--o]==0;)h.pop();return i.d=h,i.e=Vs(h,n),De?be(i,a,u):i};re.precision=re.sd=function(i){var e,t=this;if(i!==void 0&&i!==!!i&&i!==1&&i!==0)throw Error(Fn+i);return t.d?(e=Wu(t.d),i&&t.e+1>e&&(e=t.e+1)):e=NaN,e};re.round=function(){var i=this,e=i.constructor;return be(new e(i),i.e+1,e.rounding)};re.sine=re.sin=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+Math.max(t.e,t.sd())+Ce,n.rounding=1,t=f_(n,Yu(n,t)),n.precision=i,n.rounding=e,be(pn>2?t.neg():t,i,e,!0)):new n(NaN)};re.squareRoot=re.sqrt=function(){var i,e,t,n,r,s,o=this,a=o.d,u=o.e,h=o.s,c=o.constructor;if(h!==1||!a||!a[0])return new c(!h||h<0&&(!a||a[0])?NaN:a?o:1/0);for(De=!1,h=Math.sqrt(+o),h==0||h==1/0?(e=vt(a),(e.length+u)%2==0&&(e+="0"),h=Math.sqrt(e),u=wt((u+1)/2)-(u<0||u%2),h==1/0?e="5e"+u:(e=h.toExponential(),e=e.slice(0,e.indexOf("e")+1)+u),n=new c(e)):n=new c(h.toString()),t=(u=c.precision)+3;;)if(s=n,n=s.plus(qe(o,s,t+2,1)).times(.5),vt(s.d).slice(0,t)===(e=vt(n.d)).slice(0,t))if(e=e.slice(t-3,t+1),e=="9999"||!r&&e=="4999"){if(!r&&(be(s,u+1,0),s.times(s).eq(o))){n=s;break}t+=4,r=1}else{(!+e||!+e.slice(1)&&e.charAt(0)=="5")&&(be(n,u+1,1),i=!n.times(n).eq(o));break}return De=!0,be(n,u,c.rounding,i)};re.tangent=re.tan=function(){var i,e,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(i=n.precision,e=n.rounding,n.precision=i+10,n.rounding=1,t=t.sin(),t.s=1,t=qe(t,new n(1).minus(t.times(t)).sqrt(),i+10,0),n.precision=i,n.rounding=e,be(pn==2||pn==4?t.neg():t,i,e,!0)):new n(NaN)};re.times=re.mul=function(i){var e,t,n,r,s,o,a,u,h,c=this,l=c.constructor,f=c.d,d=(i=new l(i)).d;if(i.s*=c.s,!f||!f[0]||!d||!d[0])return new l(!i.s||f&&!f[0]&&!d||d&&!d[0]&&!f?NaN:!f||!d?i.s/0:i.s*0);for(t=wt(c.e/Ce)+wt(i.e/Ce),u=f.length,h=d.length,u<h&&(s=f,f=d,d=s,o=u,u=h,h=o),s=[],o=u+h,n=o;n--;)s.push(0);for(n=h;--n>=0;){for(e=0,r=u+n;r>n;)a=s[r]+d[n]*f[r-n-1]+e,s[r--]=a%jt|0,e=a/jt|0;s[r]=(s[r]+e)%jt|0}for(;!s[--o];)s.pop();return e?++t:s.shift(),i.d=s,i.e=Vs(s,t),De?be(i,l.precision,l.rounding):i};re.toBinary=function(i,e){return Ia(this,2,i,e)};re.toDecimalPlaces=re.toDP=function(i,e){var t=this,n=t.constructor;return t=new n(t),i===void 0?t:(Nt(i,0,On),e===void 0?e=n.rounding:Nt(e,0,8),be(t,i+t.e+1,e))};re.toExponential=function(i,e){var t,n=this,r=n.constructor;return i===void 0?t=nn(n,!0):(Nt(i,0,On),e===void 0?e=r.rounding:Nt(e,0,8),n=be(new r(n),i+1,e),t=nn(n,!0,i+1)),n.isNeg()&&!n.isZero()?"-"+t:t};re.toFixed=function(i,e){var t,n,r=this,s=r.constructor;return i===void 0?t=nn(r):(Nt(i,0,On),e===void 0?e=s.rounding:Nt(e,0,8),n=be(new s(r),i+r.e+1,e),t=nn(n,!1,i+n.e+1)),r.isNeg()&&!r.isZero()?"-"+t:t};re.toFraction=function(i){var e,t,n,r,s,o,a,u,h,c,l,f,d=this,v=d.d,m=d.constructor;if(!v)return new m(d);if(h=t=new m(1),n=u=new m(0),e=new m(n),s=e.e=Wu(v)-d.e-1,o=s%Ce,e.d[0]=lt(10,o<0?Ce+o:o),i==null)i=s>0?e:h;else{if(a=new m(i),!a.isInt()||a.lt(h))throw Error(Fn+a);i=a.gt(e)?s>0?e:h:a}for(De=!1,a=new m(vt(v)),c=m.precision,m.precision=s=v.length*Ce*2;l=qe(a,e,0,1,1),r=t.plus(l.times(n)),r.cmp(i)!=1;)t=n,n=r,r=h,h=u.plus(l.times(r)),u=r,r=e,e=a.minus(l.times(r)),a=r;return r=qe(i.minus(t),n,0,1,1),u=u.plus(r.times(h)),t=t.plus(r.times(n)),u.s=h.s=d.s,f=qe(h,n,s,1).minus(d).abs().cmp(qe(u,t,s,1).minus(d).abs())<1?[h,n]:[u,t],m.precision=c,De=!0,f};re.toHexadecimal=re.toHex=function(i,e){return Ia(this,16,i,e)};re.toNearest=function(i,e){var t=this,n=t.constructor;if(t=new n(t),i==null){if(!t.d)return t;i=new n(1),e=n.rounding}else{if(i=new n(i),e===void 0?e=n.rounding:Nt(e,0,8),!t.d)return i.s?t:i;if(!i.d)return i.s&&(i.s=t.s),i}return i.d[0]?(De=!1,t=qe(t,i,0,e,1).times(i),De=!0,be(t)):(i.s=t.s,t=i),t};re.toNumber=function(){return+this};re.toOctal=function(i,e){return Ia(this,8,i,e)};re.toPower=re.pow=function(i){var e,t,n,r,s,o,a=this,u=a.constructor,h=+(i=new u(i));if(!a.d||!i.d||!a.d[0]||!i.d[0])return new u(lt(+a,h));if(a=new u(a),a.eq(1))return a;if(n=u.precision,s=u.rounding,i.eq(1))return be(a,n,s);if(e=wt(i.e/Ce),e>=i.d.length-1&&(t=h<0?-h:h)<=l_)return r=qu(u,a,t,n),i.s<0?new u(1).div(r):be(r,n,s);if(o=a.s,o<0){if(e<i.d.length-1)return new u(NaN);if((i.d[e]&1)==0&&(o=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=o,a}return t=lt(+a,h),e=t==0||!isFinite(t)?wt(h*(Math.log("0."+vt(a.d))/Math.LN10+a.e+1)):new u(t+"").e,e>u.maxE+1||e<u.minE-1?new u(e>0?o/0:0):(De=!1,u.rounding=a.s=1,t=Math.min(12,(e+"").length),r=ia(i.times(An(a,n+t)),n),r.d&&(r=be(r,n+5,1),_r(r.d,n,s)&&(e=n+10,r=be(ia(i.times(An(a,e+t)),e),e+5,1),+vt(r.d).slice(n+1,n+15)+1==1e14&&(r=be(r,n+1,0)))),r.s=o,De=!0,u.rounding=s,be(r,n,s))};re.toPrecision=function(i,e){var t,n=this,r=n.constructor;return i===void 0?t=nn(n,n.e<=r.toExpNeg||n.e>=r.toExpPos):(Nt(i,1,On),e===void 0?e=r.rounding:Nt(e,0,8),n=be(new r(n),i,e),t=nn(n,i<=n.e||n.e<=r.toExpNeg,i)),n.isNeg()&&!n.isZero()?"-"+t:t};re.toSignificantDigits=re.toSD=function(i,e){var t=this,n=t.constructor;return i===void 0?(i=n.precision,e=n.rounding):(Nt(i,1,On),e===void 0?e=n.rounding:Nt(e,0,8)),be(new n(t),i,e)};re.toString=function(){var i=this,e=i.constructor,t=nn(i,i.e<=e.toExpNeg||i.e>=e.toExpPos);return i.isNeg()&&!i.isZero()?"-"+t:t};re.truncated=re.trunc=function(){return be(new this.constructor(this),this.e+1,1)};re.valueOf=re.toJSON=function(){var i=this,e=i.constructor,t=nn(i,i.e<=e.toExpNeg||i.e>=e.toExpPos);return i.isNeg()?"-"+t:t};function vt(i){var e,t,n,r=i.length-1,s="",o=i[0];if(r>0){for(s+=o,e=1;e<r;e++)n=i[e]+"",t=Ce-n.length,t&&(s+=En(t)),s+=n;o=i[e],n=o+"",t=Ce-n.length,t&&(s+=En(t))}else if(o===0)return"0";for(;o%10===0;)o/=10;return s+o}function Nt(i,e,t){if(i!==~~i||i<e||i>t)throw Error(Fn+i)}function _r(i,e,t,n){var r,s,o,a;for(s=i[0];s>=10;s/=10)--e;return--e<0?(e+=Ce,r=0):(r=Math.ceil((e+1)/Ce),e%=Ce),s=lt(10,Ce-e),a=i[r]%s|0,n==null?e<3?(e==0?a=a/100|0:e==1&&(a=a/10|0),o=t<4&&a==99999||t>3&&a==49999||a==5e4||a==0):o=(t<4&&a+1==s||t>3&&a+1==s/2)&&(i[r+1]/s/100|0)==lt(10,e-2)-1||(a==s/2||a==0)&&(i[r+1]/s/100|0)==0:e<4?(e==0?a=a/1e3|0:e==1?a=a/100|0:e==2&&(a=a/10|0),o=(n||t<4)&&a==9999||!n&&t>3&&a==4999):o=((n||t<4)&&a+1==s||!n&&t>3&&a+1==s/2)&&(i[r+1]/s/1e3|0)==lt(10,e-3)-1,o}function us(i,e,t){for(var n,r=[0],s,o=0,a=i.length;o<a;){for(s=r.length;s--;)r[s]*=e;for(r[0]+=ea.indexOf(i.charAt(o++)),n=0;n<r.length;n++)r[n]>t-1&&(r[n+1]===void 0&&(r[n+1]=0),r[n+1]+=r[n]/t|0,r[n]%=t)}return r.reverse()}function u_(i,e){var t,n,r;if(e.isZero())return e;n=e.d.length,n<32?(t=Math.ceil(n/3),r=(1/Gs(4,t)).toString()):(t=16,r="2.3283064365386962890625e-10"),i.precision+=t,e=Di(i,1,e.times(r),new i(1));for(var s=t;s--;){var o=e.times(e);e=o.times(o).minus(o).times(8).plus(1)}return i.precision-=t,e}var qe=function(){function i(n,r,s){var o,a=0,u=n.length;for(n=n.slice();u--;)o=n[u]*r+a,n[u]=o%s|0,a=o/s|0;return a&&n.unshift(a),n}function e(n,r,s,o){var a,u;if(s!=o)u=s>o?1:-1;else for(a=u=0;a<s;a++)if(n[a]!=r[a]){u=n[a]>r[a]?1:-1;break}return u}function t(n,r,s,o){for(var a=0;s--;)n[s]-=a,a=n[s]<r[s]?1:0,n[s]=a*o+n[s]-r[s];for(;!n[0]&&n.length>1;)n.shift()}return function(n,r,s,o,a,u){var h,c,l,f,d,v,m,y,p,g,_,x,M,S,w,C,D,I,T,B,O=n.constructor,F=n.s==r.s?1:-1,z=n.d,N=r.d;if(!z||!z[0]||!N||!N[0])return new O(!n.s||!r.s||(z?N&&z[0]==N[0]:!N)?NaN:z&&z[0]==0||!N?F*0:F/0);for(u?(d=1,c=n.e-r.e):(u=jt,d=Ce,c=wt(n.e/d)-wt(r.e/d)),T=N.length,D=z.length,p=new O(F),g=p.d=[],l=0;N[l]==(z[l]||0);l++);if(N[l]>(z[l]||0)&&c--,s==null?(S=s=O.precision,o=O.rounding):a?S=s+(n.e-r.e)+1:S=s,S<0)g.push(1),v=!0;else{if(S=S/d+2|0,l=0,T==1){for(f=0,N=N[0],S++;(l<D||f)&&S--;l++)w=f*u+(z[l]||0),g[l]=w/N|0,f=w%N|0;v=f||l<D}else{for(f=u/(N[0]+1)|0,f>1&&(N=i(N,f,u),z=i(z,f,u),T=N.length,D=z.length),C=T,_=z.slice(0,T),x=_.length;x<T;)_[x++]=0;B=N.slice(),B.unshift(0),I=N[0],N[1]>=u/2&&++I;do f=0,h=e(N,_,T,x),h<0?(M=_[0],T!=x&&(M=M*u+(_[1]||0)),f=M/I|0,f>1?(f>=u&&(f=u-1),m=i(N,f,u),y=m.length,x=_.length,h=e(m,_,y,x),h==1&&(f--,t(m,T<y?B:N,y,u))):(f==0&&(h=f=1),m=N.slice()),y=m.length,y<x&&m.unshift(0),t(_,m,x,u),h==-1&&(x=_.length,h=e(N,_,T,x),h<1&&(f++,t(_,T<x?B:N,x,u))),x=_.length):h===0&&(f++,_=[0]),g[l++]=f,h&&_[0]?_[x++]=z[C]||0:(_=[z[C]],x=1);while((C++<D||_[0]!==void 0)&&S--);v=_[0]!==void 0}g[0]||g.shift()}if(d==1)p.e=c,Uu=v;else{for(l=1,f=g[0];f>=10;f/=10)l++;p.e=l+c*d-1,be(p,a?s+p.e+1:s,o,v)}return p}}();function be(i,e,t,n){var r,s,o,a,u,h,c,l,f,d=i.constructor;e:if(e!=null){if(l=i.d,!l)return i;for(r=1,a=l[0];a>=10;a/=10)r++;if(s=e-r,s<0)s+=Ce,o=e,c=l[f=0],u=c/lt(10,r-o-1)%10|0;else if(f=Math.ceil((s+1)/Ce),a=l.length,f>=a)if(n){for(;a++<=f;)l.push(0);c=u=0,r=1,s%=Ce,o=s-Ce+1}else break e;else{for(c=a=l[f],r=1;a>=10;a/=10)r++;s%=Ce,o=s-Ce+r,u=o<0?0:c/lt(10,r-o-1)%10|0}if(n=n||e<0||l[f+1]!==void 0||(o<0?c:c%lt(10,r-o-1)),h=t<4?(u||n)&&(t==0||t==(i.s<0?3:2)):u>5||u==5&&(t==4||n||t==6&&(s>0?o>0?c/lt(10,r-o):0:l[f-1])%10&1||t==(i.s<0?8:7)),e<1||!l[0])return l.length=0,h?(e-=i.e+1,l[0]=lt(10,(Ce-e%Ce)%Ce),i.e=-e||0):l[0]=i.e=0,i;if(s==0?(l.length=f,a=1,f--):(l.length=f+1,a=lt(10,Ce-s),l[f]=o>0?(c/lt(10,r-o)%lt(10,o)|0)*a:0),h)for(;;)if(f==0){for(s=1,o=l[0];o>=10;o/=10)s++;for(o=l[0]+=a,a=1;o>=10;o/=10)a++;s!=a&&(i.e++,l[0]==jt&&(l[0]=1));break}else{if(l[f]+=a,l[f]!=jt)break;l[f--]=0,a=1}for(s=l.length;l[--s]===0;)l.pop()}return De&&(i.e>d.maxE?(i.d=null,i.e=NaN):i.e<d.minE&&(i.e=0,i.d=[0])),i}function nn(i,e,t){if(!i.isFinite())return Zu(i);var n,r=i.e,s=vt(i.d),o=s.length;return e?(t&&(n=t-o)>0?s=s.charAt(0)+"."+s.slice(1)+En(n):o>1&&(s=s.charAt(0)+"."+s.slice(1)),s=s+(i.e<0?"e":"e+")+i.e):r<0?(s="0."+En(-r-1)+s,t&&(n=t-o)>0&&(s+=En(n))):r>=o?(s+=En(r+1-o),t&&(n=t-r-1)>0&&(s=s+"."+En(n))):((n=r+1)<o&&(s=s.slice(0,n)+"."+s.slice(n)),t&&(n=t-o)>0&&(r+1===o&&(s+="."),s+=En(n))),s}function Vs(i,e){var t=i[0];for(e*=Ce;t>=10;t/=10)e++;return e}function Ms(i,e,t){if(e>c_)throw De=!0,t&&(i.precision=t),Error(Hu);return be(new i(xs),e,1,!0)}function Yt(i,e,t){if(e>na)throw Error(Hu);return be(new i(ws),e,t,!0)}function Wu(i){var e=i.length-1,t=e*Ce+1;if(e=i[e],e){for(;e%10==0;e/=10)t--;for(e=i[0];e>=10;e/=10)t++}return t}function En(i){for(var e="";i--;)e+="0";return e}function qu(i,e,t,n){var r,s=new i(1),o=Math.ceil(n/Ce+4);for(De=!1;;){if(t%2&&(s=s.times(e),pc(s.d,o)&&(r=!0)),t=wt(t/2),t===0){t=s.d.length-1,r&&s.d[t]===0&&++s.d[t];break}e=e.times(e),pc(e.d,o)}return De=!0,s}function dc(i){return i.d[i.d.length-1]&1}function Xu(i,e,t){for(var n,r=new i(e[0]),s=0;++s<e.length;)if(n=new i(e[s]),n.s)r[t](n)&&(r=n);else{r=n;break}return r}function ia(i,e){var t,n,r,s,o,a,u,h=0,c=0,l=0,f=i.constructor,d=f.rounding,v=f.precision;if(!i.d||!i.d[0]||i.e>17)return new f(i.d?i.d[0]?i.s<0?0:1/0:1:i.s?i.s<0?0:i:0/0);for(e==null?(De=!1,u=v):u=e,a=new f(.03125);i.e>-2;)i=i.times(a),l+=5;for(n=Math.log(lt(2,l))/Math.LN10*2+5|0,u+=n,t=s=o=new f(1),f.precision=u;;){if(s=be(s.times(i),u,1),t=t.times(++c),a=o.plus(qe(s,t,u,1)),vt(a.d).slice(0,u)===vt(o.d).slice(0,u)){for(r=l;r--;)o=be(o.times(o),u,1);if(e==null)if(h<3&&_r(o.d,u-n,d,h))f.precision=u+=10,t=s=a=new f(1),c=0,h++;else return be(o,f.precision=v,d,De=!0);else return f.precision=v,o}o=a}}function An(i,e){var t,n,r,s,o,a,u,h,c,l,f,d=1,v=10,m=i,y=m.d,p=m.constructor,g=p.rounding,_=p.precision;if(m.s<0||!y||!y[0]||!m.e&&y[0]==1&&y.length==1)return new p(y&&!y[0]?-1/0:m.s!=1?NaN:y?0:m);if(e==null?(De=!1,c=_):c=e,p.precision=c+=v,t=vt(y),n=t.charAt(0),Math.abs(s=m.e)<15e14){for(;n<7&&n!=1||n==1&&t.charAt(1)>3;)m=m.times(i),t=vt(m.d),n=t.charAt(0),d++;s=m.e,n>1?(m=new p("0."+t),s++):m=new p(n+"."+t.slice(1))}else return h=Ms(p,c+2,_).times(s+""),m=An(new p(n+"."+t.slice(1)),c-v).plus(h),p.precision=_,e==null?be(m,_,g,De=!0):m;for(l=m,u=o=m=qe(m.minus(1),m.plus(1),c,1),f=be(m.times(m),c,1),r=3;;){if(o=be(o.times(f),c,1),h=u.plus(qe(o,new p(r),c,1)),vt(h.d).slice(0,c)===vt(u.d).slice(0,c))if(u=u.times(2),s!==0&&(u=u.plus(Ms(p,c+2,_).times(s+""))),u=qe(u,new p(d),c,1),e==null)if(_r(u.d,c-v,g,a))p.precision=c+=v,h=o=m=qe(l.minus(1),l.plus(1),c,1),f=be(m.times(m),c,1),r=a=1;else return be(u,p.precision=_,g,De=!0);else return p.precision=_,u;u=h,r+=2}}function Zu(i){return String(i.s*i.s/0)}function ra(i,e){var t,n,r;for((t=e.indexOf("."))>-1&&(e=e.replace(".","")),(n=e.search(/e/i))>0?(t<0&&(t=n),t+=+e.slice(n+1),e=e.substring(0,n)):t<0&&(t=e.length),n=0;e.charCodeAt(n)===48;n++);for(r=e.length;e.charCodeAt(r-1)===48;--r);if(e=e.slice(n,r),e){if(r-=n,i.e=t=t-n-1,i.d=[],n=(t+1)%Ce,t<0&&(n+=Ce),n<r){for(n&&i.d.push(+e.slice(0,n)),r-=Ce;n<r;)i.d.push(+e.slice(n,n+=Ce));e=e.slice(n),n=Ce-e.length}else n-=r;for(;n--;)e+="0";i.d.push(+e),De&&(i.e>i.constructor.maxE?(i.d=null,i.e=NaN):i.e<i.constructor.minE&&(i.e=0,i.d=[0]))}else i.e=0,i.d=[0];return i}function h_(i,e){var t,n,r,s,o,a,u,h,c;if(e.indexOf("_")>-1){if(e=e.replace(/(\d)_(?=\d)/g,"$1"),ku.test(e))return ra(i,e)}else if(e==="Infinity"||e==="NaN")return+e||(i.s=NaN),i.e=NaN,i.d=null,i;if(o_.test(e))t=16,e=e.toLowerCase();else if(s_.test(e))t=2;else if(a_.test(e))t=8;else throw Error(Fn+e);for(s=e.search(/p/i),s>0?(u=+e.slice(s+1),e=e.substring(2,s)):e=e.slice(2),s=e.indexOf("."),o=s>=0,n=i.constructor,o&&(e=e.replace(".",""),a=e.length,s=a-s,r=qu(n,new n(t),s,s*2)),h=us(e,t,jt),c=h.length-1,s=c;h[s]===0;--s)h.pop();return s<0?new n(i.s*0):(i.e=Vs(h,c),i.d=h,De=!1,o&&(i=qe(i,r,a*4)),u&&(i=i.times(Math.abs(u)<54?lt(2,u):Ii.pow(2,u))),De=!0,i)}function f_(i,e){var t,n=e.d.length;if(n<3)return e.isZero()?e:Di(i,2,e,e);t=1.4*Math.sqrt(n),t=t>16?16:t|0,e=e.times(1/Gs(5,t)),e=Di(i,2,e,e);for(var r,s=new i(5),o=new i(16),a=new i(20);t--;)r=e.times(e),e=e.times(s.plus(r.times(o.times(r).minus(a))));return e}function Di(i,e,t,n,r){var s,o,a,u,h=i.precision,c=Math.ceil(h/Ce);for(De=!1,u=t.times(t),a=new i(n);;){if(o=qe(a.times(u),new i(e++*e++),h,1),a=r?n.plus(o):n.minus(o),n=qe(o.times(u),new i(e++*e++),h,1),o=a.plus(n),o.d[c]!==void 0){for(s=c;o.d[s]===a.d[s]&&s--;);if(s==-1)break}s=a,a=n,n=o,o=s}return De=!0,o.d.length=c+1,o}function Gs(i,e){for(var t=i;--e;)t*=i;return t}function Yu(i,e){var t,n=e.s<0,r=Yt(i,i.precision,1),s=r.times(.5);if(e=e.abs(),e.lte(s))return pn=n?4:1,e;if(t=e.divToInt(r),t.isZero())pn=n?3:2;else{if(e=e.minus(t.times(r)),e.lte(s))return pn=dc(t)?n?2:3:n?4:1,e;pn=dc(t)?n?1:4:n?3:2}return e.minus(r).abs()}function Ia(i,e,t,n){var r,s,o,a,u,h,c,l,f,d=i.constructor,v=t!==void 0;if(v?(Nt(t,1,On),n===void 0?n=d.rounding:Nt(n,0,8)):(t=d.precision,n=d.rounding),!i.isFinite())c=Zu(i);else{for(c=nn(i),o=c.indexOf("."),v?(r=2,e==16?t=t*4-3:e==8&&(t=t*3-2)):r=e,o>=0&&(c=c.replace(".",""),f=new d(1),f.e=c.length-o,f.d=us(nn(f),10,r),f.e=f.d.length),l=us(c,10,r),s=u=l.length;l[--u]==0;)l.pop();if(!l[0])c=v?"0p+0":"0";else{if(o<0?s--:(i=new d(i),i.d=l,i.e=s,i=qe(i,f,t,n,0,r),l=i.d,s=i.e,h=Uu),o=l[t],a=r/2,h=h||l[t+1]!==void 0,h=n<4?(o!==void 0||h)&&(n===0||n===(i.s<0?3:2)):o>a||o===a&&(n===4||h||n===6&&l[t-1]&1||n===(i.s<0?8:7)),l.length=t,h)for(;++l[--t]>r-1;)l[t]=0,t||(++s,l.unshift(1));for(u=l.length;!l[u-1];--u);for(o=0,c="";o<u;o++)c+=ea.charAt(l[o]);if(v){if(u>1)if(e==16||e==8){for(o=e==16?4:3,--u;u%o;u++)c+="0";for(l=us(c,r,e),u=l.length;!l[u-1];--u);for(o=1,c="1.";o<u;o++)c+=ea.charAt(l[o])}else c=c.charAt(0)+"."+c.slice(1);c=c+(s<0?"p":"p+")+s}else if(s<0){for(;++s;)c="0"+c;c="0."+c}else if(++s>u)for(s-=u;s--;)c+="0";else s<u&&(c=c.slice(0,s)+"."+c.slice(s))}c=(e==16?"0x":e==2?"0b":e==8?"0o":"")+c}return i.s<0?"-"+c:c}function pc(i,e){if(i.length>e)return i.length=e,!0}function d_(i){return new this(i).abs()}function p_(i){return new this(i).acos()}function m_(i){return new this(i).acosh()}function g_(i,e){return new this(i).plus(e)}function v_(i){return new this(i).asin()}function y_(i){return new this(i).asinh()}function __(i){return new this(i).atan()}function x_(i){return new this(i).atanh()}function w_(i,e){i=new this(i),e=new this(e);var t,n=this.precision,r=this.rounding,s=n+4;return!i.s||!e.s?t=new this(NaN):!i.d&&!e.d?(t=Yt(this,s,1).times(e.s>0?.25:.75),t.s=i.s):!e.d||i.isZero()?(t=e.s<0?Yt(this,n,r):new this(0),t.s=i.s):!i.d||e.isZero()?(t=Yt(this,s,1).times(.5),t.s=i.s):e.s<0?(this.precision=s,this.rounding=1,t=this.atan(qe(i,e,s,1)),e=Yt(this,s,1),this.precision=n,this.rounding=r,t=i.s<0?t.minus(e):t.plus(e)):t=this.atan(qe(i,e,s,1)),t}function M_(i){return new this(i).cbrt()}function b_(i){return be(i=new this(i),i.e+1,2)}function S_(i,e,t){return new this(i).clamp(e,t)}function E_(i){if(!i||typeof i!="object")throw Error(Hs+"Object expected");var e,t,n,r=i.defaults===!0,s=["precision",1,On,"rounding",0,8,"toExpNeg",-Si,0,"toExpPos",0,Si,"maxE",0,Si,"minE",-Si,0,"modulo",0,9];for(e=0;e<s.length;e+=3)if(t=s[e],r&&(this[t]=ta[t]),(n=i[t])!==void 0)if(wt(n)===n&&n>=s[e+1]&&n<=s[e+2])this[t]=n;else throw Error(Fn+t+": "+n);if(t="crypto",r&&(this[t]=ta[t]),(n=i[t])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto!="undefined"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Vu);else this[t]=!1;else throw Error(Fn+t+": "+n);return this}function T_(i){return new this(i).cos()}function A_(i){return new this(i).cosh()}function ju(i){var e,t,n;function r(s){var o,a,u,h=this;if(!(h instanceof r))return new r(s);if(h.constructor=r,mc(s)){h.s=s.s,De?!s.d||s.e>r.maxE?(h.e=NaN,h.d=null):s.e<r.minE?(h.e=0,h.d=[0]):(h.e=s.e,h.d=s.d.slice()):(h.e=s.e,h.d=s.d?s.d.slice():s.d);return}if(u=typeof s,u==="number"){if(s===0){h.s=1/s<0?-1:1,h.e=0,h.d=[0];return}if(s<0?(s=-s,h.s=-1):h.s=1,s===~~s&&s<1e7){for(o=0,a=s;a>=10;a/=10)o++;De?o>r.maxE?(h.e=NaN,h.d=null):o<r.minE?(h.e=0,h.d=[0]):(h.e=o,h.d=[s]):(h.e=o,h.d=[s]);return}else if(s*0!==0){s||(h.s=NaN),h.e=NaN,h.d=null;return}return ra(h,s.toString())}else if(u!=="string")throw Error(Fn+s);return(a=s.charCodeAt(0))===45?(s=s.slice(1),h.s=-1):(a===43&&(s=s.slice(1)),h.s=1),ku.test(s)?ra(h,s):h_(h,s)}if(r.prototype=re,r.ROUND_UP=0,r.ROUND_DOWN=1,r.ROUND_CEIL=2,r.ROUND_FLOOR=3,r.ROUND_HALF_UP=4,r.ROUND_HALF_DOWN=5,r.ROUND_HALF_EVEN=6,r.ROUND_HALF_CEIL=7,r.ROUND_HALF_FLOOR=8,r.EUCLID=9,r.config=r.set=E_,r.clone=ju,r.isDecimal=mc,r.abs=d_,r.acos=p_,r.acosh=m_,r.add=g_,r.asin=v_,r.asinh=y_,r.atan=__,r.atanh=x_,r.atan2=w_,r.cbrt=M_,r.ceil=b_,r.clamp=S_,r.cos=T_,r.cosh=A_,r.div=C_,r.exp=L_,r.floor=R_,r.hypot=P_,r.ln=N_,r.log=D_,r.log10=F_,r.log2=I_,r.max=z_,r.min=O_,r.mod=B_,r.mul=U_,r.pow=H_,r.random=V_,r.round=G_,r.sign=k_,r.sin=W_,r.sinh=q_,r.sqrt=X_,r.sub=Z_,r.sum=Y_,r.tan=j_,r.tanh=J_,r.trunc=$_,i===void 0&&(i={}),i&&i.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],e=0;e<n.length;)i.hasOwnProperty(t=n[e++])||(i[t]=this[t]);return r.config(i),r}function C_(i,e){return new this(i).div(e)}function L_(i){return new this(i).exp()}function R_(i){return be(i=new this(i),i.e+1,3)}function P_(){var i,e,t=new this(0);for(De=!1,i=0;i<arguments.length;)if(e=new this(arguments[i++]),e.d)t.d&&(t=t.plus(e.times(e)));else{if(e.s)return De=!0,new this(1/0);t=e}return De=!0,t.sqrt()}function mc(i){return i instanceof Ii||i&&i.toStringTag===Gu||!1}function N_(i){return new this(i).ln()}function D_(i,e){return new this(i).log(e)}function I_(i){return new this(i).log(2)}function F_(i){return new this(i).log(10)}function z_(){return Xu(this,arguments,"lt")}function O_(){return Xu(this,arguments,"gt")}function B_(i,e){return new this(i).mod(e)}function U_(i,e){return new this(i).mul(e)}function H_(i,e){return new this(i).pow(e)}function V_(i){var e,t,n,r,s=0,o=new this(1),a=[];if(i===void 0?i=this.precision:Nt(i,1,On),n=Math.ceil(i/Ce),this.crypto)if(crypto.getRandomValues)for(e=crypto.getRandomValues(new Uint32Array(n));s<n;)r=e[s],r>=429e7?e[s]=crypto.getRandomValues(new Uint32Array(1))[0]:a[s++]=r%1e7;else if(crypto.randomBytes){for(e=crypto.randomBytes(n*=4);s<n;)r=e[s]+(e[s+1]<<8)+(e[s+2]<<16)+((e[s+3]&127)<<24),r>=214e7?crypto.randomBytes(4).copy(e,s):(a.push(r%1e7),s+=4);s=n/4}else throw Error(Vu);else for(;s<n;)a[s++]=Math.random()*1e7|0;for(n=a[--s],i%=Ce,n&&i&&(r=lt(10,Ce-i),a[s]=(n/r|0)*r);a[s]===0;s--)a.pop();if(s<0)t=0,a=[0];else{for(t=-1;a[0]===0;t-=Ce)a.shift();for(n=1,r=a[0];r>=10;r/=10)n++;n<Ce&&(t-=Ce-n)}return o.e=t,o.d=a,o}function G_(i){return be(i=new this(i),i.e+1,this.rounding)}function k_(i){return i=new this(i),i.d?i.d[0]?i.s:0*i.s:i.s||NaN}function W_(i){return new this(i).sin()}function q_(i){return new this(i).sinh()}function X_(i){return new this(i).sqrt()}function Z_(i,e){return new this(i).sub(e)}function Y_(){var i=0,e=arguments,t=new this(e[i]);for(De=!1;t.s&&++i<e.length;)t=t.plus(e[i]);return De=!0,be(t,this.precision,this.rounding)}function j_(i){return new this(i).tan()}function J_(i){return new this(i).tanh()}function $_(i){return be(i=new this(i),i.e+1,1)}re[Symbol.for("nodejs.util.inspect.custom")]=re.toString;re[Symbol.toStringTag]="Decimal";var Ii=re.constructor=ju(ta);xs=new Ii(xs);ws=new Ii(ws);var Q_="BigNumber",K_=["?on","config"],ex=ft(Q_,K_,i=>{var{on:e,config:t}=i,n=Ii.clone({precision:t.precision,modulo:Ii.EUCLID});return n.prototype=Object.create(n.prototype),n.prototype.type="BigNumber",n.prototype.isBigNumber=!0,n.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},n.fromJSON=function(r){return new n(r.value)},e&&e("config",function(r,s){r.precision!==s.precision&&n.config({precision:r.precision})}),n},{isClass:!0}),Ju={exports:{}};/**
 * @license Complex.js v2.0.15 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/(function(i,e){(function(t){var n=function(l){return(Math.exp(l)+Math.exp(-l))*.5},r=function(l){return(Math.exp(l)-Math.exp(-l))*.5},s=function(l){var f=Math.PI/4;if(-f>l||l>f)return Math.cos(l)-1;var d=l*l;return d*(d*(d*(d*(d*(d*(d*(d/20922789888e3-11470745597729725e-27)+208767569878681e-23)-2755731922398589e-22)+248015873015873e-19)-.001388888888888889)+.041666666666666664)-.5)},o=function(l,f){var d=Math.abs(l),v=Math.abs(f);return d<3e3&&v<3e3?Math.sqrt(d*d+v*v):(d<v?(d=v,v=l/f):v=f/l,d*Math.sqrt(1+v*v))},a=function(){throw SyntaxError("Invalid Param")};function u(l,f){var d=Math.abs(l),v=Math.abs(f);return l===0?Math.log(v):f===0?Math.log(d):d<3e3&&v<3e3?Math.log(l*l+f*f)*.5:Math.log(l/Math.cos(Math.atan2(f,l)))}var h=function(l,f){var d={re:0,im:0};if(l==null)d.re=d.im=0;else if(f!==void 0)d.re=l,d.im=f;else switch(typeof l){case"object":if("im"in l&&"re"in l)d.re=l.re,d.im=l.im;else if("abs"in l&&"arg"in l){if(!Number.isFinite(l.abs)&&Number.isFinite(l.arg))return c.INFINITY;d.re=l.abs*Math.cos(l.arg),d.im=l.abs*Math.sin(l.arg)}else if("r"in l&&"phi"in l){if(!Number.isFinite(l.r)&&Number.isFinite(l.phi))return c.INFINITY;d.re=l.r*Math.cos(l.phi),d.im=l.r*Math.sin(l.phi)}else l.length===2?(d.re=l[0],d.im=l[1]):a();break;case"string":d.im=d.re=0;var v=l.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),m=1,y=0;v===null&&a();for(var p=0;p<v.length;p++){var g=v[p];g===" "||g==="	"||g===`
`||(g==="+"?m++:g==="-"?y++:g==="i"||g==="I"?(m+y===0&&a(),v[p+1]!==" "&&!isNaN(v[p+1])?(d.im+=parseFloat((y%2?"-":"")+v[p+1]),p++):d.im+=parseFloat((y%2?"-":"")+"1"),m=y=0):((m+y===0||isNaN(g))&&a(),v[p+1]==="i"||v[p+1]==="I"?(d.im+=parseFloat((y%2?"-":"")+g),p++):d.re+=parseFloat((y%2?"-":"")+g),m=y=0))}m+y>0&&a();break;case"number":d.im=0,d.re=l;break;default:a()}return isNaN(d.re)||isNaN(d.im),d};function c(l,f){if(!(this instanceof c))return new c(l,f);var d=h(l,f);this.re=d.re,this.im=d.im}c.prototype={re:0,im:0,sign:function(){var l=this.abs();return new c(this.re/l,this.im/l)},add:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:new c(this.re+d.re,this.im+d.im)},sub:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:new c(this.re-d.re,this.im-d.im)},mul:function(l,f){var d=new c(l,f);return this.isInfinite()&&d.isZero()||this.isZero()&&d.isInfinite()?c.NAN:this.isInfinite()||d.isInfinite()?c.INFINITY:d.im===0&&this.im===0?new c(this.re*d.re,0):new c(this.re*d.re-this.im*d.im,this.re*d.im+this.im*d.re)},div:function(l,f){var d=new c(l,f);if(this.isZero()&&d.isZero()||this.isInfinite()&&d.isInfinite())return c.NAN;if(this.isInfinite()||d.isZero())return c.INFINITY;if(this.isZero()||d.isInfinite())return c.ZERO;l=this.re,f=this.im;var v=d.re,m=d.im,y,p;return m===0?new c(l/v,f/v):Math.abs(v)<Math.abs(m)?(p=v/m,y=v*p+m,new c((l*p+f)/y,(f*p-l)/y)):(p=m/v,y=m*p+v,new c((l+f*p)/y,(f-l*p)/y))},pow:function(l,f){var d=new c(l,f);if(l=this.re,f=this.im,d.isZero())return c.ONE;if(d.im===0){if(f===0&&l>0)return new c(Math.pow(l,d.re),0);if(l===0)switch((d.re%4+4)%4){case 0:return new c(Math.pow(f,d.re),0);case 1:return new c(0,Math.pow(f,d.re));case 2:return new c(-Math.pow(f,d.re),0);case 3:return new c(0,-Math.pow(f,d.re))}}if(l===0&&f===0&&d.re>0&&d.im>=0)return c.ZERO;var v=Math.atan2(f,l),m=u(l,f);return l=Math.exp(d.re*m-d.im*v),f=d.im*m+d.re*v,new c(l*Math.cos(f),l*Math.sin(f))},sqrt:function(){var l=this.re,f=this.im,d=this.abs(),v,m;if(l>=0){if(f===0)return new c(Math.sqrt(l),0);v=.5*Math.sqrt(2*(d+l))}else v=Math.abs(f)/Math.sqrt(2*(d-l));return l<=0?m=.5*Math.sqrt(2*(d-l)):m=Math.abs(f)/Math.sqrt(2*(d+l)),new c(v,f<0?-m:m)},exp:function(){var l=Math.exp(this.re);return this.im===0,new c(l*Math.cos(this.im),l*Math.sin(this.im))},expm1:function(){var l=this.re,f=this.im;return new c(Math.expm1(l)*Math.cos(f)+s(f),Math.exp(l)*Math.sin(f))},log:function(){var l=this.re,f=this.im;return new c(u(l,f),Math.atan2(f,l))},abs:function(){return o(this.re,this.im)},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var l=this.re,f=this.im;return new c(Math.sin(l)*n(f),Math.cos(l)*r(f))},cos:function(){var l=this.re,f=this.im;return new c(Math.cos(l)*n(f),-Math.sin(l)*r(f))},tan:function(){var l=2*this.re,f=2*this.im,d=Math.cos(l)+n(f);return new c(Math.sin(l)/d,r(f)/d)},cot:function(){var l=2*this.re,f=2*this.im,d=Math.cos(l)-n(f);return new c(-Math.sin(l)/d,r(f)/d)},sec:function(){var l=this.re,f=this.im,d=.5*n(2*f)+.5*Math.cos(2*l);return new c(Math.cos(l)*n(f)/d,Math.sin(l)*r(f)/d)},csc:function(){var l=this.re,f=this.im,d=.5*n(2*f)-.5*Math.cos(2*l);return new c(Math.sin(l)*n(f)/d,-Math.cos(l)*r(f)/d)},asin:function(){var l=this.re,f=this.im,d=new c(f*f-l*l+1,-2*l*f).sqrt(),v=new c(d.re-f,d.im+l).log();return new c(v.im,-v.re)},acos:function(){var l=this.re,f=this.im,d=new c(f*f-l*l+1,-2*l*f).sqrt(),v=new c(d.re-f,d.im+l).log();return new c(Math.PI/2-v.im,v.re)},atan:function(){var l=this.re,f=this.im;if(l===0){if(f===1)return new c(0,1/0);if(f===-1)return new c(0,-1/0)}var d=l*l+(1-f)*(1-f),v=new c((1-f*f-l*l)/d,-2*l/d).log();return new c(-.5*v.im,.5*v.re)},acot:function(){var l=this.re,f=this.im;if(f===0)return new c(Math.atan2(1,l),0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).atan():new c(l!==0?l/0:0,f!==0?-f/0:0).atan()},asec:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(0,1/0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).acos():new c(l!==0?l/0:0,f!==0?-f/0:0).acos()},acsc:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(Math.PI/2,1/0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).asin():new c(l!==0?l/0:0,f!==0?-f/0:0).asin()},sinh:function(){var l=this.re,f=this.im;return new c(r(l)*Math.cos(f),n(l)*Math.sin(f))},cosh:function(){var l=this.re,f=this.im;return new c(n(l)*Math.cos(f),r(l)*Math.sin(f))},tanh:function(){var l=2*this.re,f=2*this.im,d=n(l)+Math.cos(f);return new c(r(l)/d,Math.sin(f)/d)},coth:function(){var l=2*this.re,f=2*this.im,d=n(l)-Math.cos(f);return new c(r(l)/d,-Math.sin(f)/d)},csch:function(){var l=this.re,f=this.im,d=Math.cos(2*f)-n(2*l);return new c(-2*r(l)*Math.cos(f)/d,2*n(l)*Math.sin(f)/d)},sech:function(){var l=this.re,f=this.im,d=Math.cos(2*f)+n(2*l);return new c(2*n(l)*Math.cos(f)/d,-2*r(l)*Math.sin(f)/d)},asinh:function(){var l=this.im;this.im=-this.re,this.re=l;var f=this.asin();return this.re=-this.im,this.im=l,l=f.re,f.re=-f.im,f.im=l,f},acosh:function(){var l=this.acos();if(l.im<=0){var f=l.re;l.re=-l.im,l.im=f}else{var f=l.im;l.im=-l.re,l.re=f}return l},atanh:function(){var l=this.re,f=this.im,d=l>1&&f===0,v=1-l,m=1+l,y=v*v+f*f,p=y!==0?new c((m*v-f*f)/y,(f*v+m*f)/y):new c(l!==-1?l/0:0,f!==0?f/0:0),g=p.re;return p.re=u(p.re,p.im)/2,p.im=Math.atan2(p.im,g)/2,d&&(p.im=-p.im),p},acoth:function(){var l=this.re,f=this.im;if(l===0&&f===0)return new c(0,Math.PI/2);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).atanh():new c(l!==0?l/0:0,f!==0?-f/0:0).atanh()},acsch:function(){var l=this.re,f=this.im;if(f===0)return new c(l!==0?Math.log(l+Math.sqrt(l*l+1)):1/0,0);var d=l*l+f*f;return d!==0?new c(l/d,-f/d).asinh():new c(l!==0?l/0:0,f!==0?-f/0:0).asinh()},asech:function(){var l=this.re,f=this.im;if(this.isZero())return c.INFINITY;var d=l*l+f*f;return d!==0?new c(l/d,-f/d).acosh():new c(l!==0?l/0:0,f!==0?-f/0:0).acosh()},inverse:function(){if(this.isZero())return c.INFINITY;if(this.isInfinite())return c.ZERO;var l=this.re,f=this.im,d=l*l+f*f;return new c(l/d,-f/d)},conjugate:function(){return new c(this.re,-this.im)},neg:function(){return new c(-this.re,-this.im)},ceil:function(l){return l=Math.pow(10,l||0),new c(Math.ceil(this.re*l)/l,Math.ceil(this.im*l)/l)},floor:function(l){return l=Math.pow(10,l||0),new c(Math.floor(this.re*l)/l,Math.floor(this.im*l)/l)},round:function(l){return l=Math.pow(10,l||0),new c(Math.round(this.re*l)/l,Math.round(this.im*l)/l)},equals:function(l,f){var d=new c(l,f);return Math.abs(d.re-this.re)<=c.EPSILON&&Math.abs(d.im-this.im)<=c.EPSILON},clone:function(){return new c(this.re,this.im)},toString:function(){var l=this.re,f=this.im,d="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(l)<c.EPSILON&&(l=0),Math.abs(f)<c.EPSILON&&(f=0),f===0?d+l:(l!==0?(d+=l,d+=" ",f<0?(f=-f,d+="-"):d+="+",d+=" "):f<0&&(f=-f,d+="-"),f!==1&&(d+=f),d+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return this.im===0?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return this.im===0&&this.re===0},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},c.ZERO=new c(0,0),c.ONE=new c(1,0),c.I=new c(0,1),c.PI=new c(Math.PI,0),c.E=new c(Math.E,0),c.INFINITY=new c(1/0,1/0),c.NAN=new c(NaN,NaN),c.EPSILON=1e-15,Object.defineProperty(c,"__esModule",{value:!0}),c.default=c,c.Complex=c,i.exports=c})()})(Ju);var Tt=Cu(Ju.exports),tx="Complex",nx=[],ix=ft(tx,nx,()=>(Tt.prototype.type="Complex",Tt.prototype.isComplex=!0,Tt.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},Tt.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},Tt.prototype.format=function(i){var e="",t=this.im,n=this.re,r=Qo(this.re,i),s=Qo(this.im,i),o=it(i)?i:i?i.precision:null;if(o!==null){var a=Math.pow(10,-o);Math.abs(n/t)<a&&(n=0),Math.abs(t/n)<a&&(t=0)}return t===0?e=r:n===0?t===1?e="i":t===-1?e="-i":e=s+"i":t<0?t===-1?e=r+" - i":e=r+" - "+s.substring(1)+"i":t===1?e=r+" + i":e=r+" + "+s+"i",e},Tt.fromPolar=function(i){switch(arguments.length){case 1:{var e=arguments[0];if(typeof e=="object")return Tt(e);throw new TypeError("Input has to be an object with r and phi keys.")}case 2:{var t=arguments[0],n=arguments[1];if(it(t)){if(Na(n)&&n.hasBase("ANGLE")&&(n=n.toNumber("rad")),it(n))return new Tt({r:t,phi:n});throw new TypeError("Phi is not a number nor an angle unit.")}else throw new TypeError("Radius r is not a number.")}default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},Tt.prototype.valueOf=Tt.prototype.toString,Tt.fromJSON=function(i){return new Tt(i)},Tt.compare=function(i,e){return i.re>e.re?1:i.re<e.re?-1:i.im>e.im?1:i.im<e.im?-1:0},Tt),{isClass:!0}),$u={exports:{}};/**
 * @license Fraction.js v4.1.3 23/05/2021
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/(function(i,e){(function(t){var n=2e3,r={s:1,n:0,d:1};function s(p){function g(){var x=Error.apply(this,arguments);x.name=this.name=p,this.stack=x.stack,this.message=x.message}function _(){}return _.prototype=Error.prototype,g.prototype=new _,g}var o=y.DivisionByZero=s("DivisionByZero"),a=y.InvalidParameter=s("InvalidParameter");function u(p,g){return isNaN(p=parseInt(p,10))&&h(),p*g}function h(){throw new a}function c(p){for(var g={},_=p,x=2,M=4;M<=_;){for(;_%x===0;)_/=x,g[x]=(g[x]||0)+1;M+=1+2*x++}return _!==p?_>1&&(g[_]=(g[_]||0)+1):g[p]=(g[p]||0)+1,g}var l=function(p,g){var _=0,x=1,M=1,S=0,w=0,C=0,D=1,I=1,T=0,B=1,O=1,F=1,z=1e7,N;if(p!=null)if(g!==void 0)_=p,x=g,M=_*x;else switch(typeof p){case"object":{"d"in p&&"n"in p?(_=p.n,x=p.d,"s"in p&&(_*=p.s)):0 in p?(_=p[0],1 in p&&(x=p[1])):h(),M=_*x;break}case"number":{if(p<0&&(M=p,p=-p),p%1===0)_=p;else if(p>0){for(p>=1&&(I=Math.pow(10,Math.floor(1+Math.log(p)/Math.LN10)),p/=I);B<=z&&F<=z;)if(N=(T+O)/(B+F),p===N){B+F<=z?(_=T+O,x=B+F):F>B?(_=O,x=F):(_=T,x=B);break}else p>N?(T+=O,B+=F):(O+=T,F+=B),B>z?(_=O,x=F):(_=T,x=B);_*=I}else(isNaN(p)||isNaN(g))&&(x=_=NaN);break}case"string":if(B=p.match(/\d+|./g),B===null&&h(),B[T]==="-"?(M=-1,T++):B[T]==="+"&&T++,B.length===T+1?w=u(B[T++],M):B[T+1]==="."||B[T]==="."?(B[T]!=="."&&(S=u(B[T++],M)),T++,(T+1===B.length||B[T+1]==="("&&B[T+3]===")"||B[T+1]==="'"&&B[T+3]==="'")&&(w=u(B[T],M),D=Math.pow(10,B[T].length),T++),(B[T]==="("&&B[T+2]===")"||B[T]==="'"&&B[T+2]==="'")&&(C=u(B[T+1],M),I=Math.pow(10,B[T+1].length)-1,T+=3)):B[T+1]==="/"||B[T+1]===":"?(w=u(B[T],M),D=u(B[T+2],1),T+=3):B[T+3]==="/"&&B[T+1]===" "&&(S=u(B[T],M),w=u(B[T+2],M),D=u(B[T+4],1),T+=5),B.length<=T){x=D*I,M=_=C+x*S+I*w;break}default:h()}if(x===0)throw new o;r.s=M<0?-1:1,r.n=Math.abs(_),r.d=Math.abs(x)};function f(p,g,_){for(var x=1;g>0;p=p*p%_,g>>=1)g&1&&(x=x*p%_);return x}function d(p,g){for(;g%2===0;g/=2);for(;g%5===0;g/=5);if(g===1)return 0;for(var _=10%g,x=1;_!==1;x++)if(_=_*10%g,x>n)return 0;return x}function v(p,g,_){for(var x=1,M=f(10,_,g),S=0;S<300;S++){if(x===M)return S;x=x*10%g,M=M*10%g}return 0}function m(p,g){if(!p)return g;if(!g)return p;for(;;){if(p%=g,!p)return g;if(g%=p,!g)return p}}function y(p,g){if(!(this instanceof y))return new y(p,g);l(p,g),p=m(r.d,r.n),this.s=r.s,this.n=r.n/p,this.d=r.d/p}y.prototype={s:1,n:0,d:1,abs:function(){return new y(this.n,this.d)},neg:function(){return new y(-this.s*this.n,this.d)},add:function(p,g){return l(p,g),new y(this.s*this.n*r.d+r.s*this.d*r.n,this.d*r.d)},sub:function(p,g){return l(p,g),new y(this.s*this.n*r.d-r.s*this.d*r.n,this.d*r.d)},mul:function(p,g){return l(p,g),new y(this.s*r.s*this.n*r.n,this.d*r.d)},div:function(p,g){return l(p,g),new y(this.s*r.s*this.n*r.d,this.d*r.n)},clone:function(){return new y(this)},mod:function(p,g){return isNaN(this.n)||isNaN(this.d)?new y(NaN):p===void 0?new y(this.s*this.n%this.d,1):(l(p,g),r.n===0&&this.d===0&&y(0,0),new y(this.s*(r.d*this.n)%(r.n*this.d),r.d*this.d))},gcd:function(p,g){return l(p,g),new y(m(r.n,this.n)*m(r.d,this.d),r.d*this.d)},lcm:function(p,g){return l(p,g),r.n===0&&this.n===0?new y:new y(r.n*this.n,m(r.n,this.n)*m(r.d,this.d))},ceil:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new y(NaN):new y(Math.ceil(p*this.s*this.n/this.d),p)},floor:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new y(NaN):new y(Math.floor(p*this.s*this.n/this.d),p)},round:function(p){return p=Math.pow(10,p||0),isNaN(this.n)||isNaN(this.d)?new y(NaN):new y(Math.round(p*this.s*this.n/this.d),p)},inverse:function(){return new y(this.s*this.d,this.n)},pow:function(p,g){if(l(p,g),r.d===1)return r.s<0?new y(Math.pow(this.s*this.d,r.n),Math.pow(this.n,r.n)):new y(Math.pow(this.s*this.n,r.n),Math.pow(this.d,r.n));if(this.s<0)return null;var _=c(this.n),x=c(this.d),M=1,S=1;for(var w in _)if(w!=="1"){if(w==="0"){M=0;break}if(_[w]*=r.n,_[w]%r.d===0)_[w]/=r.d;else return null;M*=Math.pow(w,_[w])}for(var w in x)if(w!=="1"){if(x[w]*=r.n,x[w]%r.d===0)x[w]/=r.d;else return null;S*=Math.pow(w,x[w])}return r.s<0?new y(S,M):new y(M,S)},equals:function(p,g){return l(p,g),this.s*this.n*r.d===r.s*r.n*this.d},compare:function(p,g){l(p,g);var _=this.s*this.n*r.d-r.s*r.n*this.d;return(0<_)-(_<0)},simplify:function(p){if(isNaN(this.n)||isNaN(this.d))return this;var g=this.abs().toContinued();p=p||.001;function _(S){return S.length===1?new y(S[0]):_(S.slice(1)).inverse().add(S[0])}for(var x=0;x<g.length;x++){var M=_(g.slice(0,x+1));if(M.sub(this.abs()).abs().valueOf()<p)return M.mul(this.s)}return this},divisible:function(p,g){return l(p,g),!(!(r.n*this.d)||this.n*r.d%(r.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(p){var g,_="",x=this.n,M=this.d;return this.s<0&&(_+="-"),M===1?_+=x:(p&&(g=Math.floor(x/M))>0&&(_+=g,_+=" ",x%=M),_+=x,_+="/",_+=M),_},toLatex:function(p){var g,_="",x=this.n,M=this.d;return this.s<0&&(_+="-"),M===1?_+=x:(p&&(g=Math.floor(x/M))>0&&(_+=g,x%=M),_+="\\frac{",_+=x,_+="}{",_+=M,_+="}"),_},toContinued:function(){var p,g=this.n,_=this.d,x=[];if(isNaN(g)||isNaN(_))return x;do x.push(Math.floor(g/_)),p=g%_,g=_,_=p;while(g!==1);return x},toString:function(p){var g=this.n,_=this.d;if(isNaN(g)||isNaN(_))return"NaN";p=p||15;var x=d(g,_),M=v(g,_,x),S=this.s===-1?"-":"";if(S+=g/_|0,g%=_,g*=10,g&&(S+="."),x){for(var w=M;w--;)S+=g/_|0,g%=_,g*=10;S+="(";for(var w=x;w--;)S+=g/_|0,g%=_,g*=10;S+=")"}else for(var w=p;g&&w--;)S+=g/_|0,g%=_,g*=10;return S}},Object.defineProperty(y,"__esModule",{value:!0}),y.default=y,y.Fraction=y,i.exports=y})()})($u);var _i=Cu($u.exports),rx="Fraction",sx=[],ox=ft(rx,sx,()=>(_i.prototype.type="Fraction",_i.prototype.isFraction=!0,_i.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},_i.fromJSON=function(i){return new _i(i)},_i),{isClass:!0}),ax="Matrix",lx=[],cx=ft(ax,lx,()=>{function i(){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator")}return i.prototype.type="Matrix",i.prototype.isMatrix=!0,i.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},i.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},i.prototype.create=function(e,t){throw new Error("Cannot invoke create on a Matrix interface")},i.prototype.subset=function(e,t,n){throw new Error("Cannot invoke subset on a Matrix interface")},i.prototype.get=function(e){throw new Error("Cannot invoke get on a Matrix interface")},i.prototype.set=function(e,t,n){throw new Error("Cannot invoke set on a Matrix interface")},i.prototype.resize=function(e,t){throw new Error("Cannot invoke resize on a Matrix interface")},i.prototype.reshape=function(e,t){throw new Error("Cannot invoke reshape on a Matrix interface")},i.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},i.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},i.prototype.map=function(e,t){throw new Error("Cannot invoke map on a Matrix interface")},i.prototype.forEach=function(e){throw new Error("Cannot invoke forEach on a Matrix interface")},i.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},i.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},i.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},i.prototype.format=function(e){throw new Error("Cannot invoke format on a Matrix interface")},i.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},i},{isClass:!0}),ux="DenseMatrix",hx=["Matrix"],fx=ft(ux,hx,i=>{var{Matrix:e}=i;function t(c,l){if(!(this instanceof t))throw new SyntaxError("Constructor must be called with the new operator");if(l&&!dn(l))throw new Error("Invalid datatype: "+l);if(bt(c))c.type==="DenseMatrix"?(this._data=pt(c._data),this._size=pt(c._size),this._datatype=l||c._datatype):(this._data=c.toArray(),this._size=c.size(),this._datatype=l||c._datatype);else if(c&&$e(c.data)&&$e(c.size))this._data=c.data,this._size=c.size,hc(this._data,this._size),this._datatype=l||c.datatype;else if($e(c))this._data=h(c),this._size=$n(this._data),hc(this._data,this._size),this._datatype=l;else{if(c)throw new TypeError("Unsupported type of data ("+ur(c)+")");this._data=[],this._size=[0],this._datatype=l}}t.prototype=new e,t.prototype.createDenseMatrix=function(c,l){return new t(c,l)},t.prototype.type="DenseMatrix",t.prototype.isDenseMatrix=!0,t.prototype.getDataType=function(){return _s(this._data,ur)},t.prototype.storage=function(){return"dense"},t.prototype.datatype=function(){return this._datatype},t.prototype.create=function(c,l){return new t(c,l)},t.prototype.subset=function(c,l,f){switch(arguments.length){case 1:return n(this,c);case 2:case 3:return s(this,c,l,f);default:throw new SyntaxError("Wrong number of arguments")}},t.prototype.get=function(c){if(!$e(c))throw new TypeError("Array expected");if(c.length!==this._size.length)throw new et(c.length,this._size.length);for(var l=0;l<c.length;l++)Qe(c[l],this._size[l]);for(var f=this._data,d=0,v=c.length;d<v;d++){var m=c[d];Qe(m,f.length),f=f[m]}return f},t.prototype.set=function(c,l,f){if(!$e(c))throw new TypeError("Array expected");if(c.length<this._size.length)throw new et(c.length,this._size.length,"<");var d,v,m,y=c.map(function(g){return g+1});u(this,y,f);var p=this._data;for(d=0,v=c.length-1;d<v;d++)m=c[d],Qe(m,p.length),p=p[m];return m=c[c.length-1],Qe(m,p.length),p[m]=l,this};function n(c,l){if(!zs(l))throw new TypeError("Invalid index");var f=l.isScalar();if(f)return c.get(l.min());var d=l.size();if(d.length!==c._size.length)throw new et(d.length,c._size.length);for(var v=l.min(),m=l.max(),y=0,p=c._size.length;y<p;y++)Qe(v[y],c._size[y]),Qe(m[y],c._size[y]);return new t(r(c._data,l,d.length,0),c._datatype)}function r(c,l,f,d){var v=d===f-1,m=l.dimension(d);return v?m.map(function(y){return Qe(y,c.length),c[y]}).valueOf():m.map(function(y){Qe(y,c.length);var p=c[y];return r(p,l,f,d+1)}).valueOf()}function s(c,l,f,d){if(!l||l.isIndex!==!0)throw new TypeError("Invalid index");var v=l.size(),m=l.isScalar(),y;if(bt(f)?(y=f.size(),f=f.valueOf()):y=$n(f),m){if(y.length!==0)throw new TypeError("Scalar expected");c.set(l.min(),f,d)}else{if(v.length<c._size.length)throw new et(v.length,c._size.length,"<");if(y.length<v.length){for(var p=0,g=0;v[p]===1&&y[p]===1;)p++;for(;v[p]===1;)g++,p++;f=Iu(f,v.length,g,y)}if(!vs(v,y))throw new et(v,y,">");var _=l.max().map(function(S){return S+1});u(c,_,d);var x=v.length,M=0;o(c._data,l,f,x,M)}return c}function o(c,l,f,d,v){var m=v===d-1,y=l.dimension(v);m?y.forEach(function(p,g){Qe(p),c[p]=f[g[0]]}):y.forEach(function(p,g){Qe(p),o(c[p],l,f[g[0]],d,v+1)})}t.prototype.resize=function(c,l,f){if(!Mu(c))throw new TypeError("Array or Matrix expected");var d=c.valueOf().map(m=>Array.isArray(m)&&m.length===1?m[0]:m),v=f?this.clone():this;return a(v,d,l)};function a(c,l,f){if(l.length===0){for(var d=c._data;$e(d);)d=d[0];return d}return c._size=l.slice(0),c._data=fc(c._data,c._size,f),c}t.prototype.reshape=function(c,l){var f=l?this.clone():this;f._data=Gy(f._data,c);var d=f._size.reduce((v,m)=>v*m);return f._size=Da(c,d),f};function u(c,l,f){for(var d=c._size.slice(0),v=!1;d.length<l.length;)d.push(0),v=!0;for(var m=0,y=l.length;m<y;m++)l[m]>d[m]&&(d[m]=l[m],v=!0);v&&a(c,d,f)}t.prototype.clone=function(){var c=new t({data:pt(this._data),size:pt(this._size),datatype:this._datatype});return c},t.prototype.size=function(){return this._size.slice(0)},t.prototype.map=function(c){var l=this,f=function m(y,p){return $e(y)?y.map(function(g,_){return m(g,p.concat(_))}):c(y,p,l)},d=f(this._data,[]),v=this._datatype!==void 0?_s(d,ur):void 0;return new t(d,v)},t.prototype.forEach=function(c){var l=this,f=function d(v,m){$e(v)?v.forEach(function(y,p){d(y,m.concat(p))}):c(v,m,l)};f(this._data,[])},t.prototype[Symbol.iterator]=function*(){var c=function*l(f,d){if($e(f))for(var v=0;v<f.length;v++)yield*l(f[v],d.concat(v));else yield{value:f,index:d}};yield*c(this._data,[])},t.prototype.rows=function(){var c=[],l=this.size();if(l.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");var f=this._data;for(var d of f)c.push(new t([d],this._datatype));return c},t.prototype.columns=function(){var c=this,l=[],f=this.size();if(f.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var d=this._data,v=function(p){var g=d.map(_=>[_[p]]);l.push(new t(g,c._datatype))},m=0;m<f[1];m++)v(m);return l},t.prototype.toArray=function(){return pt(this._data)},t.prototype.valueOf=function(){return this._data},t.prototype.format=function(c){return At(this._data,c)},t.prototype.toString=function(){return At(this._data)},t.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},t.prototype.diagonal=function(c){if(c){if(Zt(c)&&(c=c.toNumber()),!it(c)||!mt(c))throw new TypeError("The parameter k must be an integer number")}else c=0;for(var l=c>0?c:0,f=c<0?-c:0,d=this._size[0],v=this._size[1],m=Math.min(d-f,v-l),y=[],p=0;p<m;p++)y[p]=this._data[p+f][p+l];return new t({data:y,size:[m],datatype:this._datatype})},t.diagonal=function(c,l,f,d){if(!$e(c))throw new TypeError("Array expected, size parameter");if(c.length!==2)throw new Error("Only two dimensions matrix are supported");if(c=c.map(function(w){if(Zt(w)&&(w=w.toNumber()),!it(w)||!mt(w)||w<1)throw new Error("Size values must be positive integers");return w}),f){if(Zt(f)&&(f=f.toNumber()),!it(f)||!mt(f))throw new TypeError("The parameter k must be an integer number")}else f=0;var v=f>0?f:0,m=f<0?-f:0,y=c[0],p=c[1],g=Math.min(y-m,p-v),_;if($e(l)){if(l.length!==g)throw new Error("Invalid value array length");_=function(C){return l[C]}}else if(bt(l)){var x=l.size();if(x.length!==1||x[0]!==g)throw new Error("Invalid matrix length");_=function(C){return l.get([C])}}else _=function(){return l};d||(d=Zt(_(0))?_(0).mul(0):0);var M=[];if(c.length>0){M=fc(M,c,d);for(var S=0;S<g;S++)M[S+m][S+v]=_(S)}return new t({data:M,size:[y,p]})},t.fromJSON=function(c){return new t(c)},t.prototype.swapRows=function(c,l){if(!it(c)||!mt(c)||!it(l)||!mt(l))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return Qe(c,this._size[0]),Qe(l,this._size[0]),t._swapRows(c,l,this._data),this},t._swapRows=function(c,l,f){var d=f[c];f[c]=f[l],f[l]=d};function h(c){for(var l=0,f=c.length;l<f;l++){var d=c[l];$e(d)?c[l]=h(d):d&&d.isMatrix===!0&&(c[l]=h(d.valueOf()))}return c}return t},{isClass:!0});function Qu(i,e,t){return i&&typeof i.map=="function"?i.map(function(n){return Qu(n,e)}):e(i)}var Ku="number, number";function eh(i,e){return i+e}eh.signature=Ku;function th(i,e){return i*e}th.signature=Ku;function dx(i,e,t){if(t==null)return i.eq(e);if(i.eq(e))return!0;if(i.isNaN()||e.isNaN())return!1;if(i.isFinite()&&e.isFinite()){var n=i.minus(e).abs();if(n.isZero())return!0;var r=i.constructor.max(i.abs(),e.abs());return n.lte(r.times(t))}return!1}function px(i,e,t){return ys(i.re,e.re,t)&&ys(i.im,e.im,t)}var bs="equalScalar",mx=["typed","config"],gx=ft(bs,mx,i=>{var{typed:e,config:t}=i;return e(bs,{"boolean, boolean":function(r,s){return r===s},"number, number":function(r,s){return ys(r,s,t.epsilon)},"BigNumber, BigNumber":function(r,s){return r.eq(s)||dx(r,s,t.epsilon)},"Fraction, Fraction":function(r,s){return r.equals(s)},"Complex, Complex":function(r,s){return px(r,s,t.epsilon)},"Unit, Unit":function(r,s){if(!r.equalBase(s))throw new Error("Cannot compare units with different base");return this(r.value,s.value)}})});ft(bs,["typed","config"],i=>{var{typed:e,config:t}=i;return e(bs,{"number, number":function(r,s){return ys(r,s,t.epsilon)}})});var vx="SparseMatrix",yx=["typed","equalScalar","Matrix"],_x=ft(vx,yx,i=>{var{typed:e,equalScalar:t,Matrix:n}=i;function r(m,y){if(!(this instanceof r))throw new SyntaxError("Constructor must be called with the new operator");if(y&&!dn(y))throw new Error("Invalid datatype: "+y);if(bt(m))s(this,m,y);else if(m&&$e(m.index)&&$e(m.ptr)&&$e(m.size))this._values=m.values,this._index=m.index,this._ptr=m.ptr,this._size=m.size,this._datatype=y||m.datatype;else if($e(m))o(this,m,y);else{if(m)throw new TypeError("Unsupported type of data ("+ur(m)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=y}}function s(m,y,p){y.type==="SparseMatrix"?(m._values=y._values?pt(y._values):void 0,m._index=pt(y._index),m._ptr=pt(y._ptr),m._size=pt(y._size),m._datatype=p||y._datatype):o(m,y.valueOf(),p||y._datatype)}function o(m,y,p){m._values=[],m._index=[],m._ptr=[],m._datatype=p;var g=y.length,_=0,x=t,M=0;if(dn(p)&&(x=e.find(t,[p,p])||t,M=e.convert(0,p)),g>0){var S=0;do{m._ptr.push(m._index.length);for(var w=0;w<g;w++){var C=y[w];if($e(C)){if(S===0&&_<C.length&&(_=C.length),S<C.length){var D=C[S];x(D,M)||(m._values.push(D),m._index.push(w))}}else S===0&&_<1&&(_=1),x(C,M)||(m._values.push(C),m._index.push(w))}S++}while(S<_)}m._ptr.push(m._index.length),m._size=[g,_]}r.prototype=new n,r.prototype.createSparseMatrix=function(m,y){return new r(m,y)},r.prototype.type="SparseMatrix",r.prototype.isSparseMatrix=!0,r.prototype.getDataType=function(){return _s(this._values,ur)},r.prototype.storage=function(){return"sparse"},r.prototype.datatype=function(){return this._datatype},r.prototype.create=function(m,y){return new r(m,y)},r.prototype.density=function(){var m=this._size[0],y=this._size[1];return m!==0&&y!==0?this._index.length/(m*y):0},r.prototype.subset=function(m,y,p){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return a(this,m);case 2:case 3:return u(this,m,y,p);default:throw new SyntaxError("Wrong number of arguments")}};function a(m,y){if(!zs(y))throw new TypeError("Invalid index");var p=y.isScalar();if(p)return m.get(y.min());var g=y.size();if(g.length!==m._size.length)throw new et(g.length,m._size.length);var _,x,M,S,w=y.min(),C=y.max();for(_=0,x=m._size.length;_<x;_++)Qe(w[_],m._size[_]),Qe(C[_],m._size[_]);var D=m._values,I=m._index,T=m._ptr,B=y.dimension(0),O=y.dimension(1),F=[],z=[];B.forEach(function(ee,k){z[ee]=k[0],F[ee]=!0});var N=D?[]:void 0,U=[],Y=[];return O.forEach(function(ee){for(Y.push(U.length),M=T[ee],S=T[ee+1];M<S;M++)_=I[M],F[_]===!0&&(U.push(z[_]),N&&N.push(D[M]))}),Y.push(U.length),new r({values:N,index:U,ptr:Y,size:g,datatype:m._datatype})}function u(m,y,p,g){if(!y||y.isIndex!==!0)throw new TypeError("Invalid index");var _=y.size(),x=y.isScalar(),M;if(bt(p)?(M=p.size(),p=p.toArray()):M=$n(p),x){if(M.length!==0)throw new TypeError("Scalar expected");m.set(y.min(),p,g)}else{if(_.length!==1&&_.length!==2)throw new et(_.length,m._size.length,"<");if(M.length<_.length){for(var S=0,w=0;_[S]===1&&M[S]===1;)S++;for(;_[S]===1;)w++,S++;p=Iu(p,_.length,w,M)}if(!vs(_,M))throw new et(_,M,">");if(_.length===1){var C=y.dimension(0);C.forEach(function(T,B){Qe(T),m.set([T,0],p[B[0]],g)})}else{var D=y.dimension(0),I=y.dimension(1);D.forEach(function(T,B){Qe(T),I.forEach(function(O,F){Qe(O),m.set([T,O],p[B[0]][F[0]],g)})})}}return m}r.prototype.get=function(m){if(!$e(m))throw new TypeError("Array expected");if(m.length!==this._size.length)throw new et(m.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var y=m[0],p=m[1];Qe(y,this._size[0]),Qe(p,this._size[1]);var g=h(y,this._ptr[p],this._ptr[p+1],this._index);return g<this._ptr[p+1]&&this._index[g]===y?this._values[g]:0},r.prototype.set=function(m,y,p){if(!$e(m))throw new TypeError("Array expected");if(m.length!==this._size.length)throw new et(m.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var g=m[0],_=m[1],x=this._size[0],M=this._size[1],S=t,w=0;dn(this._datatype)&&(S=e.find(t,[this._datatype,this._datatype])||t,w=e.convert(0,this._datatype)),(g>x-1||_>M-1)&&(f(this,Math.max(g+1,x),Math.max(_+1,M),p),x=this._size[0],M=this._size[1]),Qe(g,x),Qe(_,M);var C=h(g,this._ptr[_],this._ptr[_+1],this._index);return C<this._ptr[_+1]&&this._index[C]===g?S(y,w)?c(C,_,this._values,this._index,this._ptr):this._values[C]=y:l(C,g,_,y,this._values,this._index,this._ptr),this};function h(m,y,p,g){if(p-y===0)return p;for(var _=y;_<p;_++)if(g[_]===m)return _;return y}function c(m,y,p,g,_){p.splice(m,1),g.splice(m,1);for(var x=y+1;x<_.length;x++)_[x]--}function l(m,y,p,g,_,x,M){_.splice(m,0,g),x.splice(m,0,y);for(var S=p+1;S<M.length;S++)M[S]++}r.prototype.resize=function(m,y,p){if(!Mu(m))throw new TypeError("Array or Matrix expected");var g=m.valueOf().map(x=>Array.isArray(x)&&x.length===1?x[0]:x);if(g.length!==2)throw new Error("Only two dimensions matrix are supported");g.forEach(function(x){if(!it(x)||!mt(x)||x<0)throw new TypeError("Invalid size, must contain positive integers (size: "+At(g)+")")});var _=p?this.clone():this;return f(_,g[0],g[1],y)};function f(m,y,p,g){var _=g||0,x=t,M=0;dn(m._datatype)&&(x=e.find(t,[m._datatype,m._datatype])||t,M=e.convert(0,m._datatype),_=e.convert(_,m._datatype));var S=!x(_,M),w=m._size[0],C=m._size[1],D,I,T;if(p>C){for(I=C;I<p;I++)if(m._ptr[I]=m._values.length,S)for(D=0;D<w;D++)m._values.push(_),m._index.push(D);m._ptr[p]=m._values.length}else p<C&&(m._ptr.splice(p+1,C-p),m._values.splice(m._ptr[p],m._values.length),m._index.splice(m._ptr[p],m._index.length));if(C=p,y>w){if(S){var B=0;for(I=0;I<C;I++){m._ptr[I]=m._ptr[I]+B,T=m._ptr[I+1]+B;var O=0;for(D=w;D<y;D++,O++)m._values.splice(T+O,0,_),m._index.splice(T+O,0,D),B++}m._ptr[C]=m._values.length}}else if(y<w){var F=0;for(I=0;I<C;I++){m._ptr[I]=m._ptr[I]-F;var z=m._ptr[I],N=m._ptr[I+1]-F;for(T=z;T<N;T++)D=m._index[T],D>y-1&&(m._values.splice(T,1),m._index.splice(T,1),F++)}m._ptr[I]=m._values.length}return m._size[0]=y,m._size[1]=p,m}r.prototype.reshape=function(m,y){if(!$e(m))throw new TypeError("Array expected");if(m.length!==2)throw new Error("Sparse matrices can only be reshaped in two dimensions");m.forEach(function(ee){if(!it(ee)||!mt(ee)||ee<=-2||ee===0)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+At(m)+")")});var p=this._size[0]*this._size[1];m=Da(m,p);var g=m[0]*m[1];if(p!==g)throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var _=y?this.clone():this;if(this._size[0]===m[0]&&this._size[1]===m[1])return _;for(var x=[],M=0;M<_._ptr.length;M++)for(var S=0;S<_._ptr[M+1]-_._ptr[M];S++)x.push(M);for(var w=_._values.slice(),C=_._index.slice(),D=0;D<_._index.length;D++){var I=C[D],T=x[D],B=I*_._size[1]+T;x[D]=B%m[1],C[D]=Math.floor(B/m[1])}_._values.length=0,_._index.length=0,_._ptr.length=m[1]+1,_._size=m.slice();for(var O=0;O<_._ptr.length;O++)_._ptr[O]=0;for(var F=0;F<w.length;F++){var z=C[F],N=x[F],U=w[F],Y=h(z,_._ptr[N],_._ptr[N+1],_._index);l(Y,z,N,U,_._values,_._index,_._ptr)}return _},r.prototype.clone=function(){var m=new r({values:this._values?pt(this._values):void 0,index:pt(this._index),ptr:pt(this._ptr),size:pt(this._size),datatype:this._datatype});return m},r.prototype.size=function(){return this._size.slice(0)},r.prototype.map=function(m,y){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var p=this,g=this._size[0],_=this._size[1],x=function(S,w,C){return m(S,[w,C],p)};return d(this,0,g-1,0,_-1,x,y)};function d(m,y,p,g,_,x,M){var S=[],w=[],C=[],D=t,I=0;dn(m._datatype)&&(D=e.find(t,[m._datatype,m._datatype])||t,I=e.convert(0,m._datatype));for(var T=function(se,de,Se){se=x(se,de,Se),D(se,I)||(S.push(se),w.push(de))},B=g;B<=_;B++){C.push(S.length);var O=m._ptr[B],F=m._ptr[B+1];if(M)for(var z=O;z<F;z++){var N=m._index[z];N>=y&&N<=p&&T(m._values[z],N-y,B-g)}else{for(var U={},Y=O;Y<F;Y++){var ee=m._index[Y];U[ee]=m._values[Y]}for(var k=y;k<=p;k++){var q=k in U?U[k]:0;T(q,k-y,B-g)}}}return C.push(S.length),new r({values:S,index:w,ptr:C,size:[p-y+1,_-g+1]})}r.prototype.forEach=function(m,y){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var p=this,g=this._size[0],_=this._size[1],x=0;x<_;x++){var M=this._ptr[x],S=this._ptr[x+1];if(y)for(var w=M;w<S;w++){var C=this._index[w];m(this._values[w],[C,x],p)}else{for(var D={},I=M;I<S;I++){var T=this._index[I];D[T]=this._values[I]}for(var B=0;B<g;B++){var O=B in D?D[B]:0;m(O,[B,x],p)}}}},r.prototype[Symbol.iterator]=function*(){if(!this._values)throw new Error("Cannot iterate a Pattern only matrix");for(var m=this._size[1],y=0;y<m;y++)for(var p=this._ptr[y],g=this._ptr[y+1],_=p;_<g;_++){var x=this._index[_];yield{value:this._values[_],index:[x,y]}}},r.prototype.toArray=function(){return v(this._values,this._index,this._ptr,this._size,!0)},r.prototype.valueOf=function(){return v(this._values,this._index,this._ptr,this._size,!1)};function v(m,y,p,g,_){var x=g[0],M=g[1],S=[],w,C;for(w=0;w<x;w++)for(S[w]=[],C=0;C<M;C++)S[w][C]=0;for(C=0;C<M;C++)for(var D=p[C],I=p[C+1],T=D;T<I;T++)w=y[T],S[w][C]=m?_?pt(m[T]):m[T]:1;return S}return r.prototype.format=function(m){for(var y=this._size[0],p=this._size[1],g=this.density(),_="Sparse Matrix ["+At(y,m)+" x "+At(p,m)+"] density: "+At(g,m)+`
`,x=0;x<p;x++)for(var M=this._ptr[x],S=this._ptr[x+1],w=M;w<S;w++){var C=this._index[w];_+=`
    (`+At(C,m)+", "+At(x,m)+") ==> "+(this._values?At(this._values[w],m):"X")}return _},r.prototype.toString=function(){return At(this.toArray())},r.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},r.prototype.diagonal=function(m){if(m){if(Zt(m)&&(m=m.toNumber()),!it(m)||!mt(m))throw new TypeError("The parameter k must be an integer number")}else m=0;var y=m>0?m:0,p=m<0?-m:0,g=this._size[0],_=this._size[1],x=Math.min(g-p,_-y),M=[],S=[],w=[];w[0]=0;for(var C=y;C<_&&M.length<x;C++)for(var D=this._ptr[C],I=this._ptr[C+1],T=D;T<I;T++){var B=this._index[T];if(B===C-y+p){M.push(this._values[T]),S[M.length-1]=B-p;break}}return w.push(M.length),new r({values:M,index:S,ptr:w,size:[x,1]})},r.fromJSON=function(m){return new r(m)},r.diagonal=function(m,y,p,g,_){if(!$e(m))throw new TypeError("Array expected, size parameter");if(m.length!==2)throw new Error("Only two dimensions matrix are supported");if(m=m.map(function(ee){if(Zt(ee)&&(ee=ee.toNumber()),!it(ee)||!mt(ee)||ee<1)throw new Error("Size values must be positive integers");return ee}),p){if(Zt(p)&&(p=p.toNumber()),!it(p)||!mt(p))throw new TypeError("The parameter k must be an integer number")}else p=0;var x=t,M=0;dn(_)&&(x=e.find(t,[_,_])||t,M=e.convert(0,_));var S=p>0?p:0,w=p<0?-p:0,C=m[0],D=m[1],I=Math.min(C-w,D-S),T;if($e(y)){if(y.length!==I)throw new Error("Invalid value array length");T=function(k){return y[k]}}else if(bt(y)){var B=y.size();if(B.length!==1||B[0]!==I)throw new Error("Invalid matrix length");T=function(k){return y.get([k])}}else T=function(){return y};for(var O=[],F=[],z=[],N=0;N<D;N++){z.push(O.length);var U=N-S;if(U>=0&&U<I){var Y=T(U);x(Y,M)||(F.push(U+w),O.push(Y))}}return z.push(O.length),new r({values:O,index:F,ptr:z,size:[C,D]})},r.prototype.swapRows=function(m,y){if(!it(m)||!mt(m)||!it(y)||!mt(y))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return Qe(m,this._size[0]),Qe(y,this._size[0]),r._swapRows(m,y,this._size[1],this._values,this._index,this._ptr),this},r._forEachRow=function(m,y,p,g,_){for(var x=g[m],M=g[m+1],S=x;S<M;S++)_(p[S],y[S])},r._swapRows=function(m,y,p,g,_,x){for(var M=0;M<p;M++){var S=x[M],w=x[M+1],C=h(m,S,w,_),D=h(y,S,w,_);if(C<w&&D<w&&_[C]===m&&_[D]===y){if(g){var I=g[C];g[C]=g[D],g[D]=I}continue}if(C<w&&_[C]===m&&(D>=w||_[D]!==y)){var T=g?g[C]:void 0;_.splice(D,0,y),g&&g.splice(D,0,T),_.splice(D<=C?C+1:C,1),g&&g.splice(D<=C?C+1:C,1);continue}if(D<w&&_[D]===y&&(C>=w||_[C]!==m)){var B=g?g[D]:void 0;_.splice(C,0,m),g&&g.splice(C,0,B),_.splice(C<=D?D+1:D,1),g&&g.splice(C<=D?D+1:D,1)}}},r},{isClass:!0}),gc="matrix",xx=["typed","Matrix","DenseMatrix","SparseMatrix"],wx=ft(gc,xx,i=>{var{typed:e,Matrix:t,DenseMatrix:n,SparseMatrix:r}=i;return e(gc,{"":function(){return s([])},string:function(a){return s([],a)},"string, string":function(a,u){return s([],a,u)},Array:function(a){return s(a)},Matrix:function(a){return s(a,a.storage())},"Array | Matrix, string":s,"Array | Matrix, string, string":s});function s(o,a,u){if(a==="dense"||a==="default"||a===void 0)return new n(o,u);if(a==="sparse")return new r(o,u);throw new TypeError("Unknown matrix type "+JSON.stringify(a)+".")}}),vc="addScalar",Mx=["typed"],bx=ft(vc,Mx,i=>{var{typed:e}=i;return e(vc,{"number, number":eh,"Complex, Complex":function(n,r){return n.add(r)},"BigNumber, BigNumber":function(n,r){return n.plus(r)},"Fraction, Fraction":function(n,r){return n.add(r)},"Unit, Unit":function(n,r){if(n.value===null||n.value===void 0)throw new Error("Parameter x contains a unit with undefined value");if(r.value===null||r.value===void 0)throw new Error("Parameter y contains a unit with undefined value");if(!n.equalBase(r))throw new Error("Units do not match");var s=n.clone();return s.value=this(s.value,r.value),s.fixPrefix=!1,s}})}),Sx="algorithm11",Ex=["typed","equalScalar"],Tx=ft(Sx,Ex,i=>{var{typed:e,equalScalar:t}=i;return function(r,s,o,a){var u=r._values,h=r._index,c=r._ptr,l=r._size,f=r._datatype;if(!u)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var d=l[0],v=l[1],m,y=t,p=0,g=o;typeof f=="string"&&(m=f,y=e.find(t,[m,m]),p=e.convert(0,m),s=e.convert(s,m),g=e.find(o,[m,m]));for(var _=[],x=[],M=[],S=0;S<v;S++){M[S]=x.length;for(var w=c[S],C=c[S+1],D=w;D<C;D++){var I=h[D],T=a?g(s,u[D]):g(u[D],s);y(T,p)||(x.push(I),_.push(T))}}return M[v]=x.length,r.createSparseMatrix({values:_,index:x,ptr:M,size:[d,v],datatype:m})}}),Ax="algorithm14",Cx=["typed"],Lx=ft(Ax,Cx,i=>{var{typed:e}=i;return function(r,s,o,a){var u=r._data,h=r._size,c=r._datatype,l,f=o;typeof c=="string"&&(l=c,s=e.convert(s,l),f=e.find(o,[l,l]));var d=h.length>0?t(f,0,h,h[0],u,s,a):[];return r.createDenseMatrix({data:d,size:pt(h),datatype:l})};function t(n,r,s,o,a,u,h){var c=[];if(r===s.length-1)for(var l=0;l<o;l++)c[l]=h?n(u,a[l]):n(a[l],u);else for(var f=0;f<o;f++)c[f]=t(n,r+1,s,s[r+1],a[f],u,h);return c}}),Rx="multiplyScalar",Px=["typed"],Nx=ft(Rx,Px,i=>{var{typed:e}=i;return e("multiplyScalar",{"number, number":th,"Complex, Complex":function(n,r){return n.mul(r)},"BigNumber, BigNumber":function(n,r){return n.times(r)},"Fraction, Fraction":function(n,r){return n.mul(r)},"number | Fraction | BigNumber | Complex, Unit":function(n,r){var s=r.clone();return s.value=s.value===null?s._normalize(n):this(s.value,n),s},"Unit, number | Fraction | BigNumber | Complex":function(n,r){var s=n.clone();return s.value=s.value===null?s._normalize(r):this(s.value,r),s},"Unit, Unit":function(n,r){return n.multiply(r)}})}),yc="multiply",Dx=["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],Ix=ft(yc,Dx,i=>{var{typed:e,matrix:t,addScalar:n,multiplyScalar:r,equalScalar:s,dot:o}=i,a=Tx({typed:e,equalScalar:s}),u=Lx({typed:e});function h(M,S){switch(M.length){case 1:switch(S.length){case 1:if(M[0]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(M[0]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+M[0]+") must match Matrix rows ("+S[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+S.length+" dimensions)")}break;case 2:switch(S.length){case 1:if(M[1]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+M[1]+") must match Vector length ("+S[0]+")");break;case 2:if(M[1]!==S[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+M[1]+") must match Matrix B rows ("+S[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+S.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+M.length+" dimensions)")}}function c(M,S,w){if(w===0)throw new Error("Cannot multiply two empty vectors");return o(M,S)}function l(M,S){if(S.storage()!=="dense")throw new Error("Support for SparseMatrix not implemented");return f(M,S)}function f(M,S){var w=M._data,C=M._size,D=M._datatype,I=S._data,T=S._size,B=S._datatype,O=C[0],F=T[1],z,N=n,U=r;D&&B&&D===B&&typeof D=="string"&&(z=D,N=e.find(n,[z,z]),U=e.find(r,[z,z]));for(var Y=[],ee=0;ee<F;ee++){for(var k=U(w[0],I[0][ee]),q=1;q<O;q++)k=N(k,U(w[q],I[q][ee]));Y[ee]=k}return M.createDenseMatrix({data:Y,size:[F],datatype:z})}var d=e("_multiplyMatrixVector",{"DenseMatrix, any":m,"SparseMatrix, any":g}),v=e("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":y,"DenseMatrix, SparseMatrix":p,"SparseMatrix, DenseMatrix":_,"SparseMatrix, SparseMatrix":x});function m(M,S){var w=M._data,C=M._size,D=M._datatype,I=S._data,T=S._datatype,B=C[0],O=C[1],F,z=n,N=r;D&&T&&D===T&&typeof D=="string"&&(F=D,z=e.find(n,[F,F]),N=e.find(r,[F,F]));for(var U=[],Y=0;Y<B;Y++){for(var ee=w[Y],k=N(ee[0],I[0]),q=1;q<O;q++)k=z(k,N(ee[q],I[q]));U[Y]=k}return M.createDenseMatrix({data:U,size:[B],datatype:F})}function y(M,S){var w=M._data,C=M._size,D=M._datatype,I=S._data,T=S._size,B=S._datatype,O=C[0],F=C[1],z=T[1],N,U=n,Y=r;D&&B&&D===B&&typeof D=="string"&&(N=D,U=e.find(n,[N,N]),Y=e.find(r,[N,N]));for(var ee=[],k=0;k<O;k++){var q=w[k];ee[k]=[];for(var ae=0;ae<z;ae++){for(var se=Y(q[0],I[0][ae]),de=1;de<F;de++)se=U(se,Y(q[de],I[de][ae]));ee[k][ae]=se}}return M.createDenseMatrix({data:ee,size:[O,z],datatype:N})}function p(M,S){var w=M._data,C=M._size,D=M._datatype,I=S._values,T=S._index,B=S._ptr,O=S._size,F=S._datatype;if(!I)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var z=C[0],N=O[1],U,Y=n,ee=r,k=s,q=0;D&&F&&D===F&&typeof D=="string"&&(U=D,Y=e.find(n,[U,U]),ee=e.find(r,[U,U]),k=e.find(s,[U,U]),q=e.convert(0,U));for(var ae=[],se=[],de=[],Se=S.createSparseMatrix({values:ae,index:se,ptr:de,size:[z,N],datatype:U}),Q=0;Q<N;Q++){de[Q]=se.length;var ve=B[Q],xe=B[Q+1];if(xe>ve)for(var fe=0,pe=0;pe<z;pe++){for(var Pe=pe+1,Z=void 0,K=ve;K<xe;K++){var oe=T[K];fe!==Pe?(Z=ee(w[pe][oe],I[K]),fe=Pe):Z=Y(Z,ee(w[pe][oe],I[K]))}fe===Pe&&!k(Z,q)&&(se.push(pe),ae.push(Z))}}return de[N]=se.length,Se}function g(M,S){var w=M._values,C=M._index,D=M._ptr,I=M._datatype;if(!w)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var T=S._data,B=S._datatype,O=M._size[0],F=S._size[0],z=[],N=[],U=[],Y,ee=n,k=r,q=s,ae=0;I&&B&&I===B&&typeof I=="string"&&(Y=I,ee=e.find(n,[Y,Y]),k=e.find(r,[Y,Y]),q=e.find(s,[Y,Y]),ae=e.convert(0,Y));var se=[],de=[];U[0]=0;for(var Se=0;Se<F;Se++){var Q=T[Se];if(!q(Q,ae))for(var ve=D[Se],xe=D[Se+1],fe=ve;fe<xe;fe++){var pe=C[fe];de[pe]?se[pe]=ee(se[pe],k(Q,w[fe])):(de[pe]=!0,N.push(pe),se[pe]=k(Q,w[fe]))}}for(var Pe=N.length,Z=0;Z<Pe;Z++){var K=N[Z];z[Z]=se[K]}return U[1]=N.length,M.createSparseMatrix({values:z,index:N,ptr:U,size:[O,1],datatype:Y})}function _(M,S){var w=M._values,C=M._index,D=M._ptr,I=M._datatype;if(!w)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var T=S._data,B=S._datatype,O=M._size[0],F=S._size[0],z=S._size[1],N,U=n,Y=r,ee=s,k=0;I&&B&&I===B&&typeof I=="string"&&(N=I,U=e.find(n,[N,N]),Y=e.find(r,[N,N]),ee=e.find(s,[N,N]),k=e.convert(0,N));for(var q=[],ae=[],se=[],de=M.createSparseMatrix({values:q,index:ae,ptr:se,size:[O,z],datatype:N}),Se=[],Q=[],ve=0;ve<z;ve++){se[ve]=ae.length;for(var xe=ve+1,fe=0;fe<F;fe++){var pe=T[fe][ve];if(!ee(pe,k))for(var Pe=D[fe],Z=D[fe+1],K=Pe;K<Z;K++){var oe=C[K];Q[oe]!==xe?(Q[oe]=xe,ae.push(oe),Se[oe]=Y(pe,w[K])):Se[oe]=U(Se[oe],Y(pe,w[K]))}}for(var me=se[ve],he=ae.length,Te=me;Te<he;Te++){var Le=ae[Te];q[Te]=Se[Le]}}return se[z]=ae.length,de}function x(M,S){var w=M._values,C=M._index,D=M._ptr,I=M._datatype,T=S._values,B=S._index,O=S._ptr,F=S._datatype,z=M._size[0],N=S._size[1],U=w&&T,Y,ee=n,k=r;I&&F&&I===F&&typeof I=="string"&&(Y=I,ee=e.find(n,[Y,Y]),k=e.find(r,[Y,Y]));for(var q=U?[]:void 0,ae=[],se=[],de=M.createSparseMatrix({values:q,index:ae,ptr:se,size:[z,N],datatype:Y}),Se=U?[]:void 0,Q=[],ve,xe,fe,pe,Pe,Z,K,oe,me=0;me<N;me++){se[me]=ae.length;var he=me+1;for(Pe=O[me],Z=O[me+1],pe=Pe;pe<Z;pe++)if(oe=B[pe],U)for(xe=D[oe],fe=D[oe+1],ve=xe;ve<fe;ve++)K=C[ve],Q[K]!==he?(Q[K]=he,ae.push(K),Se[K]=k(T[pe],w[ve])):Se[K]=ee(Se[K],k(T[pe],w[ve]));else for(xe=D[oe],fe=D[oe+1],ve=xe;ve<fe;ve++)K=C[ve],Q[K]!==he&&(Q[K]=he,ae.push(K));if(U)for(var Te=se[me],Le=ae.length,R=Te;R<Le;R++){var V=ae[R];q[R]=Se[V]}}return se[N]=ae.length,de}return e(yc,Cy({"Array, Array":function(S,w){h($n(S),$n(w));var C=this(t(S),t(w));return bt(C)?C.valueOf():C},"Matrix, Matrix":function(S,w){var C=S.size(),D=w.size();return h(C,D),C.length===1?D.length===1?c(S,w,C[0]):l(S,w):D.length===1?d(S,w):v(S,w)},"Matrix, Array":function(S,w){return this(S,t(w))},"Array, Matrix":function(S,w){return this(t(S,w.storage()),w)},"SparseMatrix, any":function(S,w){return a(S,w,r,!1)},"DenseMatrix, any":function(S,w){return u(S,w,r,!1)},"any, SparseMatrix":function(S,w){return a(w,S,r,!0)},"any, DenseMatrix":function(S,w){return u(w,S,r,!0)},"Array, any":function(S,w){return u(t(S),w,r,!1).valueOf()},"any, Array":function(S,w){return u(t(w),S,r,!0).valueOf()},"any, any":r,"any, any, ...any":function(S,w,C){for(var D=this(S,w),I=0;I<C.length;I++)D=this(D,C[I]);return D}},r.signatures))}),_c="conj",Fx=["typed"],zx=ft(_c,Fx,i=>{var{typed:e}=i;return e(_c,{number:function(n){return n},BigNumber:function(n){return n},Complex:function(n){return n.conjugate()},"Array | Matrix":function(n){return Qu(n,this)}})});function Ox(){throw new Error('No "matrix" implementation available')}var xc="size",Bx=["typed","config","?matrix"],Ux=ft(xc,Bx,i=>{var{typed:e,config:t,matrix:n}=i;return e(xc,{Matrix:function(s){return s.create(s.size())},Array:$n,string:function(s){return t.matrix==="Array"?[s.length]:n([s.length])},"number | Complex | BigNumber | Unit | boolean | null":function(s){return t.matrix==="Array"?[]:n?n([]):Ox()}})}),wc="dot",Hx=["typed","addScalar","multiplyScalar","conj","size"],Vx=ft(wc,Hx,i=>{var{typed:e,addScalar:t,multiplyScalar:n,conj:r,size:s}=i;return e(wc,{"Array | DenseMatrix, Array | DenseMatrix":a,"SparseMatrix, SparseMatrix":u});function o(c,l){var f=h(c),d=h(l),v,m;if(f.length===1)v=f[0];else if(f.length===2&&f[1]===1)v=f[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+f.join(", ")+")");if(d.length===1)m=d[0];else if(d.length===2&&d[1]===1)m=d[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+d.join(", ")+")");if(v!==m)throw new RangeError("Vectors must have equal length ("+v+" != "+m+")");if(v===0)throw new RangeError("Cannot calculate the dot product of empty vectors");return v}function a(c,l){var f=o(c,l),d=bt(c)?c._data:c,v=bt(c)?c._datatype:void 0,m=bt(l)?l._data:l,y=bt(l)?l._datatype:void 0,p=h(c).length===2,g=h(l).length===2,_=t,x=n;if(v&&y&&v===y&&typeof v=="string"){var M=v;_=e.find(t,[M,M]),x=e.find(n,[M,M])}if(!p&&!g){for(var S=x(r(d[0]),m[0]),w=1;w<f;w++)S=_(S,x(r(d[w]),m[w]));return S}if(!p&&g){for(var C=x(r(d[0]),m[0][0]),D=1;D<f;D++)C=_(C,x(r(d[D]),m[D][0]));return C}if(p&&!g){for(var I=x(r(d[0][0]),m[0]),T=1;T<f;T++)I=_(I,x(r(d[T][0]),m[T]));return I}if(p&&g){for(var B=x(r(d[0][0]),m[0][0]),O=1;O<f;O++)B=_(B,x(r(d[O][0]),m[O][0]));return B}}function u(c,l){o(c,l);for(var f=c._index,d=c._values,v=l._index,m=l._values,y=0,p=t,g=n,_=0,x=0;_<f.length&&x<v.length;){var M=f[_],S=v[x];if(M<S){_++;continue}if(M>S){x++;continue}M===S&&(y=p(y,g(d[_],m[x])),_++,x++)}return y}function h(c){return bt(c)?c.size():s(c)}}),Gx=ex({config:Os}),kx=ix({}),Wx=ox({}),Fa=cx({}),nh=fx({Matrix:Fa}),mn=i_({BigNumber:Gx,Complex:kx,DenseMatrix:nh,Fraction:Wx}),ih=bx({typed:mn}),qx=zx({typed:mn}),rh=gx({config:Os,typed:mn}),sh=Nx({typed:mn}),Xx=_x({Matrix:Fa,equalScalar:rh,typed:mn}),oh=wx({DenseMatrix:nh,Matrix:Fa,SparseMatrix:Xx,typed:mn}),Zx=Ux({matrix:oh,config:Os,typed:mn}),Yx=Vx({addScalar:ih,conj:qx,multiplyScalar:sh,size:Zx,typed:mn}),Jx=Ix({addScalar:ih,dot:Yx,equalScalar:rh,matrix:oh,multiplyScalar:sh,typed:mn});export{Ye as B,T0 as C,Sr as L,ha as M,Ct as P,hu as S,P as V,ke as W,Lt as a,ct as b,_a as c,Jx as d,Qc as e,oh as m};
